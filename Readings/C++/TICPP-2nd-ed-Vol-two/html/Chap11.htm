<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:C:\TEMP\TicV2\html\TicV2.rtf
Application Directory:C:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:08/19/2001
Translation Time:14:25:08
Translation Platform:Win32
Number of Output files:19
This File:C:\TEMP\TicV2\html\Chap11.htm
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html">
<TITLE>11: Design patterns</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF"><DIV ALIGN="CENTER">
  <a href="http://www.MindView.net">
  <img src="mindview.gif" alt="MindView Inc." BORDER = "0"></a>
  <CENTER>
    <FONT FACE="Verdana, Tahoma, Arial, Helvetica, Sans" size = "-1">
    [ <a href="README.txt">Viewing Hints</a> ]
    [ <a href="RevisionHistory.htm">Revision History</a> ]
    [ <a href="http://www.mindview.net/Books/TICPP/ThinkingInCPP2e.html">Book Home Page</a> ]
    [ <a href="http://www.mindview.net/Etc/MailingList.html">Free Newsletter</a> ] <br>
    [ <a href="http://www.mindview.net/Seminars">Seminars</a> ]
    [ <a href="http://www.mindview.net/CDs">Seminars on CD ROM</a> ]
    [ <a href="http://www.mindview.net/Services">Consulting</a> ]
    </FONT>
  <H2><FONT FACE="Verdana, Tahoma, Arial, Helvetica, Sans">
  Thinking in C++, 2nd edition, Volume 2<br>
  <small>Revision 4.0</small></FONT></H2>
  <H3><FONT FACE="Verdana, Tahoma, Arial, Helvetica, Sans">
  by Bruce Eckel &amp; Chuck Allison<br>&copy;2001 MindView, Inc.</FONT></H3>
  
    <FONT FACE="Verdana, Tahoma, Arial, Helvetica, Sans" size = "-1">
     [ <a href="Chap10.htm">Previous Chapter</a> ] 
    
    [ <a href="SimpCont.htm">Short TOC</a> ] 
    [ <a href="Contents.htm">Table of Contents</a> ] 
  
        [ <a href="DocIdx.htm">Index</a> ]
        
     [ <a href="AppendA.htm">Next Chapter</a> ] 
    </FONT>
    
  </CENTER>
  </P></DIV><A NAME="_Toc312374156"></A><A NAME="_Toc375545412"></A><A NAME="_Toc407441460"></A><A NAME="_Toc408018793"></A><A NAME="DesignPatterns"></A><A NAME="_Toc519042116"></A><A NAME="Heading325"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H1 ALIGN="LEFT">
11: Design patterns</H1></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana" SIZE=4><a NAME="TIC2V2_CHAPTER11_I1"></a>

&#8220;... describes a problem which occurs over and over again in our
environment, and then describes the core of the solution to that problem, in
such a way that you can use this solution a million times over, without ever
doing it the same way twice&#8221;  &#8211; Christopher
Alexander</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana" SIZE=4>This chapter introduces the
important and yet non-traditional &#8220;patterns&#8221; approach to program
design. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">[[ Much of the prose in this chapter
still needs work, but the examples all compile. Also, more patterns and examples
are forthcoming ]]
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I1">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I2"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Probably the most important step forward
in object-oriented design is the &#8220;design patterns&#8221; movement,
chronicled in <A NAME="Index642"></A><A NAME="Index643"></A><I>Design
Patterns</I>, by Gamma, Helm, Johnson &amp; Vlissides (Addison-Wesley
1995).</FONT><A NAME="fnB28" HREF="#fn28">[28]</A><FONT FACE="Georgia"> That
book shows 23 different solutions to particular classes of problems. In this
chapter, the basic concepts of design patterns will be introduced along with
examples. This should whet your appetite to read <I>Design Patterns</I> (a
source of what has now become an essential, almost mandatory, vocabulary for OOP
programmers).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I2">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I3"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The latter part of this chapter contains
an example of the design evolution process, starting with an initial solution
and moving through the logic and process of evolving the solution to more
appropriate designs. The program shown (a trash recycling simulation) has
evolved over time, and you can look at that evolution as a prototype for the way
your own design can start as an adequate solution to a particular problem and
evolve into a flexible approach to a class of
problems.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I3">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I4"></a>
</FONT><A NAME="_Toc408018794"></A><A NAME="_Toc519042117"></A><BR></P></DIV>
<A NAME="Heading326"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
The pattern concept</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Initially, you can think of a pattern as
an especially clever and insightful way of solving a particular class of
problems. That is, it looks like a lot of people have worked out all the angles
of a problem and have come up with the most general, flexible solution for it.
The problem could be one you have seen and solved before, but your solution
probably didn&#8217;t have the kind of completeness you&#8217;ll see embodied in
a pattern.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I4">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I5"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although they&#8217;re called
&#8220;design patterns,&#8221; they really aren&#8217;t tied to the realm of
design. A pattern seems to stand apart from the traditional way of thinking
about analysis, design, and implementation. Instead, a pattern embodies a
complete idea within a program, and thus it can sometimes appear at the analysis
phase or high-level design phase. This is interesting because a pattern has a
direct implementation in code and so you might not expect it to show up before
low-level design or implementation (and in fact you might not realize that you
need a particular pattern until you get to those
phases).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I5">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I6"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The basic concept of a pattern can also
be seen as the basic concept of program design: adding layers of
<A NAME="Index644"></A><A NAME="Index645"></A>abstraction. Whenever you abstract
something you&#8217;re isolating particular details, and one of the most
compelling motivations behind this is to <I>separate things that change from
things that stay the same</I>. Another way to put this is that once you find
some part of your program that&#8217;s likely to change for one reason or
another, you&#8217;ll want to keep those changes from propagating other
modifications throughout your code. Not only does this make the code much
cheaper to maintain, but it also turns out that it is usually simpler to
understand (which results in lowered
costs).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I6">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I7"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Often, the most difficult part of
developing an elegant and cheap-to-maintain design is in discovering what I call
&#8220;the
<A NAME="Index646"></A><A NAME="Index647"></A><A NAME="Index648"></A>vector of
change.&#8221; (Here, &#8220;vector&#8221; refers to the maximum gradient and
not a container class.) This means finding the most important thing that changes
in your system, or put another way, discovering where your greatest cost is.
Once you discover the vector of change, you have the focal point around which to
structure your design.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I7">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I8"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So the goal of design patterns is to
isolate changes in your code. If you look at it this way, you&#8217;ve been
seeing some design patterns already in this book. For example,
<A NAME="Index649"></A>inheritance could be thought of as a design pattern
(albeit one implemented by the compiler). It allows you to express differences
in behavior (that&#8217;s the thing that changes) in objects that all have the
same interface (that&#8217;s what stays the same).
<A NAME="Index650"></A>Composition could also be considered a pattern, since it
allows you to change &#8211; dynamically or statically &#8211; the objects that
implement your class, and thus the way that class works. Normally, however,
features that are directly supported by a programming language are not
classified as design
patterns.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I8">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I9"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ve also already seen another
pattern that appears in <I>Design Patterns</I>: the
<A NAME="Index651"></A><I>iterator</I>. This is the fundamental tool used in the
design of the STL; it hides the particular implementation of the container as
you&#8217;re stepping through and selecting the elements one by one. The
iterator allows you to write generic code that performs an operation on all of
the elements in a range without regard to the container that holds the range.
Thus your generic code can be used with any container that can produce
iterators.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I9">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I10"></a>
</FONT><A NAME="_Toc408018795"></A><A NAME="_Toc519042118"></A><BR></P></DIV>
<A NAME="Heading327"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
The singleton</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Possibly the simplest design pattern is
the <A NAME="Index652"></A><I>singleton</I>, which is a way to provide one and
only one instance of an
object:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I10">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I11"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:SingletonPattern.cpp</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Singleton {
  <font color=#0000ff>static</font> Singleton s;
  <font color=#0000ff>int</font> i;
  Singleton(<font color=#0000ff>int</font> x) : i(x) { }
  <font color=#0000ff>void</font> <font color=#0000ff>operator</font>=(Singleton&amp;);
  Singleton(<font color=#0000ff>const</font> Singleton&amp;);
<font color=#0000ff>public</font>:
  <font color=#0000ff>static</font> Singleton&amp; getHandle() {
    <font color=#0000ff>return</font> s;
  }
  <font color=#0000ff>int</font> getValue() { <font color=#0000ff>return</font> i; }
  <font color=#0000ff>void</font> setValue(<font color=#0000ff>int</font> x) { i = x; }
};

Singleton Singleton::s(47);

<font color=#0000ff>int</font> main() {
  Singleton&amp; s = Singleton::getHandle();
  cout &lt;&lt; s.getValue() &lt;&lt; endl;
  Singleton&amp; s2 = Singleton::getHandle();
  s2.setValue(9);
  cout &lt;&lt; s.getValue() &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The key to creating a singleton is to
prevent the client programmer from having any way to create an object except the
ways you provide. To do this, you must declare all
<A NAME="Index653"></A><A NAME="Index654"></A>constructors as <B>private</B>,
and you must<B> </B>create at least one constructor to prevent the compiler from
<A NAME="Index655"></A><A NAME="Index656"></A>synthesizing a default constructor
for you.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I11">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I12"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">At this point, you decide how
you&#8217;re going to create your object. Here, it&#8217;s created statically,
but you can also wait until the client programmer asks for one and create it on
demand. In any case, the object should be stored privately. You provide access
through public methods. Here, <B>getHandle(&#160;)</B> produces a reference to
the <B>Singleton</B> object. The rest of the interface (<B>getValue(&#160;)</B>
and <B>setValue(&#160;)</B>) is the regular class
interface.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I12">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I13"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that you aren&#8217;t restricted to
creating only one object. This technique easily supports the creation of a
limited pool of objects. In that situation, however, you can be confronted with
the problem of sharing objects in the pool. If this is an issue, you can create
a solution involving a check-out and check-in of the shared
objects.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I13">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I14"></a>
</FONT><BR></P></DIV>
<A NAME="Heading328"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Variations on singleton</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Any static member object inside a class
is an expression of singleton: one and only one will be made. So in a sense, the
language has direct support for the idea; we certainly use it on a regular
basis. However, there&#8217;s a problem associated with static objects (member
or not), and that&#8217;s the order of initialization, as described in Volume 1
of this book. If one static object depends on another, it&#8217;s important that
the order of initialization proceed
correctly.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I14">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I15"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In Volume 1, you were shown how a static
object defined inside a function can be used to control initialization order.
This delays the initialization of the object until the first time the function
is called. If the function returns a reference to the static object, it gives
you the effect of a singleton while removing much of the worry of static
initialization. For example, suppose you want to create a logfile upon the first
call to a function which returns a reference to that logfile. This header file
will do the trick:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I15">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I16"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:LogFile.h</font>
#ifndef LOGFILE_H
#define LOGFILE_H
#include &lt;fstream&gt;

std::ofstream&amp; logfile();

#endif <font color=#009900>// LOGFILE_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The implementation <I>must not be
inlined</I>, because that would mean that the whole function, including the
static object definition within, could be duplicated in any translation unit
where it&#8217;s included, and you&#8217;d end up with multiple copies of the
static object. This would most certainly foil the attempts to control the order
of initialization (but potentially in a very subtle and hard-to-detect fashion).
So the implementation must be
separate:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I16">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I17"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:LogFile.cpp {O}</font>
#include <font color=#004488>"LogFile.h"</font>
std::ofstream&amp; logfile() {
  <font color=#0000ff>static</font> std::ofstream log(<font color=#004488>"Logfile.log"</font>);
  <font color=#0000ff>return</font> log;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now the <B>log</B> object will not be
initialized until the first time <B>logfile(&#160;)</B> is called. So if you use
the function in one
file:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I17">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I18"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:UseLog1.h</font>
#ifndef USELOG1_H
#define USELOG1_H
<font color=#0000ff>void</font> f();
#endif <font color=#009900>// USELOG1_H ///:~</font>

<font color=#009900>//: C11:UseLog1.cpp {O}</font>
#include <font color=#004488>"UseLog1.h"</font>
#include <font color=#004488>"LogFile.h"</font>
<font color=#0000ff>void</font> f() {
  logfile() &lt;&lt; __FILE__ &lt;&lt; std::endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">And again in another
file:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I18">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I19"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:UseLog2.cpp</font>
<font color=#009900>//{L} UseLog1 LogFile ../TestSuite/Test</font>
#include <font color=#004488>"UseLog1.h"</font>
#include <font color=#004488>"LogFile.h"</font>
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>void</font> g() {
  logfile() &lt;&lt; __FILE__ &lt;&lt; endl;
} 

<font color=#0000ff>int</font> main() {
  f();
  g();
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Then the <B>log </B>object doesn&#8217;t
get created until the first call to
<B>f(&#160;)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I19">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I20"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can easily combine the creation of
the static object inside a member function with the singleton class.
<B>SingletonPattern.cpp</B> can be modified to use this
approach:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I20">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I21"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:SingletonPattern2.cpp</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Singleton {
  <font color=#0000ff>int</font> i;
  Singleton(<font color=#0000ff>int</font> x) : i(x) { }
  <font color=#0000ff>void</font> <font color=#0000ff>operator</font>=(Singleton&amp;);
  Singleton(<font color=#0000ff>const</font> Singleton&amp;);
<font color=#0000ff>public</font>:
  <font color=#0000ff>static</font> Singleton&amp; getHandle() {
    <font color=#0000ff>static</font> Singleton s(47);
    <font color=#0000ff>return</font> s;
  }
  <font color=#0000ff>int</font> getValue() { <font color=#0000ff>return</font> i; }
  <font color=#0000ff>void</font> setValue(<font color=#0000ff>int</font> x) { i = x; }
};

<font color=#0000ff>int</font> main() {
  Singleton&amp; s = Singleton::getHandle();
  cout &lt;&lt; s.getValue() &lt;&lt; endl;
  Singleton&amp; s2 = Singleton::getHandle();
  s2.setValue(9);
  cout &lt;&lt; s.getValue() &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An especially interesting case is if two
of these singletons depend on each other, like
this:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I21">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I22"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:FunctionStaticSingleton.cpp</font>
<font color=#009900>//{L} ../TestSuite/Test</font>

<font color=#0000ff>class</font> Singleton1 {
  Singleton1() {}
<font color=#0000ff>public</font>:
  <font color=#0000ff>static</font> Singleton1&amp; ref() {
    <font color=#0000ff>static</font> Singleton1 single;
    <font color=#0000ff>return</font> single;
  }
};

<font color=#0000ff>class</font> Singleton2 {
  Singleton1&amp; s1;
  Singleton2(Singleton1&amp; s) : s1(s) {}
<font color=#0000ff>public</font>:
  <font color=#0000ff>static</font> Singleton2&amp; ref() {
    <font color=#0000ff>static</font> Singleton2 single(Singleton1::ref());
    <font color=#0000ff>return</font> single;
  }
  Singleton1&amp; f() { <font color=#0000ff>return</font> s1; }
};

<font color=#0000ff>int</font> main() {
  Singleton1&amp; s1 = Singleton2::ref().f();
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When <B>Singleton2::ref(&#160;)</B> is
called, it causes its sole <B>Singleton2</B> object to be created. In the
process of this creation, <B>Singleton1::ref(&#160;)</B> is called, and that
causes the sole <B>Singleton1</B> object to be created. Because this technique
doesn&#8217;t rely on the order of linking or loading, the programmer has much
better control over initialization, leading to less
problems.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I22">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I23"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll see further examples of the
singleton pattern in the rest of this
chapter.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I23">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I24"></a>
</FONT><A NAME="_Toc408018796"></A><A NAME="_Toc519042119"></A><BR></P></DIV>
<A NAME="Heading329"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Classifying patterns</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <I>Design Patterns</I> book discusses
23 different patterns, classified under three purposes (all of which revolve
around the particular aspect that can vary). The three purposes
are:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I24">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I25"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index657"></A><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	<A NAME="Index658"></A></FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Creational</B>:
how an object can be created. This often involves isolating the details of
object creation so your code isn&#8217;t dependent on what types of objects
there are and thus doesn&#8217;t have to be changed when you add a new type of
object. The aforementioned <I>Singleton</I> is classified as a creational
pattern, and later in this chapter you&#8217;ll see examples of <I>Factory
Method</I> and <I>Prototype</I>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index659"></A><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	<A NAME="Index660"></A></FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Structural</B>:
designing objects to satisfy particular project constraints. These work with the
way objects are connected with other objects to ensure that changes in the
system don&#8217;t require changes to those connections.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index661"></A><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	<A NAME="Index662"></A></FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Behavioral</B>:
objects that handle particular types of actions within a program. These
encapsulate processes that you want to perform, such as interpreting a language,
fulfilling a request, moving through a sequence (as in an iterator), or
implementing an algorithm. This chapter contains examples of the <I>Observer</I>
and the <I>Visitor</I> patterns.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <I>Design Patterns</I> book has a
section on each of its 23 patterns along with one or more examples for each,
typically in C++ but sometimes in Smalltalk. This book will not repeat all the
details of the patterns shown in <I>Design Patterns</I> since that book stands
on its own and should be studied separately. The catalog and examples provided
here are intended to rapidly give you a grasp of the patterns, so you can get a
decent feel for what patterns are about and why they are so
important.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I25">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I26"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">[[ Describe different form of
categorization, based on what you want to accomplish rather than the way the
patterns look. More categories, but should result in easier-to-understand,
faster selection
]]]
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I26">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I27"></a>
</FONT><A NAME="_Toc375545413"></A><A NAME="_Toc408018797"></A><A NAME="_Toc519042120"></A><BR></P></DIV>
<A NAME="Heading330"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Features, idioms, patterns</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">How things have gotten confused;
conflicting pattern descriptions, na&iuml;ve &#8220;patterns,&#8221; patterns
are not trivial nor are they represented by features that are built into the
language, nor are they things that you do almost all the time. Constructors and
destructors, for example, could be called the &#8220;guaranteed initialization
and cleanup design pattern.&#8221; This is an important and essential idea, but
it&#8217;s built into the
language.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I27">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I28"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Another example comes from various forms
of aggregation. Aggregation is a completely fundamental principle in
object-oriented programming: you make objects out of other objects [[ make
reference to basic tenets of OO ]]. Yet sometimes this idea is classified as a
pattern, which tends to confuse the issue. This is unfortunate because it
pollutes the idea of the design pattern and suggest that anything that surprises
you the first time you see it should be a design
pattern.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I28">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I29"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Another misguided example is found in the
Java language; the designers of the &#8220;JavaBeans&#8221; specification
decided to refer to a simple naming convention as a design pattern (you say
<B>getInfo(&#160;)</B> for a member function that returns an <B>Info</B>
property and <B>setInfo(&#160;)</B> for one that changes the internal
<B>Info</B> property; the use of the &#8220;get&#8221; and &#8220;set&#8221;
strings is what they decided constituted calling it a design
pattern).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I29">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I30"></a>
</FONT><A NAME="_Toc519042121"></A><BR></P></DIV>
<A NAME="Heading331"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Basic complexity hiding</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll often find that messy code
can be cleaned up by putting it inside a class. This is more than fastidiousness
&#8211; if nothing else, it aids readability and therefore maintainability, and
it can often lead to
reusability.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I30">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I31"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Simple Veneer (fa&ccedil;ade, Adapter
(existing system), Bridge (designed in),

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I31">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I32"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Hiding types (polymorphism, iterators,
proxy)
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I32">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I33"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Hiding connections
(mediator,)
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I33">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I34"></a>
</FONT><A NAME="_Toc519042122"></A><BR></P></DIV>
<A NAME="Heading332"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Dynamic aggregation</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">[[ This may actually be the
&#8220;builder&#8221; design pattern in some form
]]
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I34">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I35"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The examples we&#8217;ve seen so far are
illustrative, but fairly simple. It&#8217;s useful to see an example that has
more complexity so you can see that the STL will work in all
situations.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I35">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I36"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">[[ Add a factory method that takes a
vector of string]]
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I36">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I37"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The class that will be created as the
example will be reasonably complex: it&#8217;s a bicycle which can have a choice
of parts. In addition, you can change the parts during the lifetime of a
<B>Bicycle</B> object; this includes the ability to add new parts or to upgrade
from standard-quality parts to &#8220;fancy&#8221; parts. The <B>BicyclePart</B>
class is a base class with many different types, and the <B>Bicycle</B> class
contains a <B>vector&lt;BicyclePart*&gt;</B> to hold the various combination of
parts that may be attached to a
<B>Bicycle</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I37">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I38"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:Bicycle.h</font>
<font color=#009900>// Complex class involving dynamic aggregation</font>
#ifndef BICYCLE_H
#define BICYCLE_H
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;typeinfo&gt;

<font color=#0000ff>class</font> LeakChecker {
  <font color=#0000ff>int</font> count;
<font color=#0000ff>public</font>:
  LeakChecker() : count(0) {}
  <font color=#0000ff>void</font> print() {
    std::cout &lt;&lt; count &lt;&lt; std::endl; 
  }
  ~LeakChecker() { print(); }
  <font color=#0000ff>void</font> <font color=#0000ff>operator</font>++(<font color=#0000ff>int</font>) { count++; }
  <font color=#0000ff>void</font> <font color=#0000ff>operator</font>--(<font color=#0000ff>int</font>) { count--; }
};

<font color=#0000ff>class</font> BicyclePart {
  <font color=#0000ff>static</font> LeakChecker lc;
<font color=#0000ff>public</font>:
  BicyclePart() { lc++; }
  <font color=#0000ff>virtual</font> BicyclePart* clone() = 0;
  <font color=#0000ff>virtual</font> ~BicyclePart() { lc--; }
  <font color=#0000ff>friend</font> std::ostream&amp; 
  <font color=#0000ff>operator</font>&lt;&lt;(std::ostream&amp; os, BicyclePart* bp) {
    <font color=#0000ff>return</font> os &lt;&lt; <font color=#0000ff>typeid</font>(*bp).name();
  }
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> Bicycle;
};

<font color=#0000ff>enum</font> BPart {
  Frame, Wheel, Seat, HandleBar, 
  Sprocket, Deraileur,
};

<font color=#0000ff>template</font>&lt;BPart id&gt; 
<font color=#0000ff>class</font> Part : <font color=#0000ff>public</font> BicyclePart {
<font color=#0000ff>public</font>:
  BicyclePart* clone() { <font color=#0000ff>return</font> <font color=#0000ff>new</font> Part&lt;id&gt;; }
};

<font color=#0000ff>class</font> Bicycle {
<font color=#0000ff>public</font>:
  <font color=#0000ff>typedef</font> std::vector&lt;BicyclePart*&gt; VBP;
  Bicycle();
  Bicycle(<font color=#0000ff>const</font> Bicycle&amp; old);
  Bicycle&amp; <font color=#0000ff>operator</font>=(<font color=#0000ff>const</font> Bicycle&amp; old);
  <font color=#009900>// [Other operators as needed go here:]</font>
  <font color=#009900>// [...]</font>
  <font color=#009900>// [...]</font>
  ~Bicycle() { purge(); }
  <font color=#009900>// So you can change parts on a bike (but be </font>
  <font color=#009900>// careful: you must clean up any objects you</font>
  <font color=#009900>// remove from the bicycle!)</font>
  VBP&amp; bikeParts() { <font color=#0000ff>return</font> parts; }
  <font color=#0000ff>friend</font> std::ostream&amp; 
  <font color=#0000ff>operator</font>&lt;&lt;(std::ostream&amp; os, Bicycle* b);
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(std::vector&lt;Bicycle*&gt;&amp; vb, 
    std::ostream&amp; os = std::cout);
<font color=#0000ff>private</font>:
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> counter;
  <font color=#0000ff>int</font> id;
  VBP parts;
  <font color=#0000ff>void</font> purge();
};

<font color=#009900>// Both the Bicycle and the generator should </font>
<font color=#009900>// provide more variety than this. But this gives</font>
<font color=#009900>// you the idea.</font>
<font color=#0000ff>struct</font> BicycleGenerator {
  Bicycle* <font color=#0000ff>operator</font>()() {
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> Bicycle;
  }
}; 
#endif <font color=#009900>// BICYCLE_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>operator&lt;&lt;</B> for
<B>ostream</B> and <B>Bicycle</B> moves through and calls the
<B>operator&lt;&lt;</B> for each <B>BicyclePart</B>, and that prints out the
class name of the part so you can see what a <B>Bicycle</B> contains. The
<B>BicyclePart::clone(&#160;)</B> member function is necessary in the
copy-constructor of <B>Bicycle</B>, since it just has a
<B>vector&lt;BicyclePart*&gt;</B> and wouldn&#8217;t otherwise know how to copy
the <B>BicyclePart</B>s correctly. The cloning process, of course, will be more
involved when there are data members in a
<B>BicyclePart</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I38">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I39"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>BicyclePart::partcount</B> is used to
keep track of the number of parts created and destroyed (so you can detect
memory leaks). It is incremented every time a new <B>BicyclePart</B> is created
and decremented when one is destroyed; also, when <B>partcount</B> goes to zero
this is reported and if it goes below zero there will be an
<B>assert(&#160;)</B>
failure.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I39">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I40"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you want to change <B>BicyclePart</B>s
on a <B>Bicycle</B>, you just call <B>Bicycle::bikeParts(&#160;)</B> to get the
<B>vector&lt;BicyclePart*&gt;</B> which you can then modify. But whenever you
remove a part from a <B>Bicycle</B>, you must call <B>delete</B> for that
pointer, otherwise it won&#8217;t get cleaned
up.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I40">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I41"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s the
implementation:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I41">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I42"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:Bicycle.cpp {O}</font>
<font color=#009900>// Bicycle implementation</font>
#include <font color=#004488>"Bicycle.h"</font>
#include &lt;map&gt;
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#009900>// Static member definitions:</font>
LeakChecker BicyclePart::lc;
<font color=#0000ff>int</font> Bicycle::counter = 0;

Bicycle::Bicycle() : id(counter++) {
  BicyclePart *bp[] = {
    <font color=#0000ff>new</font> Part&lt;Frame&gt;, 
    <font color=#0000ff>new</font> Part&lt;Wheel&gt;, <font color=#0000ff>new</font> Part&lt;Wheel&gt;, 
    <font color=#0000ff>new</font> Part&lt;Seat&gt;, <font color=#0000ff>new</font> Part&lt;HandleBar&gt;,
    <font color=#0000ff>new</font> Part&lt;Sprocket&gt;,  <font color=#0000ff>new</font> Part&lt;Deraileur&gt;,
  };
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> bplen = <font color=#0000ff>sizeof</font> bp / <font color=#0000ff>sizeof</font> *bp;
  parts = VBP(bp, bp + bplen);
}

Bicycle::Bicycle(<font color=#0000ff>const</font> Bicycle&amp; old) 
  : parts(old.parts.begin(), old.parts.end()) {
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; parts.size(); i++)
    parts[i] = parts[i]-&gt;clone();
}

Bicycle&amp; Bicycle::<font color=#0000ff>operator</font>=(<font color=#0000ff>const</font> Bicycle&amp; old) {
  purge(); <font color=#009900>// Remove old lvalues</font>
  parts.resize(old.parts.size());
  copy(old.parts.begin(), 
    old.parts.end(), parts.begin());
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; parts.size(); i++)
    parts[i] = parts[i]-&gt;clone();
  <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
}

<font color=#0000ff>void</font> Bicycle::purge() {
  <font color=#0000ff>for</font>(VBP::iterator it = parts.begin();
    it != parts.end(); it++) {
      <font color=#0000ff>delete</font> *it;
      *it = 0; <font color=#009900>// Prevent multiple deletes</font>
  }
}

ostream&amp; <font color=#0000ff>operator</font>&lt;&lt;(ostream&amp; os, Bicycle* b) {
  copy(b-&gt;parts.begin(), b-&gt;parts.end(),
    ostream_iterator&lt;BicyclePart*&gt;(os, <font color=#004488>"\n"</font>));
  os &lt;&lt; <font color=#004488>"--------"</font> &lt;&lt; endl;
  <font color=#0000ff>return</font> os;
}

<font color=#0000ff>void</font> Bicycle::print(vector&lt;Bicycle*&gt;&amp; vb, 
  ostream&amp; os) {
  copy(vb.begin(), vb.end(),
    ostream_iterator&lt;Bicycle*&gt;(os, <font color=#004488>"\n"</font>));
  cout &lt;&lt; <font color=#004488>"--------"</font> &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s a
test:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I42">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I43"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:BikeTest.cpp</font>
<font color=#009900>//{L} Bicycle ../TestSuite/Test</font>
#include <font color=#004488>"Bicycle.h"</font>
#include &lt;algorithm&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  vector&lt;Bicycle*&gt; bikes;
  BicycleGenerator bg;
  generate_n(back_inserter(bikes), 12, bg);
  Bicycle::print(bikes);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
<A NAME="_Toc519042123"></A><BR>Factories: encapsulating object creation</H2></FONT>
<A NAME="Heading333"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you discover that you need to add
new types to a system, the most sensible first step to take is to use
polymorphism to create a common interface to those new types. This separates the
rest of the code in your system from the knowledge of the specific types that
you are adding. New types may be added without disturbing existing code ... or
so it seems. At first it would appear that the only place you need to change the
code in such a design is the place where you inherit a new type, but this is not
quite true. You must still create an object of your new type, and at the point
of creation you must specify the exact constructor to use. Thus, if the code
that creates objects is distributed throughout your application, you have the
same problem when adding new types &#8211; you must still chase down all the
points of your code where type matters. It happens to be the <I>creation</I> of
the type that matters in this case rather than the <I>use</I> of the type (which
is taken care of by polymorphism), but the effect is the same: adding a new type
can cause problems.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I43">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I44"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The solution is to force the creation of
objects to occur through a common <I>factory</I> rather than to allow the
creational code to be spread throughout your system. If all the code in your
program must go through this factory whenever it needs to create one of your
objects, then all you must do when you add a new object is to modify the
factory. 
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I44">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I45"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since every object-oriented program
creates objects, and since it&#8217;s very likely you will extend your program
by adding new types, I suspect that factories may be the most universally useful
kinds of design
patterns.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I45">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I46"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As an example, let&#8217;s revisit the
<B>Shape</B> system. One approach is to make the factory a <B>static</B> method
of the base class:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I46">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I47"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:ShapeFactory1.cpp</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"..</font><font color=#004488>/purge.h"</font>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;exception&gt;
#include &lt;vector&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Shape {
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> draw() = 0;
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> erase() = 0;
  <font color=#0000ff>virtual</font> ~Shape() {}
  <font color=#0000ff>class</font> BadShapeCreation : <font color=#0000ff>public</font> exception {
    string reason;
  <font color=#0000ff>public</font>:
    BadShapeCreation(string type) {
      reason = <font color=#004488>"Cannot create type "</font> + type;
    }
    ~BadShapeCreation() <font color=#0000ff>throw</font>() {}
    <font color=#0000ff>const</font> <font color=#0000ff>char</font> *what() <font color=#0000ff>const</font> <font color=#0000ff>throw</font>() { 
      <font color=#0000ff>return</font> reason.c_str(); 
    }
  };
  <font color=#0000ff>static</font> Shape* factory(string type) 
    <font color=#0000ff>throw</font>(BadShapeCreation);
};

<font color=#0000ff>class</font> Circle : <font color=#0000ff>public</font> Shape {
  Circle() {} <font color=#009900>// Private constructor</font>
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> Shape;
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> draw() { cout &lt;&lt; <font color=#004488>"Circle::draw\n"</font>; }
  <font color=#0000ff>void</font> erase() { cout &lt;&lt; <font color=#004488>"Circle::erase\n"</font>; }
  ~Circle() { cout &lt;&lt; <font color=#004488>"Circle::~Circle\n"</font>; }
};

<font color=#0000ff>class</font> Square : <font color=#0000ff>public</font> Shape {
  Square() {}
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> Shape;
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> draw() { cout &lt;&lt; <font color=#004488>"Square::draw\n"</font>; }
  <font color=#0000ff>void</font> erase() { cout &lt;&lt; <font color=#004488>"Square::erase\n"</font>; }
  ~Square() { cout &lt;&lt; <font color=#004488>"Square::~Square\n"</font>; }
};

Shape* Shape::factory(string type) 
  <font color=#0000ff>throw</font>(Shape::BadShapeCreation) {
  <font color=#0000ff>if</font>(type == <font color=#004488>"Circle"</font>) <font color=#0000ff>return</font> <font color=#0000ff>new</font> Circle;
  <font color=#0000ff>if</font>(type == <font color=#004488>"Square"</font>) <font color=#0000ff>return</font> <font color=#0000ff>new</font> Square;
  <font color=#0000ff>throw</font> BadShapeCreation(type);
}

<font color=#0000ff>char</font>* shlist[] = { <font color=#004488>"Circle"</font>, <font color=#004488>"Square"</font>, <font color=#004488>"Square"</font>,
  <font color=#004488>"Circle"</font>, <font color=#004488>"Circle"</font>, <font color=#004488>"Circle"</font>, <font color=#004488>"Square"</font>, <font color=#004488>""</font> };

<font color=#0000ff>int</font> main() {
  vector&lt;Shape*&gt; shapes;
  <font color=#0000ff>try</font> {
    <font color=#0000ff>for</font>(<font color=#0000ff>char</font>** cp = shlist; **cp; cp++)
      shapes.push_back(Shape::factory(*cp));
  } <font color=#0000ff>catch</font>(Shape::BadShapeCreation e) {
    cout &lt;&lt; e.what() &lt;&lt; endl;
    <font color=#0000ff>return</font> 1;
  }
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; shapes.size(); i++) {
    shapes[i]-&gt;draw();
    shapes[i]-&gt;erase();
  }
  purge(shapes);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>factory(&#160;)</B> takes an
argument that allows it to determine what type of  <B>Shape</B> to create; it
happens to be a <B>string</B> in this case but it could be any set of data. The
<B>factory(&#160;)</B> is now the only other code in the system that needs to be
changed when a new type of <B>Shape </B>is added (the initialization data for
the objects will presumably come from somewhere outside the system, and not be a
hard-coded array as in the above
example).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I47">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I48"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To ensure that the creation can only
happen in the <B>factory(&#160;)</B>, the constructors for the specific types of
<B>Shape</B> are made <B>private</B>, and <B>Shape</B> is declared a
<B>friend</B> so that <B>factory(&#160;)</B> has access to the constructors (you
could also declare only <B>Shape::factory(&#160;)</B> to be a <B>friend</B>, but
it seems reasonably harmless to declare the entire base class as a
<B>friend</B>).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I48">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I49"></a>
</FONT><A NAME="_Toc519042124"></A><BR></P></DIV>
<A NAME="Heading334"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Polymorphic factories</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>static factory(&#160;)</B> method
in the previous example forces all the creation operations to be focused in one
spot, to that&#8217;s the only place you need to change the code. This is
certainly a reasonable solution, as it throws a box around the process of
creating objects. However, the <I>Design Patterns</I> book emphasizes that the
reason for the <I>Factory Method</I> pattern is so that different types of
factories can be subclassed from the basic factory (the above design is
mentioned as a special case). However, the book does not provide an example, but
instead just repeats the example used for the <I>Abstract Factory</I>. Here is
<B>ShapeFactory1.cpp</B> modified so the factory methods are in a separate class
as virtual functions:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I49">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I50"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:ShapeFactory2.cpp</font>
<font color=#009900>// Polymorphic factory methods</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"..</font><font color=#004488>/purge.h"</font>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;exception&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Shape {
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> draw() = 0;
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> erase() = 0;
  <font color=#0000ff>virtual</font> ~Shape() {}
};

<font color=#0000ff>class</font> ShapeFactory {
  <font color=#0000ff>virtual</font> Shape* create() = 0;
  <font color=#0000ff>static</font> map&lt;string, ShapeFactory*&gt; factories;
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> ~ShapeFactory() {}
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> ShapeFactoryInitializer;
  <font color=#0000ff>class</font> BadShapeCreation : <font color=#0000ff>public</font> exception {
    string reason;
  <font color=#0000ff>public</font>:
    BadShapeCreation(string type) {
      reason = <font color=#004488>"Cannot create type "</font> + type;
    }
    ~BadShapeCreation() <font color=#0000ff>throw</font>() {}
    <font color=#0000ff>const</font> <font color=#0000ff>char</font> *what() <font color=#0000ff>const</font> <font color=#0000ff>throw</font>() { 
      <font color=#0000ff>return</font> reason.c_str(); 
    }
  };
  <font color=#0000ff>static</font> Shape* 
  createShape(string id) <font color=#0000ff>throw</font>(BadShapeCreation){
    <font color=#0000ff>if</font>(factories.find(id) != factories.end())
      <font color=#0000ff>return</font> factories[id]-&gt;create();
    <font color=#0000ff>else</font>
      <font color=#0000ff>throw</font> BadShapeCreation(id);
  }
};

<font color=#009900>// Define the static object:</font>
map&lt;string, ShapeFactory*&gt; 
  ShapeFactory::factories;

<font color=#0000ff>class</font> Circle : <font color=#0000ff>public</font> Shape {
  Circle() {} <font color=#009900>// Private constructor</font>
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> draw() { cout &lt;&lt; <font color=#004488>"Circle::draw\n"</font>; }
  <font color=#0000ff>void</font> erase() { cout &lt;&lt; <font color=#004488>"Circle::erase\n"</font>; }
  ~Circle() { cout &lt;&lt; <font color=#004488>"Circle::~Circle\n"</font>; }
<font color=#0000ff>private</font>:
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> ShapeFactoryInitializer;
  <font color=#0000ff>class</font> Factory;
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> Factory;
  <font color=#0000ff>class</font> Factory : <font color=#0000ff>public</font> ShapeFactory {
  <font color=#0000ff>public</font>:
    Shape* create() { <font color=#0000ff>return</font> <font color=#0000ff>new</font> Circle; }
    <font color=#0000ff>friend</font> <font color=#0000ff>class</font> ShapeFactoryInitializer;
  };
};

<font color=#0000ff>class</font> Square : <font color=#0000ff>public</font> Shape {
  Square() {}
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> draw() { cout &lt;&lt; <font color=#004488>"Square::draw\n"</font>; }
  <font color=#0000ff>void</font> erase() { cout &lt;&lt; <font color=#004488>"Square::erase\n"</font>; }
  ~Square() { cout &lt;&lt; <font color=#004488>"Square::~Square\n"</font>; }
<font color=#0000ff>private</font>:
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> ShapeFactoryInitializer;
  <font color=#0000ff>class</font> Factory;
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> Factory;
  <font color=#0000ff>class</font> Factory : <font color=#0000ff>public</font> ShapeFactory {
  <font color=#0000ff>public</font>:
    Shape* create() { <font color=#0000ff>return</font> <font color=#0000ff>new</font> Square; }
    <font color=#0000ff>friend</font> <font color=#0000ff>class</font> ShapeFactoryInitializer;
  };
};

<font color=#009900>// Singleton to initialize the ShapeFactory:</font>
<font color=#0000ff>class</font> ShapeFactoryInitializer {
  <font color=#0000ff>static</font> ShapeFactoryInitializer si;
  ShapeFactoryInitializer() {
    ShapeFactory::factories[<font color=#004488>"Circle"</font>] =
      <font color=#0000ff>new</font> Circle::Factory;
    ShapeFactory::factories[<font color=#004488>"Square"</font>] =
      <font color=#0000ff>new</font> Square::Factory;
  }
};

<font color=#009900>// Static member definition:</font>
ShapeFactoryInitializer
  ShapeFactoryInitializer::si;

<font color=#0000ff>char</font>* shlist[] = { <font color=#004488>"Circle"</font>, <font color=#004488>"Square"</font>, <font color=#004488>"Square"</font>,
  <font color=#004488>"Circle"</font>, <font color=#004488>"Circle"</font>, <font color=#004488>"Circle"</font>, <font color=#004488>"Square"</font>, <font color=#004488>""</font> };

<font color=#0000ff>int</font> main() {
  vector&lt;Shape*&gt; shapes;
  <font color=#0000ff>try</font> {
    <font color=#0000ff>for</font>(<font color=#0000ff>char</font>** cp = shlist; **cp; cp++)
      shapes.push_back(
        ShapeFactory::createShape(*cp));
  } <font color=#0000ff>catch</font>(ShapeFactory::BadShapeCreation e) {
    cout &lt;&lt; e.what() &lt;&lt; endl;
    <font color=#0000ff>return</font> 1;
  }
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; shapes.size(); i++) {
    shapes[i]-&gt;draw();
    shapes[i]-&gt;erase();
  }
  purge(shapes);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now the factory method appears in its own
class, <B>ShapeFactory</B>, as the <B>virtual create(&#160;)</B>. This is a
<B>private</B> member function, which means it cannot be called directly but can
be overridden. The subclasses of <B>Shape</B> must each create their own
subclasses of <B>ShapeFactory</B> and override the <B>create(&#160;)</B> method
to create an object of their own type. These factories are private, so that they
are only accessible from the main factory method. This way, all client
programmers are forced to go through the factory method in order to create
objects.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The actual creation of shapes is
performed by calling <B>ShapeFactory::createShape(&#160;)</B>, which is a static
method that uses the <B>map</B> in <B>ShapeFactory</B> to find the appropriate
factory object based on an identifier that you pass it. The factory is
immediately used to create the shape object, but you could imagine a more
complex problem where the appropriate factory object is returned and then used
by the caller to create an object in a more sophisticated way. However, it seems
that much of the time you don&#8217;t need the intricacies of the polymorphic
factory method, and a single static method in the base class (as shown in
<B>ShapeFactory1.cpp</B>) will work
fine.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I50">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I51"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Notice that the <B>ShapeFactory</B> must
be initialized by loading its <B>map</B> with factory objects, which takes place
in the singleton <B>ShapeFactoryInitializer</B>. So to add a new type to this
design you must inherit the type, create a factory, and modify
<B>ShapeFactoryInitializer</B> so that an instance of your factory is inserted
in the map. This extra complexity again suggests the use of a <B>static</B>
factory method if you don&#8217;t need to create individual factory
objects.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I51">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I52"></a>
</FONT><A NAME="_Toc305593322"></A><A NAME="_Toc305628794"></A><A NAME="_Toc312374165"></A><A NAME="_Toc519042125"></A><BR></P></DIV>
<A NAME="Heading335"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Abstract factories</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <I>Abstract Factory</I> pattern looks
like the factory objects we&#8217;ve seen previously, with not one but several
factory methods. Each of the factory methods creates a different kind of object.
The idea is that at the point of creation of the factory object, you decide how
all the objects created by that factory will be used. The example given in
<I>Design Patterns</I> implements portability across various graphical user
interfaces (GUIs): you create a factory object appropriate to the GUI that
you&#8217;re working with, and from then on when you ask it for a menu, button,
slider, etc. it will automatically create the appropriate version of that item
for the GUI. Thus you&#8217;re able to isolate, in one place, the effect of
changing from one GUI to
another.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I52">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I53"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As another example suppose you are
creating a general-purpose gaming environment and you want to be able to support
different types of games. Here&#8217;s how it might look using an abstract
factory:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I53">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I54"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:AbstractFactory.cpp</font>
<font color=#009900>// A gaming environment</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Obstacle {
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> action() = 0;
};

<font color=#0000ff>class</font> Player {
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> interactWith(Obstacle*) = 0;
};

<font color=#0000ff>class</font> Kitty: <font color=#0000ff>public</font> Player {
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> interactWith(Obstacle* ob) {
    cout &lt;&lt; <font color=#004488>"Kitty has encountered a "</font>;
    ob-&gt;action();
  }
};

<font color=#0000ff>class</font> KungFuGuy: <font color=#0000ff>public</font> Player {
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> interactWith(Obstacle* ob) {
    cout &lt;&lt; <font color=#004488>"KungFuGuy now battles against a "</font>;
    ob-&gt;action();
  }
};

<font color=#0000ff>class</font> Puzzle: <font color=#0000ff>public</font> Obstacle {
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> action() { cout &lt;&lt; <font color=#004488>"Puzzle\n"</font>; }
};

<font color=#0000ff>class</font> NastyWeapon: <font color=#0000ff>public</font> Obstacle {
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> action() { cout &lt;&lt; <font color=#004488>"NastyWeapon\n"</font>; }
};

<font color=#009900>// The abstract factory:</font>
<font color=#0000ff>class</font> GameElementFactory {
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> Player* makePlayer() = 0;
  <font color=#0000ff>virtual</font> Obstacle* makeObstacle() = 0;
};

<font color=#009900>// Concrete factories:</font>
<font color=#0000ff>class</font> KittiesAndPuzzles : 
  <font color=#0000ff>public</font> GameElementFactory {
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> Player* makePlayer() { 
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> Kitty;
  }
  <font color=#0000ff>virtual</font> Obstacle* makeObstacle() {
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> Puzzle;
  }
};

<font color=#0000ff>class</font> KillAndDismember : 
  <font color=#0000ff>public</font> GameElementFactory {
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> Player* makePlayer() { 
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> KungFuGuy;
  }
  <font color=#0000ff>virtual</font> Obstacle* makeObstacle() {
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> NastyWeapon;
  }
};

<font color=#0000ff>class</font> GameEnvironment {
  GameElementFactory* gef;
  Player* p;
  Obstacle* ob;
<font color=#0000ff>public</font>:
  GameEnvironment(GameElementFactory* factory) :
    gef(factory), p(factory-&gt;makePlayer()), 
    ob(factory-&gt;makeObstacle()) {}
  <font color=#0000ff>void</font> play() {
    p-&gt;interactWith(ob);
  }
  ~GameEnvironment() {
    <font color=#0000ff>delete</font> p;
    <font color=#0000ff>delete</font> ob;
    <font color=#0000ff>delete</font> gef;
  }
};

<font color=#0000ff>int</font> main() {
  GameEnvironment 
    g1(<font color=#0000ff>new</font> KittiesAndPuzzles),
    g2(<font color=#0000ff>new</font> KillAndDismember);
  g1.play();
  g2.play();
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In this environment, <B>Player</B>
objects interact with <B>Obstacle</B> objects, but there are different types of
players and obstacles depending on what kind of game you&#8217;re playing. You
determine the kind of game by choosing a particular <B>GameElementFactory</B>,
and then the <B>GameEnvironment</B> controls the setup and play of the game. In
this example, the setup and play is very simple, but those activities (the
<I>initial conditions</I> and the <I>state change</I>) can determine much of the
game&#8217;s outcome. Here, <B>GameEnvironment</B> is not designed to be
inherited, although it could very possibly make sense to do
that.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I54">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I55"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This also contains examples of <I>Double
Dispatching</I> and the <I>Factory Method</I>, both of which will be explained
later.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I55">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I56"></a>
</FONT><A NAME="_Toc519042126"></A><BR></P></DIV>
<A NAME="Heading336"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Virtual constructors</H3></FONT>
<DIV ALIGN="LEFT"><P><BR>Show simpler version of virtual constructor scheme,
letting the user create the object with new. Probably make constructor for
objects private and use a maker function to force all objects on the
heap.<BR></P></DIV>
<FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the primary goals of using a
factory is so that
<A NAME="Index663"></A><A NAME="Index664"></A><A NAME="Index665"></A>you can
organize your code so you don&#8217;t have to select an exact type of
constructor when creating an object. That is, you can say, &#8220;I don&#8217;t
know precisely what type of object you are, but here&#8217;s the information:
Create yourself.&#8221; 
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I56">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I57"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In addition, during a constructor call
the virtual mechanism does not operate (early binding occurs). Sometimes this is
awkward. For example, in the <B>Shape </B>program it seems logical that inside
the constructor for a <B>Shape</B> object, you would want to set everything up
and then <B>draw(&#160;)</B> the <B>Shape</B>. <B>draw(&#160;)</B> should be a
virtual function, a message to the <B>Shape</B> that it should draw itself
appropriately, depending on whether it is a circle, square, line, and so on.
However, this doesn&#8217;t work inside the constructor, for the reasons given
in Chapter XX: Virtual functions<A NAME="Index666"></A><A NAME="Index667"></A>
resolve to the &#8220;local&#8221; function bodies when called in
constructors.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I57">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I58"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you want to be able to call a virtual
function inside the constructor and have it do the right thing, you must use a
technique to <I>simulate</I> a virtual constructor (which is a variation of the
<I>Factory Method</I>). This is a conundrum. Remember the idea of a virtual
function is that you send a message to an object and let the object figure out
the right thing to do. But a constructor builds an object. So a virtual
constructor would be like saying, &#8220;I don&#8217;t know exactly what type of
object you are, but build yourself anyway.&#8221; In an ordinary constructor,
the compiler must know which VTABLE <A NAME="Index668"></A>address to bind to
the VPTR<A NAME="Index669"></A>, and if it existed, a virtual constructor
couldn&#8217;t do this because it doesn&#8217;t know all the type information at
compile-time. It makes sense that a constructor can&#8217;t be virtual because
it is the one function that absolutely must know everything about the type of
the object.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I58">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I59"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">And yet there are times when you want
something approximating the behavior of a virtual
constructor.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I59">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I60"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the <B>Shape</B> example, it would be
nice to hand the <B>Shape</B> constructor some specific information in the
argument list and let the constructor create a specific type of <B>Shape</B> (a
<B>Circle</B>, <B>Square</B>) with no further intervention. Ordinarily,
you&#8217;d have to make an explicit call to the <B>Circle</B>, <B>Square</B>
constructor yourself.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I60">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I61"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Coplien</FONT><A NAME="fnB29" HREF="#fn29">[29]</A><A NAME="Index670"></A><FONT FACE="Georgia">
calls his solution to this problem &#8220;envelope and letter classes.&#8221;
The &#8220;envelope&#8221; class is the base class, a shell that contains a
pointer to an object of the base class. The constructor for the
&#8220;envelope&#8221; determines (at runtime, when the constructor is called,
not at compile-time, when the type checking is normally done) what specific type
to make, then creates an object of that specific type (on the heap) and assigns
the object to its pointer. All the function calls are then handled by the base
class through its pointer. So the base class is acting as a proxy for the
derived class:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I61">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I62"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:VirtualConstructor.cpp</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;exception&gt;
#include &lt;vector&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Shape {
  Shape* s;
  <font color=#009900>// Prevent copy-construction &amp; operator=</font>
  Shape(Shape&amp;);
  Shape <font color=#0000ff>operator</font>=(Shape&amp;);
<font color=#0000ff>protected</font>:
  Shape() { s = 0; };
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> draw() { s-&gt;draw(); }
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> erase() { s-&gt;erase(); }
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> test() { s-&gt;test(); };
  <font color=#0000ff>virtual</font> ~Shape() {
    cout &lt;&lt; <font color=#004488>"~Shape\n"</font>;
    <font color=#0000ff>if</font>(s) {
      cout &lt;&lt; <font color=#004488>"Making virtual call: "</font>;
      s-&gt;erase(); <font color=#009900>// Virtual call</font>
    }
    cout &lt;&lt; <font color=#004488>"delete s: "</font>;
    <font color=#0000ff>delete</font> s; <font color=#009900>// The polymorphic deletion</font>
  }
  <font color=#0000ff>class</font> BadShapeCreation : <font color=#0000ff>public</font> exception {
    string reason;
  <font color=#0000ff>public</font>:
    BadShapeCreation(string type) {
      reason = <font color=#004488>"Cannot create type "</font> + type;
    }
    ~BadShapeCreation() <font color=#0000ff>throw</font>() {}
    <font color=#0000ff>const</font> <font color=#0000ff>char</font> *what() <font color=#0000ff>const</font> <font color=#0000ff>throw</font>() { 
      <font color=#0000ff>return</font> reason.c_str(); 
    }
  };
  Shape(string type) <font color=#0000ff>throw</font>(BadShapeCreation);
};

<font color=#0000ff>class</font> Circle : <font color=#0000ff>public</font> Shape {
  Circle(Circle&amp;);
  Circle <font color=#0000ff>operator</font>=(Circle&amp;);
  Circle() {} <font color=#009900>// Private constructor</font>
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> Shape;
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> draw() { cout &lt;&lt; <font color=#004488>"Circle::draw\n"</font>; }
  <font color=#0000ff>void</font> erase() { cout &lt;&lt; <font color=#004488>"Circle::erase\n"</font>; }
  <font color=#0000ff>void</font> test() { draw(); }
  ~Circle() { cout &lt;&lt; <font color=#004488>"Circle::~Circle\n"</font>; }
};

<font color=#0000ff>class</font> Square : <font color=#0000ff>public</font> Shape {
  Square(Square&amp;);
  Square <font color=#0000ff>operator</font>=(Square&amp;);
  Square() {}
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> Shape;
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> draw() { cout &lt;&lt; <font color=#004488>"Square::draw\n"</font>; }
  <font color=#0000ff>void</font> erase() { cout &lt;&lt; <font color=#004488>"Square::erase\n"</font>; }
  <font color=#0000ff>void</font> test() { draw(); }
  ~Square() { cout &lt;&lt; <font color=#004488>"Square::~Square\n"</font>; }
};

Shape::Shape(string type) 
  <font color=#0000ff>throw</font>(Shape::BadShapeCreation) {
  <font color=#0000ff>if</font>(type == <font color=#004488>"Circle"</font>) 
    s = <font color=#0000ff>new</font> Circle;
  <font color=#0000ff>else</font> <font color=#0000ff>if</font>(type == <font color=#004488>"Square"</font>)
    s = <font color=#0000ff>new</font> Square;
  <font color=#0000ff>else</font> <font color=#0000ff>throw</font> BadShapeCreation(type);
  draw();  <font color=#009900>// Virtual call in the constructor</font>
}

<font color=#0000ff>char</font>* shlist[] = { <font color=#004488>"Circle"</font>, <font color=#004488>"Square"</font>, <font color=#004488>"Square"</font>,
  <font color=#004488>"Circle"</font>, <font color=#004488>"Circle"</font>, <font color=#004488>"Circle"</font>, <font color=#004488>"Square"</font>, <font color=#004488>""</font> };

<font color=#0000ff>int</font> main() {
  vector&lt;Shape*&gt; shapes;
  cout &lt;&lt; <font color=#004488>"virtual constructor calls:"</font> &lt;&lt; endl;
  <font color=#0000ff>try</font> {
    <font color=#0000ff>for</font>(<font color=#0000ff>char</font>** cp = shlist; **cp; cp++)
      shapes.push_back(<font color=#0000ff>new</font> Shape(*cp));
  } <font color=#0000ff>catch</font>(Shape::BadShapeCreation e) {
    cout &lt;&lt; e.what() &lt;&lt; endl;
    <font color=#0000ff>return</font> 1;
  }
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; shapes.size(); i++) {
    shapes[i]-&gt;draw();
    cout &lt;&lt; <font color=#004488>"test\n"</font>;
    shapes[i]-&gt;test();
    cout &lt;&lt; <font color=#004488>"end test\n"</font>;
    shapes[i]-&gt;erase();
  }
  Shape c(<font color=#004488>"Circle"</font>); <font color=#009900>// Create on the stack</font>
  cout &lt;&lt; <font color=#004488>"destructor calls:"</font> &lt;&lt; endl;
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; shapes.size(); j++) {
    <font color=#0000ff>delete</font> shapes[j];
    cout &lt;&lt; <font color=#004488>"\n------------\n"</font>;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The base class <B>Shape</B> contains a
pointer to an object of type <B>Shape</B> as its only data member. When you
build a &#8220;virtual constructor&#8221; scheme, you must exercise special care
to ensure this pointer is always initialized to a live
object.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I62">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I63"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each time you derive a new subtype from
<B>Shape</B>, you must go back and add the creation for that type in one place,
inside the &#8220;virtual constructor&#8221; in the <B>Shape</B> base class.
This is not too onerous a task, but the disadvantage is you now have a
dependency between the <B>Shape</B> class and all classes derived from it (a
reasonable trade-off, it seems). Also, because it is a proxy, the base-class
interface is truly the only thing the user
sees.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I63">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I64"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In this example, the information you must
hand the virtual constructor about what type to create is very explicit:
It&#8217;s a <B>string</B> that names the type. However, your scheme may use
other information &#8211; for example, in a parser the output of the scanner may
be handed to the virtual constructor, which then uses that information to
determine which token to
create.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I64">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I65"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The virtual constructor
<B>Shape(type)</B> can only be declared inside the class; it cannot be defined
until after all the derived classes have been declared. However, the default
constructor<A NAME="Index671"></A><A NAME="Index672"></A> can be defined inside
<B>class Shape</B>, but it should be made <B>protected</B> so temporary
<B>Shape</B> objects cannot be created. This default constructor is only called
by the constructors of derived-class objects. You are forced to explicitly
create a default constructor because the compiler will create one for you
automatically only if there are <I>no</I> constructors defined. Because you must
define <B>Shape(type)</B>, you must also define
<B>Shape(&#160;)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I65">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I66"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The default constructor in this scheme
has at least one very important chore &#8211; it must set the value of the
<B>s</B> pointer to zero. This sounds strange at first, but remember that the
default constructor will be called as part of the construction of the <I>actual
object</I> &#8211; in Coplien&#8217;s terms, the &#8220;letter,&#8221; not the
&#8220;envelope.&#8221; However, the &#8220;letter&#8221; is derived from the
&#8220;envelope,&#8221; so it also inherits the data member <B>s</B>. In the
&#8220;envelope,&#8221; <B>s</B> is important because it points to the actual
object, but in the &#8220;letter,&#8221; <B>s</B> is simply excess baggage. Even
excess baggage should be initialized, however, and if <B>s</B> is not set to
zero by the default constructor called for the &#8220;letter,&#8221; bad things
happen (as you&#8217;ll see
later).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I66">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I67"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The virtual constructor takes as its
argument information that completely determines the type of the object. Notice,
though, that this type information isn&#8217;t read and acted upon until
runtime, whereas normally the compiler must know the exact type at compile-time
(one other reason this system effectively imitates virtual
constructors).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I67">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I68"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Inside the virtual constructor
there&#8217;s a <B>switch</B> statement that uses the argument to construct the
actual (&#8220;letter&#8221;) object, which is then assigned to the pointer
inside the &#8220;envelope.&#8221; At that point, the construction of the
&#8220;letter&#8221; has been completed, so any virtual calls will be properly
directed.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I68">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I69"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As an example, consider the call to
<B>draw(&#160;)</B> inside the virtual constructor. If you trace this call
(either by hand or with a debugger), you can see that it starts in the
<B>draw(&#160;)</B> function in the base class, <B>Shape</B>. This function
calls <B>draw(&#160;)</B> for the &#8220;envelope&#8221; <B>s</B> pointer to its
&#8220;letter.&#8221; All types derived from <B>Shape</B> share the same
interface, so this virtual call is properly executed, even though it seems to be
in the constructor. (Actually, the constructor for the &#8220;letter&#8221; has
already completed.) As long as all virtual calls in the base class simply make
calls to identical virtual function through the pointer to the
&#8220;letter,&#8221; the system operates
properly.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I69">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I70"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To understand how it works, consider the
code in <B>main(&#160;)</B>. To fill the <B>vector shapes</B>, &#8220;virtual
constructor&#8221; calls are made to <B>Shape</B>. Ordinarily in a situation
like this, you would call the constructor for the actual type, and the VPTR for
that type would be installed in the object. Here, however, the VPTR used in each
case is the one for <B>Shape</B>, not the one for the specific <B>Circle</B>,
<B>Square</B>, or
<B>Triangle</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I70">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I71"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the <B>for</B> loop where the
<B>draw(&#160;)</B> and <B>erase(&#160;) </B>functions are called for each
<B>Shape</B>, the virtual function call resolves, through the VPTR, to the
corresponding type. However, this is <B>Shape</B> in each case. In fact, you
might wonder why <B>draw(&#160;)</B> and <B>erase(&#160;) </B>were made
<B>virtual</B> at all. The reason shows up in the next step: The base-class
version of <B>draw(&#160;)</B> makes a call, through the &#8220;letter&#8221;
pointer <B>s</B>, to the <B>virtual</B> function <B>draw(&#160;)</B> for the
&#8220;letter.&#8221; This time the call resolves to the actual type of the
object, not just the base class <B>Shape</B>. Thus the runtime cost of using
virtual constructors is one more virtual call every time you make a virtual
function call.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I71">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I72"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In order to create any function that is
overridden, such as <B>draw(&#160;)</B>, <B>erase(&#160;)</B> or
<B>test(&#160;)</B>, you must proxy all calls to the <B>s</B> pointer in the
base class implementation, as shown above. This is because, when the call is
made, the call to the envelope&#8217;s member function will resolve as being to
<B>Shape</B>, and not to a derived type of <B>Shape</B>. Only when you make the
proxy call to <B>s</B> will the virtual behavior take place. In
<B>main(&#160;)</B>, you can see that everything works correctly, even when
calls are made inside constructors and
destructors.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I72">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I73"></a>
</FONT><BR></P></DIV>
<A NAME="Heading337"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Destructor operation</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The activities of destruction in this
scheme are also tricky. To understand, let&#8217;s verbally walk through what
happens when you call <B>delete</B> for a pointer to a <B>Shape</B> object
&#8211; specifically, a <B>Square</B> &#8211; created on the heap. (This is more
complicated than an object created on the stack.) This will be a <B>delete</B>
through the polymorphic interface, as in the statement <B>delete shapes[i]</B>
in <B>main(&#160;)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I73">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I74"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The type of the pointer <B>shapes[i]</B>
is of the base class <B>Shape</B>, so the compiler makes the call through
<B>Shape</B>. Normally, you might say that it&#8217;s a virtual call, so
<B>Square</B>&#8217;s destructor will be called. But with the virtual
constructor scheme, the compiler is creating actual <B>Shape</B> objects, even
though the constructor initializes the letter pointer to a specific type of
<B>Shape</B>. The virtual mechanism <I>is</I> used, but the VPTR inside the
<B>Shape</B> object is <B>Shape</B>&#8217;s VPTR, not <B>Square</B>&#8217;s.
This resolves to <B>Shape</B>&#8217;s destructor, which calls <B>delete</B> for
the letter pointer <B>s</B>, which actually points to a <B>Square</B> object.
This is again a virtual call, but this time it resolves to <B>Square</B>&#8217;s
destructor.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I74">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I75"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">With a destructor, however, C++
guarantees, via the compiler, that all destructors in the hierarchy are called.
<B>Square</B>&#8217;s destructor is called first, followed by any intermediate
destructors, in order, until finally the base-class destructor is called. This
base-class destructor has code that says <B>delete s</B>. When this destructor
was called originally, it was for the &#8220;envelope&#8221; <B>s</B>, but now
it&#8217;s for the &#8220;letter&#8221; <B>s</B>, which is there because the
&#8220;letter&#8221; was inherited from the &#8220;envelope,&#8221; and not
because it contains anything. So <I>this</I> call to <B>delete</B> should do
nothing.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I75">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I76"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The solution to the problem is to make
the &#8220;letter&#8221; <B>s</B> pointer zero. Then when the
&#8220;letter&#8221; base-class destructor is called, you get <B>delete 0</B>,
which by definition does nothing. Because the default constructor is protected,
it will be called <I>only</I> during the construction of a &#8220;letter,&#8221;
so that&#8217;s the only situation where <B>s</B> is set to
zero.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I76">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I77"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Your most common tool for hiding
construction will probably be ordinary factory methods rather than the more
complex approaches. The idea of adding new types with minimal effect on the rest
of the system will be further explored later in this
chapter.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I77">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I78"></a>
</FONT><A NAME="_Toc519042127"></A><BR></P></DIV>
<A NAME="Heading338"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Callbacks</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Decoupling code
behavior
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I78">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I79"></a>
</FONT><A NAME="_Toc519042128"></A><BR></P></DIV>
<A NAME="Heading339"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Functor/Command<A NAME="_Toc519042129"></A></H3></FONT>
<A NAME="Heading340"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Strategy<A NAME="_Toc519042130"></A></H3></FONT>
<A NAME="Heading341"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Observer</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Like the other forms of callback, this
contains a hook point where you can change code. The difference is in the
observer&#8217;s completely dynamic nature. It is often used for the specific
case of changes based on other object&#8217;s change of state, but is also the
basis of event management. Anytime you want to decouple the source of the call
from the called code in a completely dynamic
way.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I79">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I80"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index673"></A><A NAME="Index674"></A>observer pattern solves a fairly
common problem: What if a group of objects needs to update themselves when some
other object changes state? This can be seen in the &#8220;model-view&#8221;
aspect of Smalltalk&#8217;s MVC (model-view-controller), or the
almost-equivalent &#8220;Document-View Architecture.&#8221; Suppose that you
have some data (the &#8220;document&#8221;) and more than one view, say a plot
and a textual view. When you change the data, the two views must know to update
themselves, and that&#8217;s what the observer facilitates.

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I80">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I81"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are two types of objects used to
implement the observer pattern in the following code. The
<A NAME="Index675"></A><B>Observable</B> class keeps track of everybody who
wants to be informed when a change happens, whether the &#8220;state&#8221; has
changed or not. When someone says &#8220;OK, everybody should check and
potentially update themselves,&#8221; the <B>Observable</B> class performs this
task by calling the <A NAME="Index676"></A><B>notifyObservers(&#160;)</B> member
function for each observer on the list. The <B>notifyObservers(&#160;)</B>
member function is part of the base class
<B>Observable</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I81">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I82"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are actually two &#8220;things that
change&#8221; in the observer pattern: the quantity of observing objects and the
way an update occurs. That is, the observer pattern allows you to modify both of
these without affecting the surrounding
code.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I82">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I83"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are a number of ways to implement
the observer pattern, but the code shown here will create a framework from which
you can build your own observer code, following the example. First, this
interface describes what an observer looks
like:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I83">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I84"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:Observer.h</font>
<font color=#009900>// The Observer interface</font>
#ifndef OBSERVER_H
#define OBSERVER_H

<font color=#0000ff>class</font> Observable;
<font color=#0000ff>class</font> Argument {};

<font color=#0000ff>class</font> Observer {
<font color=#0000ff>public</font>:
  <font color=#009900>// Called by the observed object, whenever </font>
  <font color=#009900>// the observed object is changed:</font>
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> 
  update(Observable* o, Argument * arg) = 0;
};
#endif <font color=#009900>// OBSERVER_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since <B>Observer</B> interacts with
<B>Observable</B> in this approach, <B>Observable</B> must be declared first. In
addition, the <B>Argument</B> class is empty and only acts as a base class for
any type of argument you wish to pass during an update. If you want, you can
simply pass the extra argument as a <B>void*</B>; you&#8217;ll have to downcast
in either case but some folks find <B>void*</B>
objectionable.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I84">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I85"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Observer</B> is an
&#8220;interface&#8221; class that only has one member function,
<B>update(&#160;)</B>. This function is called by the object that&#8217;s being
observed, when that object decides its time to update all it&#8217;s observers.
The arguments are optional; you could have an <B>update(&#160;)</B> with no
arguments and that would still fit the observer pattern; however this is more
general &#8211; it allows the observed object to pass the object that caused the
update (since an <B>Observer </B>may be registered with more than one observed
object) and any extra information if that&#8217;s helpful, rather than forcing
the <B>Observer</B> object to hunt around to see who is updating and to fetch
any other information it
needs.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I85">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I86"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The &#8220;observed object&#8221; that
decides when and how to do the updating will be called the
<B>Observable</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I86">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I87"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:Observable.h</font>
<font color=#009900>// The Observable class</font>
#ifndef OBSERVABLE_H
#define OBSERVABLE_H
#include <font color=#004488>"Observer.h"</font>
#include &lt;set&gt;

<font color=#0000ff>class</font> Observable {
  <font color=#0000ff>bool</font> changed;
  std::set&lt;Observer*&gt; observers;
<font color=#0000ff>protected</font>:
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> setChanged() { changed = <font color=#0000ff>true</font>; }
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> clearChanged(){ changed = <font color=#0000ff>false</font>; }
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> addObserver(Observer&amp; o) {
    observers.insert(&amp;o);
  }
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> deleteObserver(Observer&amp; o) {
    observers.erase(&amp;o);
  }
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> deleteObservers() {
    observers.clear();
  }
  <font color=#0000ff>virtual</font> <font color=#0000ff>int</font> countObservers() {
    <font color=#0000ff>return</font> observers.size();
  }
  <font color=#0000ff>virtual</font> <font color=#0000ff>bool</font> hasChanged() { <font color=#0000ff>return</font> changed; }
  <font color=#009900>// If this object has changed, notify all</font>
  <font color=#009900>// of its observers:</font>
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> notifyObservers(Argument* arg=0) {
    <font color=#0000ff>if</font>(!hasChanged()) <font color=#0000ff>return</font>;
    clearChanged(); <font color=#009900>// Not "changed" anymore</font>
    std::set&lt;Observer*&gt;::iterator it;
    <font color=#0000ff>for</font>(it = observers.begin(); 
      it != observers.end(); it++)
      (*it)-&gt;update(<font color=#0000ff>this</font>, arg);
  }
};
#endif <font color=#009900>// OBSERVABLE_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Again, the design here is more elaborate
than is necessary; as long as there&#8217;s a way to register an <B>Observer</B>
with an <B>Observable</B> and for the <B>Observable</B> to update its
<B>Observer</B>s, the set of member functions doesn&#8217;t matter. However,
this design is intended to be reusable (it was lifted from the design used in
the Java standard library). As mentioned elsewhere in the book, there is no
support for multithreading in the Standard C++ libraries, so this design would
need to be modified in a multithreaded
environment.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I87">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I88"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Observable</B> has a flag to indicate
whether it&#8217;s been changed. In a simpler design, there would be no flag; if
something happened, everyone would be notified. The flag allows you to wait, and
only notify the <B>Observer</B>s when you decide the time is right. Notice,
however, that the control of the flag&#8217;s state is <B>protected</B>, so that
only an inheritor can decide what constitutes a change, and not the end user of
the resulting derived <B>Observer</B>
class.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I88">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I89"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The collection of <B>Observer</B> objects
is kept in a <B>set&lt;Observer*&gt;</B> to prevent duplicates; the <B>set
insert(&#160;)</B>, <B>erase(&#160;)</B>, <B>clear(&#160;)</B> and
<B>size(&#160;)</B> functions are exposed to allow <B>Observer</B>s to be added
and removed at any time, thus providing runtime
flexibility.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I89">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I90"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Most of the work is done in
<B>notifyObservers(&#160;)</B>. If the <B>changed</B> flag has not been set,
this does nothing. Otherwise, it first clears the <B>changed</B> flag so
repeated calls to <B>notifyObservers(&#160;)</B> won&#8217;t waste time. This is
done before notifying the observers in case the calls to <B>update(&#160;)</B>
do anything that causes a change back to this <B>Observable</B> object. Then it
moves through the <B>set</B> and calls back to the <B>update(&#160;)</B> member
function of each <B>Observer</B>.

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I90">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I91"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">At first it may appear that you can use
an ordinary <B>Observable</B> object to manage the updates. But this
doesn&#8217;t work; to get an effect, you <I>must</I> inherit from
<B>Observable</B> and somewhere in your derived-class code call
<A NAME="Index677"></A><B>setChanged(&#160;)</B>. This is the member function
that sets the &#8220;changed&#8221; flag, which means that when you call
<A NAME="Index678"></A><B>notifyObservers(&#160;)</B> all of the observers will,
in fact, get notified. <I>Where</I> you call <B>setChanged(&#160;)</B> depends
on the logic of your
program.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I91">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I92"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now we encounter a dilemma. An object
that should notify its observers about things that happen to it &#8211; events
or changes in state &#8211; might have more than one such item of interest. For
example, if you&#8217;re dealing with a graphical user interface (GUI) item
&#8211; a button, say &#8211; the items of interest might be the mouse clicked
the button, the mouse moved over the button, and (for some reason) the button
changed its color. So we&#8217;d like to be able to report all of these events
to different observers, each of which is interested in a different type of
event.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I92">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I93"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The problem is that we would normally
reach for multiple inheritance in such a situation: &#8220;I&#8217;ll inherit
from <B>Observable</B> to deal with mouse clicks, and I&#8217;ll ... er ...
inherit from <B>Observable</B> to deal with mouse-overs, and, well, ... hmm,
that doesn&#8217;t
work.&#8221;
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I93">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I94"></a>
</FONT><BR></P></DIV>
<A NAME="Heading342"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
The &#8220;interface&#8221; idiom</H4></FONT>
<A NAME="Heading343"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
The &#8220;inner class&#8221; idiom</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s a situation where we do
actually need to (in effect) upcast to more than one type, but in this case we
need to provide several <I>different</I> implementations of the same base type.
The solution is something I&#8217;ve lifted from Java, which takes C++&#8217;s
nested class one step further. Java has a built-in feature called <I>inner
classes</I>, which look like C++&#8217;s nested classes, but they do two other
things:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I94">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I95"></a>
</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">A Java inner class
automatically has access to the private elements of the class it is nested
within.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">An object of
a Java inner class automatically grabs the &#8220;this&#8221; to the outer class
object it was created within. In Java, the &#8220;outer this&#8221; is
implicitly dereferenced whenever you name an element of the outer
class.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">[[ Insert the
definition of a closure ]]. So to implement the inner class idiom in C++, we
must do these things by hand. Here&#8217;s an
example:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I95">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I96"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:InnerClassIdiom.cpp</font>
<font color=#009900>// Example of the "inner class" idiom</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;iostream&gt;
#include &lt;string&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Poingable {
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> poing() = 0;
};

<font color=#0000ff>void</font> callPoing(Poingable&amp; p) {
  p.poing();
}

<font color=#0000ff>class</font> Bingable {
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> bing() = 0;
};

<font color=#0000ff>void</font> callBing(Bingable&amp; b) {
  b.bing();
}

<font color=#0000ff>class</font> Outer {
  string name;
  <font color=#009900>// Define one inner class:</font>
  <font color=#0000ff>class</font> Inner1;
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> Outer::Inner1;
  <font color=#0000ff>class</font> Inner1 : <font color=#0000ff>public</font> Poingable {
    Outer* parent;
  <font color=#0000ff>public</font>:
    Inner1(Outer* p) : parent(p) {}
    <font color=#0000ff>void</font> poing() {
      cout &lt;&lt; <font color=#004488>"poing called for "</font>
        &lt;&lt; parent-&gt;name &lt;&lt; endl;
      <font color=#009900>// Accesses data in the outer class object</font>
    }
  } inner1;
  <font color=#009900>// Define a second inner class:</font>
  <font color=#0000ff>class</font> Inner2;
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> Outer::Inner2;
  <font color=#0000ff>class</font> Inner2 : <font color=#0000ff>public</font> Bingable {
    Outer* parent;
  <font color=#0000ff>public</font>:
    Inner2(Outer* p) : parent(p) {}
    <font color=#0000ff>void</font> bing() {
      cout &lt;&lt; <font color=#004488>"bing called for "</font>
        &lt;&lt; parent-&gt;name &lt;&lt; endl;
    }
  } inner2;
<font color=#0000ff>public</font>:
  Outer(<font color=#0000ff>const</font> string&amp; nm) : name(nm), 
    inner1(<font color=#0000ff>this</font>), inner2(<font color=#0000ff>this</font>) {}
  <font color=#009900>// Return reference to interfaces</font>
  <font color=#009900>//  implemented by the inner classes:</font>
  <font color=#0000ff>operator</font> Poingable&amp;() { <font color=#0000ff>return</font> inner1; }
  <font color=#0000ff>operator</font> Bingable&amp;() { <font color=#0000ff>return</font> inner2; }
};

<font color=#0000ff>int</font> main() {
  Outer x(<font color=#004488>"Ping Pong"</font>);
  <font color=#009900>// Like upcasting to multiple base types!:</font>
  callPoing(x);
  callBing(x);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The example begins with the
<B>Poingable</B> and <B>Bingable </B>interfaces, each of which contain a single
member function. The services provided by <B>callPoing(&#160;)</B> and
<B>callBing(&#160;) </B>require that the object they receive implement the
<B>Poingable</B> and <B>Bingable </B>interfaces, respectively, but they put no
other requirements on that object so as to maximize the flexibility of using
<B>callPoing(&#160;)</B> and <B>callBing(&#160;)</B>. Note the lack of
<B>virtual</B> destructors in either interface &#8211; the intent is that you
never perform object destruction via the
interface.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I96">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I97"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Outer</B> contains some private data
(<B>name</B>) and it wishes to provide both a <B>Poingable</B> interface and a
<B>Bingable </B>interface so it can be used with <B>callPoing(&#160;) </B>and
<B>callBing(&#160;)</B>. Of course, in this situation we <I>could</I> simply use
multiple inheritance. This example is just intended to show the simplest syntax
for the idiom; we&#8217;ll see a real use shortly. To provide a <B>Poingable</B>
object without inheriting <B>Outer</B> from <B>Poingable</B>, the inner class
idiom is used. First, the declaration <B>class Inner</B> says that, somewhere,
there is a nested class of this name. This allows the <B>friend</B> declaration
for the class, which follows. Finally, now that the nested class has been
granted access to all the private elements of <B>Outer</B>, the class can be
defined. Notice that it keeps a pointer to the <B>Outer</B> which created it,
and this pointer must be initialized in the constructor. Finally, the
<B>poing(&#160;)</B> function from <B>Poingable</B> is implemented. The same
process occurs for the second inner class which implements <B>Bingable</B>. Each
inner class has a single <B>private</B> instance created, which is initialized
in the <B>Outer</B> constructor. By creating the member objects and returning
references to them, issues of object lifetime are
eliminated.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I97">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I98"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Notice that both inner class definitions
are <B>private</B>, and in fact the client programmer doesn&#8217;t have any
access to details of the implementation, since the two access methods
<B>operator Poingable&amp;(&#160;)</B> and <B>operator Bingable&amp;(&#160;)</B>
only return a reference to the upcast interface, not to the object that
implements it. In fact, since the two inner classes are <B>private</B>, the
client programmer cannot even downcast to the implementation classes, thus
providing complete isolation between interface and
implementation.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I98">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I99"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Just to push a point, I&#8217;ve taken
the extra liberty here of defining the automatic type conversion operators
<B>operator Poingable&amp;(&#160;)</B> and <B>operator
Bingable&amp;(&#160;)</B>. In <B>main(&#160;)</B>, you can see that these
actually allow a syntax that looks like <B>Outer</B> is multiply inherited from
<B>Poingable</B> and <B>Bingable</B>. The difference is that the casts in this
case are one way. You can get the effect of an upcast to <B>Poingable</B> or
<B>Bingable</B>, but you cannot downcast back to an <B>Outer</B>. In the
following example of observer, you&#8217;ll see the more typical approach: you
provide access to the inner class objects using ordinary member functions, not
automatic type conversion
operations.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I99">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I100"></a>
</FONT><BR></P></DIV>
<A NAME="Heading344"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
The observer example</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Armed with the <B>Observer</B> and
<B>Observable </B>header files and the inner class idiom, we can look at an
example of the observer
pattern:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I100">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I101"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:ObservedFlower.cpp</font>
<font color=#009900>// Demonstration of "observer" pattern</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"Observable.h"</font>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Flower {
  <font color=#0000ff>bool</font> isOpen;
<font color=#0000ff>public</font>:
  Flower() : isOpen(<font color=#0000ff>false</font>), 
    openNotifier(<font color=#0000ff>this</font>), closeNotifier(<font color=#0000ff>this</font>) {}
  <font color=#0000ff>void</font> open() { <font color=#009900>// Opens its petals</font>
    isOpen = <font color=#0000ff>true</font>;
    openNotifier.notifyObservers();
    closeNotifier.open();
  }
  <font color=#0000ff>void</font> close() { <font color=#009900>// Closes its petals</font>
    isOpen = <font color=#0000ff>false</font>;
    closeNotifier.notifyObservers();
    openNotifier.close();
  }
  <font color=#009900>// Using the "inner class" idiom:</font>
  <font color=#0000ff>class</font> OpenNotifier;
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> Flower::OpenNotifier;
  <font color=#0000ff>class</font> OpenNotifier : <font color=#0000ff>public</font> Observable {
    Flower* parent;
    <font color=#0000ff>bool</font> alreadyOpen;
  <font color=#0000ff>public</font>:
    OpenNotifier(Flower* f) : parent(f), 
      alreadyOpen(<font color=#0000ff>false</font>) {}
    <font color=#0000ff>void</font> notifyObservers(Argument* arg=0) {
      <font color=#0000ff>if</font>(parent-&gt;isOpen &amp;&amp; !alreadyOpen) {
        setChanged();
        Observable::notifyObservers();
        alreadyOpen = <font color=#0000ff>true</font>;
      }
    }
    <font color=#0000ff>void</font> close() { alreadyOpen = <font color=#0000ff>false</font>; }
  } openNotifier;
  <font color=#0000ff>class</font> CloseNotifier;
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> Flower::CloseNotifier;
  <font color=#0000ff>class</font> CloseNotifier : <font color=#0000ff>public</font> Observable {
    Flower* parent;
    <font color=#0000ff>bool</font> alreadyClosed;
  <font color=#0000ff>public</font>:
    CloseNotifier(Flower* f) : parent(f), 
      alreadyClosed(<font color=#0000ff>false</font>) {}
    <font color=#0000ff>void</font> notifyObservers(Argument* arg=0) {
      <font color=#0000ff>if</font>(!parent-&gt;isOpen &amp;&amp; !alreadyClosed) {
        setChanged();
        Observable::notifyObservers();
        alreadyClosed = <font color=#0000ff>true</font>;
      }
    }
    <font color=#0000ff>void</font> open() { alreadyClosed = <font color=#0000ff>false</font>; }
  } closeNotifier;
};

<font color=#0000ff>class</font> Bee {
  string name;
  <font color=#009900>// An "inner class" for observing openings:</font>
  <font color=#0000ff>class</font> OpenObserver;
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> Bee::OpenObserver;
  <font color=#0000ff>class</font> OpenObserver : <font color=#0000ff>public</font> Observer {
    Bee* parent;
  <font color=#0000ff>public</font>:
    OpenObserver(Bee* b) : parent(b) {}
    <font color=#0000ff>void</font> update(Observable*, Argument *) {
      cout &lt;&lt; <font color=#004488>"Bee "</font> &lt;&lt; parent-&gt;name 
        &lt;&lt; <font color=#004488>"'s breakfast time!\n"</font>;
    }
  } openObsrv;
  <font color=#009900>// Another "inner class" for closings:</font>
  <font color=#0000ff>class</font> CloseObserver;
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> Bee::CloseObserver;
  <font color=#0000ff>class</font> CloseObserver : <font color=#0000ff>public</font> Observer {
    Bee* parent;
  <font color=#0000ff>public</font>:
    CloseObserver(Bee* b) : parent(b) {}
    <font color=#0000ff>void</font> update(Observable*, Argument *) {
      cout &lt;&lt; <font color=#004488>"Bee "</font> &lt;&lt; parent-&gt;name 
        &lt;&lt; <font color=#004488>"'s bed time!\n"</font>;
    }
  } closeObsrv;
<font color=#0000ff>public</font>:
  Bee(string nm) : name(nm), 
    openObsrv(<font color=#0000ff>this</font>), closeObsrv(<font color=#0000ff>this</font>) {}
  Observer&amp; openObserver() { <font color=#0000ff>return</font> openObsrv; }
  Observer&amp; closeObserver() { <font color=#0000ff>return</font> closeObsrv;}
};

<font color=#0000ff>class</font> Hummingbird {
  string name;
  <font color=#0000ff>class</font> OpenObserver;
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> Hummingbird::OpenObserver;
  <font color=#0000ff>class</font> OpenObserver : <font color=#0000ff>public</font> Observer {
    Hummingbird* parent;
  <font color=#0000ff>public</font>:
    OpenObserver(Hummingbird* h) : parent(h) {}
    <font color=#0000ff>void</font> update(Observable*, Argument *) {
      cout &lt;&lt; <font color=#004488>"Hummingbird "</font> &lt;&lt; parent-&gt;name 
        &lt;&lt; <font color=#004488>"'s breakfast time!\n"</font>;
    }
  } openObsrv;
  <font color=#0000ff>class</font> CloseObserver;
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> Hummingbird::CloseObserver;
  <font color=#0000ff>class</font> CloseObserver : <font color=#0000ff>public</font> Observer {
    Hummingbird* parent;
  <font color=#0000ff>public</font>:
    CloseObserver(Hummingbird* h) : parent(h) {}
    <font color=#0000ff>void</font> update(Observable*, Argument *) {
      cout &lt;&lt; <font color=#004488>"Hummingbird "</font> &lt;&lt; parent-&gt;name 
        &lt;&lt; <font color=#004488>"'s bed time!\n"</font>;
    }
  } closeObsrv;
<font color=#0000ff>public</font>:
  Hummingbird(string nm) : name(nm), 
    openObsrv(<font color=#0000ff>this</font>), closeObsrv(<font color=#0000ff>this</font>) {}
  Observer&amp; openObserver() { <font color=#0000ff>return</font> openObsrv; }
  Observer&amp; closeObserver() { <font color=#0000ff>return</font> closeObsrv;}
};

<font color=#0000ff>int</font> main() {
  Flower f;
  Bee ba(<font color=#004488>"A"</font>), bb(<font color=#004488>"B"</font>);
  Hummingbird ha(<font color=#004488>"A"</font>), hb(<font color=#004488>"B"</font>);
  f.openNotifier.addObserver(ha.openObserver());
  f.openNotifier.addObserver(hb.openObserver());
  f.openNotifier.addObserver(ba.openObserver());
  f.openNotifier.addObserver(bb.openObserver());
  f.closeNotifier.addObserver(ha.closeObserver());
  f.closeNotifier.addObserver(hb.closeObserver());
  f.closeNotifier.addObserver(ba.closeObserver());
  f.closeNotifier.addObserver(bb.closeObserver());
  <font color=#009900>// Hummingbird B decides to sleep in:</font>
  f.openNotifier.deleteObserver(hb.openObserver());
  <font color=#009900>// Something changes that interests observers:</font>
  f.open();
  f.open(); <font color=#009900>// It's already open, no change.</font>
  <font color=#009900>// Bee A doesn't want to go to bed:</font>
  f.closeNotifier.deleteObserver(
    ba.closeObserver());
  f.close();
  f.close(); <font color=#009900>// It's already closed; no change</font>
  f.openNotifier.deleteObservers();
  f.open();
  f.close();
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The events of interest are that a
<B>Flower</B> can open or close. Because of the use of the inner class idiom,
both these events can be separately-observable phenomena. <B>OpenNotifier</B>
and <B>CloseNotifier</B> both inherit <B>Observable</B>, so they have access to
<B>setChanged(&#160;)</B> and can be handed to anything that needs an
<B>Observable</B>. You&#8217;ll notice that, contrary to
<B>InnerClassIdiom.cpp</B>, the <B>Observable</B> descendants are <B>public</B>.
This is because some of their member functions must be available to the client
programmer. There&#8217;s nothing that says that an inner class must be
<B>private</B>; in <B>InnerClassIdiom.cpp</B> I was simply following the design
guideline &#8220;make things as private as possible.&#8221; You could make the
classes <B>private</B> and expose the appropriate methods by proxy in
<B>Flower</B>, but it wouldn&#8217;t gain
much.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I101">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I102"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The inner class idiom also comes in handy
to define more than one kind of <B>Observer</B>, in <B>Bee</B> and
<B>Hummingbird</B>, since both those classes may want to independently observe
<B>Flower</B> openings and closings. Notice how the inner class idiom provides
something that has most of the benefits of inheritance (the ability to access
the private data in the outer class, for example) without the same
restrictions.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I102">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I103"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>main(&#160;)</B>, you can see one
of the prime benefits of the observer pattern: the ability to change behavior at
runtime by dynamically registering and un-registering <B>Observer</B>s with
<B>Observable</B>s. 
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I103">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I104"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you study the code above you&#8217;ll
see that <B>OpenNotifier </B>and <B>CloseNotifier</B> use the basic
<B>Observable</B> interface. This means that you could inherit other completely
different <B>Observer</B> classes; the only connection the <B>Observer</B>s have
with <B>Flower</B>s is the <B>Observer</B>
interface.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I104">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I105"></a>
</FONT><A NAME="_Toc519042131"></A><BR></P></DIV>
<A NAME="Heading345"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Multiple dispatching</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When dealing with multiple types which
are interacting, a program can get particularly messy. For example, consider a
system that parses and executes mathematical expressions. You want to be able to
say <B>Number + Number</B>, <B>Number * Number</B>, etc., where <B>Number</B> is
the base class for a family of numerical objects. But when you say <B>a + b</B>,
and you don&#8217;t know the exact type of either <B>a</B> or <B>b</B>, so how
can you get them to interact
properly?
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I105">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I106"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The answer starts with something you
probably don&#8217;t think about: C++ performs only single dispatching. That is,
if you are performing an operation on more than one object whose type is
unknown, C++ can invoke the dynamic binding mechanism on only one of those
types. This doesn&#8217;t solve the problem, so you end up detecting some types
manually and effectively producing your own dynamic binding
behavior.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I106">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I107"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The solution is called
<A NAME="Index679"></A><A NAME="Index680"></A><I>multiple dispatching</I>.
Remember that polymorphism can occur only via member function calls, so if you
want double dispatching to occur, there must be two member function calls: the
first to determine the first unknown type, and the second to determine the
second unknown type. With multiple dispatching, you must have a virtual call to
determine each of the types. Generally, you&#8217;ll set up a configuration such
that a single member function call produces more than one dynamic member
function call and thus determines more than one type in the process. To get this
effect, you need to work with more than one virtual function: you&#8217;ll need
a virtual function call for each dispatch. The virtual functions in the
following example are called <B>compete(&#160;) </B>and <B>eval(&#160;)</B>, and
are both members of the same type. (In this case there will be only two
dispatches, which is referred to as
<A NAME="Index681"></A><A NAME="Index682"></A><I>double dispatching</I>). If you
are working with two different type hierarchies that are interacting, then
you&#8217;ll have to have a virtual call in each
hierarchy.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I107">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I108"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s an example of multiple
dispatching:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I108">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I109"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:PaperScissorsRock.cpp</font>
<font color=#009900>// Demonstration of multiple dispatching</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"..</font><font color=#004488>/purge.h"</font>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Paper;
<font color=#0000ff>class</font> Scissors;
<font color=#0000ff>class</font> Rock;

<font color=#0000ff>enum</font> Outcome { win, lose, draw };

ostream&amp; 
<font color=#0000ff>operator</font>&lt;&lt;(ostream&amp; os, <font color=#0000ff>const</font> Outcome out) {
  <font color=#0000ff>switch</font>(out) {
    <font color=#0000ff>default</font>:
    <font color=#0000ff>case</font> win: <font color=#0000ff>return</font> os &lt;&lt; <font color=#004488>"win"</font>;
    <font color=#0000ff>case</font> lose: <font color=#0000ff>return</font> os &lt;&lt; <font color=#004488>"lose"</font>;
    <font color=#0000ff>case</font> draw: <font color=#0000ff>return</font> os &lt;&lt; <font color=#004488>"draw"</font>;
  }
}

<font color=#0000ff>class</font> Item {
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> Outcome compete(<font color=#0000ff>const</font> Item*) = 0;
  <font color=#0000ff>virtual</font> Outcome eval(<font color=#0000ff>const</font> Paper*) <font color=#0000ff>const</font> = 0;
  <font color=#0000ff>virtual</font> Outcome eval(<font color=#0000ff>const</font> Scissors*) <font color=#0000ff>const</font>= 0;
  <font color=#0000ff>virtual</font> Outcome eval(<font color=#0000ff>const</font> Rock*) <font color=#0000ff>const</font> = 0;
  <font color=#0000ff>virtual</font> ostream&amp; print(ostream&amp; os) <font color=#0000ff>const</font> = 0;
  <font color=#0000ff>virtual</font> ~Item() {}
  <font color=#0000ff>friend</font> ostream&amp; 
  <font color=#0000ff>operator</font>&lt;&lt;(ostream&amp; os, <font color=#0000ff>const</font> Item* it) {
    <font color=#0000ff>return</font> it-&gt;print(os);
  }
};

<font color=#0000ff>class</font> Paper : <font color=#0000ff>public</font> Item {
<font color=#0000ff>public</font>:
  Outcome compete(<font color=#0000ff>const</font> Item* it) {
    <font color=#0000ff>return</font> it-&gt;eval(<font color=#0000ff>this</font>);
  }
  Outcome eval(<font color=#0000ff>const</font> Paper*) <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> draw;
  }
  Outcome eval(<font color=#0000ff>const</font> Scissors*) <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> win;
  }
  Outcome eval(<font color=#0000ff>const</font> Rock*) <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> lose;
  }
  ostream&amp; print(ostream&amp; os) <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> os &lt;&lt; <font color=#004488>"Paper   "</font>;
  }
};

<font color=#0000ff>class</font> Scissors : <font color=#0000ff>public</font> Item {
<font color=#0000ff>public</font>:
  Outcome compete(<font color=#0000ff>const</font> Item* it) {
    <font color=#0000ff>return</font> it-&gt;eval(<font color=#0000ff>this</font>);
  }
  Outcome eval(<font color=#0000ff>const</font> Paper*) <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> lose;
  }
  Outcome eval(<font color=#0000ff>const</font> Scissors*) <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> draw;
  }
  Outcome eval(<font color=#0000ff>const</font> Rock*) <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> win;
  }
  ostream&amp; print(ostream&amp; os) <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> os &lt;&lt; <font color=#004488>"Scissors"</font>;
  }
};

<font color=#0000ff>class</font> Rock : <font color=#0000ff>public</font> Item {
<font color=#0000ff>public</font>:
  Outcome compete(<font color=#0000ff>const</font> Item* it) {
    <font color=#0000ff>return</font> it-&gt;eval(<font color=#0000ff>this</font>);
  }
  Outcome eval(<font color=#0000ff>const</font> Paper*) <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> win;
  }
  Outcome eval(<font color=#0000ff>const</font> Scissors*) <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> lose;
  }
  Outcome eval(<font color=#0000ff>const</font> Rock*) <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> draw;
  }
  ostream&amp; print(ostream&amp; os) <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> os &lt;&lt; <font color=#004488>"Rock    "</font>;
  }
};

<font color=#0000ff>struct</font> ItemGen {
  ItemGen() { srand(time(0)); }
  Item* <font color=#0000ff>operator</font>()() {
    <font color=#0000ff>switch</font>(rand() % 3) {
      <font color=#0000ff>default</font>:
      <font color=#0000ff>case</font> 0:
        <font color=#0000ff>return</font> <font color=#0000ff>new</font> Scissors;
      <font color=#0000ff>case</font> 1:
        <font color=#0000ff>return</font> <font color=#0000ff>new</font> Paper;
      <font color=#0000ff>case</font> 2:
        <font color=#0000ff>return</font> <font color=#0000ff>new</font> Rock;
    }
  }
};

<font color=#0000ff>struct</font> Compete {
  Outcome <font color=#0000ff>operator</font>()(Item* a, Item* b) {
    cout &lt;&lt; a &lt;&lt; <font color=#004488>"\t"</font> &lt;&lt; b &lt;&lt; <font color=#004488>"\t"</font>;
    <font color=#0000ff>return</font> a-&gt;compete(b);
  }
};

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> sz = 20;
  vector&lt;Item*&gt; v(sz*2);
  generate(v.begin(), v.end(), ItemGen());
  transform(v.begin(), v.begin() + sz, 
    v.begin() + sz, 
    ostream_iterator&lt;Outcome&gt;(cout, <font color=#004488>"\n"</font>), 
    Compete());
  purge(v);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I109">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I110"></a>
</FONT><A NAME="_Toc519042132"></A><BR></P></DIV>
<A NAME="Heading346"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Visitor, a type of multiple dispatching</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The assumption is that you have a primary
class hierarchy that is fixed; perhaps it&#8217;s from another vendor and you
can&#8217;t make changes to that hierarchy. However, you&#8217;d like to add new
polymorphic methods to that hierarchy, which means that normally you&#8217;d
have to add something to the base class interface. So the dilemma is that you
need to add methods to the base class, but you can&#8217;t touch the base class.
How do you get around
this?
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I110">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I111"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The design pattern that solves this kind
of problem is called a &#8220;visitor&#8221; (the final one in the <I>Design
Patterns</I> book), and it builds on the double<I> </I>dispatching scheme shown
in the last section.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I111">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I112"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index683"></A><A NAME="Index684"></A>visitor pattern allows you to
extend the interface of the primary type by creating a separate class hierarchy
of type <B>Visitor </B>to virtualize the operations performed upon the primary
type. The objects of the primary type simply &#8220;accept&#8221; the visitor,
then call the visitor&#8217;s dynamically<B>-</B>bound member
function.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I112">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I113"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:BeeAndFlowers.cpp</font>
<font color=#009900>// Demonstration of "visitor" pattern</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"..</font><font color=#004488>/purge.h"</font>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Gladiolus;
<font color=#0000ff>class</font> Renuculus;
<font color=#0000ff>class</font> Chrysanthemum;

<font color=#0000ff>class</font> Visitor {
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> visit(Gladiolus* f) = 0;
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> visit(Renuculus* f) = 0;
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> visit(Chrysanthemum* f) = 0;
  <font color=#0000ff>virtual</font> ~Visitor() {}
};

<font color=#0000ff>class</font> Flower {
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> accept(Visitor&amp;) = 0;
  <font color=#0000ff>virtual</font> ~Flower() {}
};

<font color=#0000ff>class</font> Gladiolus : <font color=#0000ff>public</font> Flower {
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> accept(Visitor&amp; v) {
    v.visit(<font color=#0000ff>this</font>);
  }
};

<font color=#0000ff>class</font> Renuculus : <font color=#0000ff>public</font> Flower {
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> accept(Visitor&amp; v) {
    v.visit(<font color=#0000ff>this</font>);
  }
};

<font color=#0000ff>class</font> Chrysanthemum : <font color=#0000ff>public</font> Flower {
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> accept(Visitor&amp; v) {
    v.visit(<font color=#0000ff>this</font>);
  }
};

<font color=#009900>// Add the ability to produce a string:</font>
<font color=#0000ff>class</font> StringVal : <font color=#0000ff>public</font> Visitor {
  string s;
<font color=#0000ff>public</font>:
  <font color=#0000ff>operator</font> <font color=#0000ff>const</font> string&amp;() { <font color=#0000ff>return</font> s; }
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> visit(Gladiolus*) {
    s = <font color=#004488>"Gladiolus"</font>;
  }
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> visit(Renuculus*) {
    s = <font color=#004488>"Renuculus"</font>;
  }
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> visit(Chrysanthemum*) {
    s = <font color=#004488>"Chrysanthemum"</font>;
  }
};

<font color=#009900>// Add the ability to do "Bee" activities:</font>
<font color=#0000ff>class</font> Bee : <font color=#0000ff>public</font> Visitor {
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> visit(Gladiolus*) {
    cout &lt;&lt; <font color=#004488>"Bee and Gladiolus\n"</font>;
  }
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> visit(Renuculus*) {
    cout &lt;&lt; <font color=#004488>"Bee and Renuculus\n"</font>;
  }
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> visit(Chrysanthemum*) {
    cout &lt;&lt; <font color=#004488>"Bee and Chrysanthemum\n"</font>;
  }
};

<font color=#0000ff>struct</font> FlowerGen {
  FlowerGen() { srand(time(0)); }
  Flower* <font color=#0000ff>operator</font>()() {
    <font color=#0000ff>switch</font>(rand() % 3) {
      <font color=#0000ff>default</font>:
      <font color=#0000ff>case</font> 0: <font color=#0000ff>return</font> <font color=#0000ff>new</font> Gladiolus;
      <font color=#0000ff>case</font> 1: <font color=#0000ff>return</font> <font color=#0000ff>new</font> Renuculus;
      <font color=#0000ff>case</font> 2: <font color=#0000ff>return</font> <font color=#0000ff>new</font> Chrysanthemum;
    }
  }
};

<font color=#0000ff>int</font> main() {
  vector&lt;Flower*&gt; v(10);
  generate(v.begin(), v.end(), FlowerGen());
  vector&lt;Flower*&gt;::iterator it;
  <font color=#009900>// It's almost as if I added a virtual function</font>
  <font color=#009900>// to produce a Flower string representation:</font>
  StringVal sval;
  <font color=#0000ff>for</font>(it = v.begin(); it != v.end(); it++) {
    (*it)-&gt;accept(sval);
    cout &lt;&lt; string(sval) &lt;&lt; endl;
  }
  <font color=#009900>// Perform "Bee" operation on all Flowers:</font>
  Bee bee;
  <font color=#0000ff>for</font>(it = v.begin(); it != v.end(); it++)
    (*it)-&gt;accept(bee);
  purge(v);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I113">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I114"></a>
</FONT><A NAME="_Toc519042133"></A><BR></P></DIV>
<A NAME="Heading347"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Proxy<A NAME="_Toc519042134"></A></H2></FONT>
<A NAME="Heading348"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Efficiency<A NAME="_Toc519042135"></A></H2></FONT>
<A NAME="Heading349"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Reference counting<A NAME="_Toc519042136"></A></H3></FONT>
<A NAME="Heading350"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Flyweight<A NAME="_Toc408018798"></A><A NAME="_Toc519042137"></A></H3></FONT>
<A NAME="Heading351"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
The composite<A NAME="_Toc519042138"></A></H2></FONT>
<A NAME="Heading352"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Evolving a design: the trash recycler</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The nature of this problem (modeling a
trash recycling system) is that the trash is thrown unclassified into a single
bin, so the specific type information is lost. But later, the specific type
information must be recovered to properly sort the trash. In the initial
solution, RTTI (described in Chapter XX) is
used.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I114">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I115"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is not a trivial design because it
has an added constraint. That&#8217;s what makes it interesting &#8211;
it&#8217;s more like the messy problems you&#8217;re likely to encounter in your
work. The extra constraint is that the trash arrives at the trash recycling
plant all mixed together. The program must model the sorting of that trash. This
is where RTTI comes in: you have a bunch of anonymous pieces of trash, and the
program figures out exactly what type they
are.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I115">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I116"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the objectives of this program is
to sum up the weight and value of the different types of trash. The trash will
be kept in (potentially different types of) containers, so it makes sense to
templatize the &#8220;summation&#8221; function on the container holding it
(assuming that container exhibits basic STL-like behavior), so the function will
be maximally flexible:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I116">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I117"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:sumValue.h</font>
<font color=#009900>// Sums the value of Trash in any type of STL</font>
<font color=#009900>// container of any specific type of Trash:</font>
#ifndef SUMVALUE_H
#define SUMVALUE_H
#include &lt;typeinfo&gt;
#include &lt;vector&gt;

<font color=#0000ff>template</font>&lt;<font color=#0000ff>typename</font> Cont&gt;
<font color=#0000ff>void</font> sumValue(<font color=#0000ff>const</font> Cont&amp; bin) {
  <font color=#0000ff>double</font> val = 0.0f;
  <font color=#0000ff>typename</font> 
    Cont::const_iterator tally = bin.begin();
  <font color=#0000ff>while</font>(tally != bin.end()) {
    val +=(*tally)-&gt;weight() * (*tally)-&gt;value();
    out &lt;&lt; <font color=#004488>"weight of "</font>
        &lt;&lt; <font color=#0000ff>typeid</font>(*(*tally)).name()
        &lt;&lt; <font color=#004488>" = "</font> &lt;&lt; (*tally)-&gt;weight() 
        &lt;&lt; endl;
    tally++;
  }
  out &lt;&lt; <font color=#004488>"Total value = "</font> &lt;&lt; val &lt;&lt; endl;
}
#endif <font color=#009900>// SUMVALUE_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you look at a piece of code like
this, it can be initially disturbing because you might wonder &#8220;how can the
compiler know that the member functions I&#8217;m calling here are valid?&#8221;
But of course, all the template says is &#8220;generate this code on
demand,&#8221; and so only when you call the function will type checking come
into play. This enforces that <B>*tally</B> produces an object that has member
functions <B>weight(&#160;)</B> and <B>value(&#160;)</B>, and that <B>out</B> is
a global
<B>ostream</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I117">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I118"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>sumValue(&#160;)</B> function is
templatized on the type of container that&#8217;s holding the <B>Trash
</B>pointers. Notice there&#8217;s nothing in the template signature that says
&#8220;this container must behave like an STL container and must hold
<B>Trash*</B>&#8221;; that is all implied in the code that&#8217;s generated
which uses the
container.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I118">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I119"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first version of the example takes
the straightforward approach: creating a <B>vector&lt;Trash*&gt;</B>, filling it
with <B>Trash</B> objects, then using RTTI to sort them
out:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I119">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I120"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:Recycle1.cpp </font>
<font color=#009900>// Recycling with RTTI</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"sumValue.h"</font>
#include <font color=#004488>"..</font><font color=#004488>/purge.h"</font>
#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;typeinfo&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;
ofstream out(<font color=#004488>"Recycle1.out"</font>);

<font color=#0000ff>class</font> Trash {
  <font color=#0000ff>double</font> _weight;
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> _count; <font color=#009900>// # created</font>
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> _dcount; <font color=#009900>// # destroyed</font>
  <font color=#009900>// disallow automatic creation of</font>
  <font color=#009900>// assignment &amp; copy-constructor:</font>
  <font color=#0000ff>void</font> <font color=#0000ff>operator</font>=(<font color=#0000ff>const</font> Trash&amp;);
  Trash(<font color=#0000ff>const</font> Trash&amp;);
<font color=#0000ff>public</font>:
  Trash(<font color=#0000ff>double</font> wt) : _weight(wt) { 
    _count++; 
  }
  <font color=#0000ff>virtual</font> <font color=#0000ff>double</font> value() <font color=#0000ff>const</font> = 0;
  <font color=#0000ff>double</font> weight() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> _weight; }
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> count() { <font color=#0000ff>return</font> _count; }
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> dcount() { <font color=#0000ff>return</font> _dcount;}
  <font color=#0000ff>virtual</font> ~Trash() { _dcount++; }
};

<font color=#0000ff>int</font> Trash::_count = 0;
<font color=#0000ff>int</font> Trash::_dcount = 0;

<font color=#0000ff>class</font> Aluminum : <font color=#0000ff>public</font> Trash {
  <font color=#0000ff>static</font> <font color=#0000ff>double</font> val;
<font color=#0000ff>public</font>:
  Aluminum(<font color=#0000ff>double</font> wt) : Trash(wt) {}
  <font color=#0000ff>double</font> value() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> val; }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> value(<font color=#0000ff>double</font> newval) {
    val = newval;
  }
  ~Aluminum() { out &lt;&lt; <font color=#004488>"~Aluminum\n"</font>; }
};

<font color=#0000ff>double</font> Aluminum::val = 1.67F;

<font color=#0000ff>class</font> Paper : <font color=#0000ff>public</font> Trash {
  <font color=#0000ff>static</font> <font color=#0000ff>double</font> val;
<font color=#0000ff>public</font>:
  Paper(<font color=#0000ff>double</font> wt) : Trash(wt) {}
  <font color=#0000ff>double</font> value() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> val; }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> value(<font color=#0000ff>double</font> newval) {
    val = newval;
  }
  ~Paper() { out &lt;&lt; <font color=#004488>"~Paper\n"</font>; }
};

<font color=#0000ff>double</font> Paper::val = 0.10F;

<font color=#0000ff>class</font> Glass : <font color=#0000ff>public</font> Trash {
  <font color=#0000ff>static</font> <font color=#0000ff>double</font> val;
<font color=#0000ff>public</font>:
  Glass(<font color=#0000ff>double</font> wt) : Trash(wt) {}
  <font color=#0000ff>double</font> value() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> val; }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> value(<font color=#0000ff>double</font> newval) {
    val = newval;
  }
  ~Glass() { out &lt;&lt; <font color=#004488>"~Glass\n"</font>; }
};

<font color=#0000ff>double</font> Glass::val = 0.23F;

<font color=#0000ff>class</font> TrashGen {
<font color=#0000ff>public</font>:
  TrashGen() { srand(time(0)); }
  <font color=#0000ff>static</font> <font color=#0000ff>double</font> frand(<font color=#0000ff>int</font> mod) {
    <font color=#0000ff>return</font> <font color=#0000ff>static_cast</font>&lt;<font color=#0000ff>double</font>&gt;(rand() % mod);
  }
  Trash* <font color=#0000ff>operator</font>()() {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 30; i++)
      <font color=#0000ff>switch</font>(rand() % 3) {
        <font color=#0000ff>case</font> 0 :
          <font color=#0000ff>return</font> <font color=#0000ff>new</font> Aluminum(frand(100));
        <font color=#0000ff>case</font> 1 :
          <font color=#0000ff>return</font> <font color=#0000ff>new</font> Paper(frand(100));
        <font color=#0000ff>case</font> 2 :
          <font color=#0000ff>return</font> <font color=#0000ff>new</font> Glass(frand(100));
      }
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> Aluminum(0);
    <font color=#009900>// Or throw exeception...</font>
  }
};

<font color=#0000ff>int</font> main() {
  vector&lt;Trash*&gt; bin;
  <font color=#009900>// Fill up the Trash bin:</font>
  generate_n(back_inserter(bin), 30, TrashGen());
  vector&lt;Aluminum*&gt; alBin;
  vector&lt;Paper*&gt; paperBin;
  vector&lt;Glass*&gt; glassBin;
  vector&lt;Trash*&gt;::iterator sorter = bin.begin();
  <font color=#009900>// Sort the Trash:</font>
  <font color=#0000ff>while</font>(sorter != bin.end()) {
    Aluminum* ap = 
      <font color=#0000ff>dynamic_cast</font>&lt;Aluminum*&gt;(*sorter);
    Paper* pp = <font color=#0000ff>dynamic_cast</font>&lt;Paper*&gt;(*sorter);
    Glass* gp = <font color=#0000ff>dynamic_cast</font>&lt;Glass*&gt;(*sorter);
    <font color=#0000ff>if</font>(ap) alBin.push_back(ap);
    <font color=#0000ff>if</font>(pp) paperBin.push_back(pp);
    <font color=#0000ff>if</font>(gp) glassBin.push_back(gp);
    sorter++;
  }
  sumValue(alBin);
  sumValue(paperBin);
  sumValue(glassBin);
  sumValue(bin);
  out &lt;&lt; <font color=#004488>"total created = "</font>
      &lt;&lt; Trash::count() &lt;&lt; endl;
  purge(bin);
  out &lt;&lt; <font color=#004488>"total destroyed = "</font>
      &lt;&lt; Trash::dcount() &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This uses the classic structure of
virtual functions in the base class that are redefined in the derived class. In
addition, there are two <B>static </B>data members in the base class:<B>
</B>_<B>count </B>to indicate the number of <B>Trash </B>objects that are
created, and <B>_dcount </B>to keep track of the number that are destroyed. This
verifies that proper memory management occurs. To support this, the
<B>operator=</B> and copy-constructor are disallowed by declaring them
<B>private</B> (no definitions are necessary; this simply prevents the compiler
from synthesizing them). Those operations would cause problems with the count,
and if they were allowed you&#8217;d have to define them
properly.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I120">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I121"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Trash</B> objects are created, for
the sake of this example, by the generator <B>TrashGen</B>, which uses the
random number generator to choose the type of <B>Trash</B>, and also to provide
it with a &#8220;weight&#8221; argument. The return value of the
generator&#8217;s <B>operator(&#160;) </B>is upcast to <B>Trash*</B>, so all the
specific type information is lost.<B> </B>In <B>main(&#160;)</B>, a
<B>vector&lt;Trash*&gt;</B> called <B>bin </B>is created and then filled using
the STL algorithm <B>generate_n(&#160;)</B>. To perform the sorting, three
<B>vector</B>s are created, each of which holds a different type of
<B>Trash*</B>. An iterator moves through <B>bin</B> and RTTI is used to
determine which specific type of <B>Trash</B> the iterator is currently
selecting, placing each into the appropriate typed bin. Finally,
<B>sumValue(&#160;)</B> is applied to each of the containers, and the <B>Trash
</B>objects are cleaned up using <B>purge(&#160;)</B> (defined in Chapter XX).
The creation and destruction counts ensure that things are properly cleaned
up.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I121">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I122"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, it seems silly to upcast the
types of <B>Trash</B> into a container holding base type pointers, and then to
turn around and downcast. Why not just put the trash into the appropriate
receptacle in the first place? (indeed, this is the whole enigma of recycling).
In this program it might be easy to repair, but sometimes a system&#8217;s
structure and flexibility can benefit greatly from
downcasting.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I122">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I123"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The program satisfies the design
requirements: it works. This may be fine as long as it&#8217;s a one-shot
solution. However, a good program will evolve over time, so you must ask: what
if the situation changes? For example, cardboard is now a valuable recyclable
commodity, so how will that be integrated into the system (especially if the
program is large and complicated). Since the above type-check coding in the
<B>switch</B> statement and in the RTTI statements could be scattered throughout
the program, you&#8217;d have to go find all that code every time a new type was
added, and if you miss one the compiler won&#8217;t help
you.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I123">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I124"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The key to the misuse of RTTI here is
that <I>every type is tested</I>. If you&#8217;re only looking for a subset of
types because that subset needs special treatment, that&#8217;s probably fine.
But if you&#8217;re hunting for every type inside a <B>switch</B> statement,
then you&#8217;re probably missing an important point, and definitely making
your code less maintainable. In the next section we&#8217;ll look at how this
program evolved over several stages to become much more flexible. This should
prove a valuable example in program
design.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I124">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I125"></a>
</FONT><A NAME="_Toc375545414"></A><A NAME="_Toc408018799"></A><A NAME="_Toc519042139"></A><BR></P></DIV>
<A NAME="Heading353"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Improving the design</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The solutions in <I>Design Patterns</I>
are organized around the question &#8220;What will change as this program
evolves?&#8221; This is usually the most important question that you can ask
about any design. If you can build your system around the answer, the results
will be two-pronged: not only will your system allow easy (and inexpensive)
maintenance, but you might also produce components that are reusable, so that
other systems can be built more cheaply. This is the promise of object-oriented
programming, but it doesn&#8217;t happen automatically; it requires thought and
insight on your part. In this section we&#8217;ll see how this process can
happen during the refinement of a
system.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I125">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I126"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The answer to the question &#8220;What
will change?&#8221; for the recycling system is a common one: more types will be
added to the system. The goal of the design, then, is to make this addition of
types as painless as possible. In the recycling program, we&#8217;d like to
encapsulate all places where specific type information is mentioned, so (if for
no other reason) any changes can be localized inside those encapsulations. It
turns out that this process also cleans up the rest of the code
considerably.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I126">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I127"></a>
</FONT><A NAME="_Toc375545415"></A><A NAME="_Toc408018800"></A><A NAME="_Toc519042140"></A><BR></P></DIV>
<A NAME="Heading354"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
&#8220;Make more objects&#8221;</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This brings up a general object-oriented
design principle that I first heard spoken by <A NAME="Index685"></A>Grady
Booch: &#8220;If the design is too complicated, make more objects.&#8221; This
is simultaneously counterintuitive and ludicrously simple, and yet it&#8217;s
the most useful guideline I&#8217;ve found. (You might observe that &#8220;make
more objects&#8221; is often equivalent to &#8220;add another level of
indirection.&#8221;) In general, if you find a place with messy code, consider
what sort of class would clean things up. Often the side effect of cleaning up
the code will be a system that has better structure and is more
flexible.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I127">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I128"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Consider first the place where
<B>Trash</B> objects are created. In the above example, we&#8217;re conveniently
using a generator to create the objects. The generator nicely encapsulates the
creation of the objects, but the neatness is an illusion because in general
we&#8217;ll want to create the objects based on something more than a random
number generator. Some information will be available which will determine what
kind of <B>Trash</B> object this should be. Because you generally need to make
your objects by examining some kind of information, if you&#8217;re not paying
close attention you may end up with <B>switch</B> statements (as in
<B>TrashGen</B>) or cascaded <B>if </B>statements scattered throughout your
code. This is definitely messy, and also a place where you must change code
whenever a new type is added. If new types are commonly added, a better solution
is a single member function that takes all of the necessary information and
produces an object of the correct type, already upcast to a <B>Trash</B>
pointer. In <I>Design Patterns</I> this is broadly referred to as a
<A NAME="Index686"></A><A NAME="Index687"></A><I>creational pattern</I> (of
which there are several). The specific pattern that will be applied here is a
variant of the <A NAME="Index688"></A><A NAME="Index689"></A><I>Factory
Method</I> (&#8220;method&#8221; being a more OOPish way to refer to a member
function). Here, the factory method will be a <B>static</B> member of
<B>Trash</B>, but more commonly it is a member function that is overridden in
the derived class.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I128">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I129"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The idea of the factory method is that
you pass it the essential information it needs to know to create your object,
then stand back and wait for the pointer (already upcast to the base type) to
pop out as the return value. From then on, you treat the object polymorphically.
Thus, you never even need to know the exact type of object that&#8217;s created.
In fact, the factory method hides it from you to prevent accidental misuse. If
you want to use the object without polymorphism, you must explicitly use RTTI
and casting.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I129">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I130"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">But there&#8217;s a little problem,
especially when you use the more complicated approach (not shown here) of making
the factory method in the base class and overriding it in the derived classes.
What if the information required in the derived class requires more or different
arguments? &#8220;Creating more objects&#8221; solves this problem. To implement
the factory method, the <B>Trash</B> class gets a new member function called
<B>factory(&#160;)</B>. To hide the creational data, there&#8217;s a new class
called <B>Info</B> that contains all of the necessary information for the
<B>factory(&#160;)</B> method to create the appropriate <B>Trash</B> object.
Here&#8217;s a simple implementation of
<B>Info</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I130">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I131"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>  <font color=#0000ff>class</font> Info {
    <font color=#0000ff>int</font> type;
    <font color=#009900>// Must change this to add another type:</font>
    <font color=#0000ff>enum</font> { maxnum = 3 };
    <font color=#0000ff>double</font> data;
  <font color=#0000ff>public</font>:
    Info(<font color=#0000ff>int</font> typeNum, <font color=#0000ff>double</font> dat)
      : type(typeNum % maxnum), data(dat) {}
  };</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An <B>Info</B> object&#8217;s only job is
to hold information for the <B>factory(&#160;)</B> method. Now, if there&#8217;s
a situation in which <B>factory(&#160;)</B> needs more or different information
to create a new type of <B>Trash</B> object, the <B>factory(&#160;)</B>
interface doesn&#8217;t need to be changed. The <B>Info</B> class can be changed
by adding new data and new constructors, or in the more typical object-oriented
fashion of subclassing.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I131">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I132"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s the second version of the
program with the factory method added. The object-counting code has been
removed; we&#8217;ll assume proper cleanup will take place in all the rest of
the examples.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I132">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I133"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:Recycle2.cpp</font>
<font color=#009900>// Adding a factory method</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"sumValue.h"</font>
#include <font color=#004488>"..</font><font color=#004488>/purge.h"</font>
#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;typeinfo&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;
ofstream out(<font color=#004488>"Recycle2.out"</font>);

<font color=#0000ff>class</font> Trash {
  <font color=#0000ff>double</font> _weight;
  <font color=#0000ff>void</font> <font color=#0000ff>operator</font>=(<font color=#0000ff>const</font> Trash&amp;);
  Trash(<font color=#0000ff>const</font> Trash&amp;);
<font color=#0000ff>public</font>:
  Trash(<font color=#0000ff>double</font> wt) : _weight(wt) { }
  <font color=#0000ff>virtual</font> <font color=#0000ff>double</font> value() <font color=#0000ff>const</font> = 0;
  <font color=#0000ff>double</font> weight() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> _weight; }
  <font color=#0000ff>virtual</font> ~Trash() {}
  <font color=#009900>// Nested class because it's tightly coupled</font>
  <font color=#009900>// to Trash:</font>
  <font color=#0000ff>class</font> Info {
    <font color=#0000ff>int</font> type;
    <font color=#009900>// Must change this to add another type:</font>
    <font color=#0000ff>enum</font> { maxnum = 3 };
    <font color=#0000ff>double</font> data;
    <font color=#0000ff>friend</font> <font color=#0000ff>class</font> Trash;
  <font color=#0000ff>public</font>:
    Info(<font color=#0000ff>int</font> typeNum, <font color=#0000ff>double</font> dat)
      : type(typeNum % maxnum), data(dat) {}
  };
  <font color=#0000ff>static</font> Trash* factory(<font color=#0000ff>const</font> Info&amp; info);
};

<font color=#0000ff>class</font> Aluminum : <font color=#0000ff>public</font> Trash {
  <font color=#0000ff>static</font> <font color=#0000ff>double</font> val;
<font color=#0000ff>public</font>:
  Aluminum(<font color=#0000ff>double</font> wt) : Trash(wt) {}
  <font color=#0000ff>double</font> value() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> val; }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> value(<font color=#0000ff>double</font> newval) {
    val = newval;
  }
  ~Aluminum() { out &lt;&lt; <font color=#004488>"~Aluminum\n"</font>; }
};

<font color=#0000ff>double</font> Aluminum::val = 1.67F;

<font color=#0000ff>class</font> Paper : <font color=#0000ff>public</font> Trash {
  <font color=#0000ff>static</font> <font color=#0000ff>double</font> val;
<font color=#0000ff>public</font>:
  Paper(<font color=#0000ff>double</font> wt) : Trash(wt) {}
  <font color=#0000ff>double</font> value() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> val; }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> value(<font color=#0000ff>double</font> newval) {
    val = newval;
  }
  ~Paper() { out &lt;&lt; <font color=#004488>"~Paper\n"</font>; }
};

<font color=#0000ff>double</font> Paper::val = 0.10F;

<font color=#0000ff>class</font> Glass : <font color=#0000ff>public</font> Trash {
  <font color=#0000ff>static</font> <font color=#0000ff>double</font> val;
<font color=#0000ff>public</font>:
  Glass(<font color=#0000ff>double</font> wt) : Trash(wt) {}
  <font color=#0000ff>double</font> value() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> val; }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> value(<font color=#0000ff>double</font> newval) {
    val = newval;
  }
  ~Glass() { out &lt;&lt; <font color=#004488>"~Glass\n"</font>; }
};

<font color=#0000ff>double</font> Glass::val = 0.23F;

<font color=#009900>// Definition of the factory method. It must know</font>
<font color=#009900>// all the types, so is defined after all the</font>
<font color=#009900>// subtypes are defined:</font>
Trash* Trash::factory(<font color=#0000ff>const</font> Info&amp; info) {
  <font color=#0000ff>switch</font>(info.type) {
    <font color=#0000ff>default</font>: <font color=#009900>// In case of overrun</font>
    <font color=#0000ff>case</font> 0:
      <font color=#0000ff>return</font> <font color=#0000ff>new</font> Aluminum(info.data);
    <font color=#0000ff>case</font> 1:
      <font color=#0000ff>return</font> <font color=#0000ff>new</font> Paper(info.data);
    <font color=#0000ff>case</font> 2:
      <font color=#0000ff>return</font> <font color=#0000ff>new</font> Glass(info.data);
  }
}

<font color=#009900>// Generator for Info objects:</font>
<font color=#0000ff>class</font> InfoGen {
  <font color=#0000ff>int</font> typeQuantity;
  <font color=#0000ff>int</font> maxWeight;
<font color=#0000ff>public</font>:
  InfoGen(<font color=#0000ff>int</font> typeQuant, <font color=#0000ff>int</font> maxWt)
    : typeQuantity(typeQuant), maxWeight(maxWt) {
    srand(time(0)); 
  }
  Trash::Info <font color=#0000ff>operator</font>()() {
    <font color=#0000ff>return</font> Trash::Info(rand() % typeQuantity, 
      <font color=#0000ff>static_cast</font>&lt;<font color=#0000ff>double</font>&gt;(rand() % maxWeight));
  }
};

<font color=#0000ff>int</font> main() {
  vector&lt;Trash*&gt; bin;
  <font color=#009900>// Fill up the Trash bin:</font>
  InfoGen infoGen(3, 100);
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 30; i++)
    bin.push_back(Trash::factory(infoGen()));
  vector&lt;Aluminum*&gt; alBin;
  vector&lt;Paper*&gt; paperBin;
  vector&lt;Glass*&gt; glassBin;
  vector&lt;Trash*&gt;::iterator sorter = bin.begin();
  <font color=#009900>// Sort the Trash:</font>
  <font color=#0000ff>while</font>(sorter != bin.end()) {
    Aluminum* ap = 
      <font color=#0000ff>dynamic_cast</font>&lt;Aluminum*&gt;(*sorter);
    Paper* pp = <font color=#0000ff>dynamic_cast</font>&lt;Paper*&gt;(*sorter);
    Glass* gp = <font color=#0000ff>dynamic_cast</font>&lt;Glass*&gt;(*sorter);
    <font color=#0000ff>if</font>(ap) alBin.push_back(ap);
    <font color=#0000ff>if</font>(pp) paperBin.push_back(pp);
    <font color=#0000ff>if</font>(gp) glassBin.push_back(gp);
    sorter++;
  }
  sumValue(alBin);
  sumValue(paperBin);
  sumValue(glassBin);
  sumValue(bin);
  purge(bin); <font color=#009900>// Cleanup</font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the factory method
<B>Trash::factory(&#160;)</B>, the determination of the exact type of object is
simple, but you can imagine a more complicated system in which
<B>factory(&#160;)</B> uses an elaborate algorithm. The point is that it&#8217;s
now hidden away in one place, and you know to come to this place to make changes
when you add new types.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I133">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I134"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The creation of new objects is now more
general in <B>main(&#160;)</B>, and depends on &#8220;real&#8221; data (albeit
created by another generator, driven by random numbers). The generator object is
created, telling it the maximum type number and the largest &#8220;data&#8221;
value to produce. Each call to the generator creates an <B>Info</B> object which
is passed into <B>Trash::factory(&#160;)</B>, which in turn produces some kind
of <B>Trash</B> object and returns the pointer that&#8217;s added to the
<B>vector&lt;Trash*&gt;</B> <B>bin</B>.

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I134">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I135"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The constructor for the <B>Info
</B>object is very specific and restrictive in this example. However, you could
also imagine a <B>vector</B> of arguments into the <B>Info </B>constructor (or
directly into a <B>factory(&#160;)</B> call, for that matter). This requires
that the arguments be parsed and checked at runtime, but it does provide the
greatest flexibility.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I135">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I136"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see from this code what
&#8220;<A NAME="Index690"></A><A NAME="Index691"></A><A NAME="Index692"></A>vector
of change&#8221; problem the factory is responsible for solving: if you add new
types to the system (the change), the only code that must be modified is within
the factory, so the factory isolates the effect of that
change.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I136">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I137"></a>
</FONT><A NAME="_Toc375545418"></A><A NAME="_Toc408018801"></A><A NAME="_Toc519042141"></A><BR></P></DIV>
<A NAME="Heading355"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
A pattern for prototyping creation</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A problem with the above design is that
it still requires a central location where all the types of the objects must be
known: inside the <B>factory(&#160;)</B> method. If new types are regularly
being added to the system, the <B>factory(&#160;)</B> method must be changed for
each new type. When you discover something like this, it is useful to try to go
one step further and move <I>all</I> of the activities involving that specific
type &#8211; including its creation &#8211; into the class representing that
type. This way, the only thing you need to do to add a new type to the system is
to inherit a single
class.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I137">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I138"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To move the information concerning type
creation into each specific type of <B>Trash</B>,<B> </B>the
&#8220;<A NAME="Index693"></A><A NAME="Index694"></A>prototype&#8221; pattern
will be used. The general idea is that you have a master container of objects,
one of each type you&#8217;re interested in making. The &#8220;prototype
objects&#8221; in this container are used <I>only</I> for making new objects. In
this case, we&#8217;ll name the object-creation member function
<B>clone(&#160;)</B>.<B> </B>When you&#8217;re ready to make a new object,
presumably you have some sort of information that establishes the type of object
you want to create. The <B>factory(&#160;)</B> method (it&#8217;s not required
that you use factory with prototype, but they commingle nicely) moves through
the master container comparing your information with whatever appropriate
information is in the prototype objects in the master container. When a match is
found, <B>factory(&#160;) </B>returns a clone of that
object.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I138">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I139"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In this scheme there is no hard-coded
information for creation. Each object knows how to expose appropriate
information to allow matching, and how to clone itself. Thus, the
<B>factory(&#160;)</B> method doesn&#8217;t need to be changed when a new type
is added to the system.

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I139">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I140"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The prototypes will be contained in a
<B>static</B> <B>vector&lt;Trash*&gt;</B> called <B>prototypes</B>. This is a
<B>private</B> member of the base class <B>Trash</B>. The <B>friend </B>class
<B>TrashProtoInit </B>is responsible for putting the <B>Trash*</B> prototypes
into the prototype
list.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I140">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I141"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll also note that the
<B>Info</B> class has changed. It now uses a <B>string</B> to act as type
identification information. As you shall see, this will allow us to read object
information from a file when creating <B>Trash</B>
objects.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I141">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I142"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:Trash.h</font>
<font color=#009900>// Base class for Trash recycling examples</font>
#ifndef TRASH_H
#define TRASH_H
#include &lt;iostream&gt;
#include &lt;exception&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

<font color=#0000ff>class</font> TypedBin; <font color=#009900>// For a later example</font>
<font color=#0000ff>class</font> Visitor; <font color=#009900>// For a later example</font>

<font color=#0000ff>class</font> Trash {
  <font color=#0000ff>double</font> _weight;
  <font color=#0000ff>void</font> <font color=#0000ff>operator</font>=(<font color=#0000ff>const</font> Trash&amp;);
  Trash(<font color=#0000ff>const</font> Trash&amp;);
<font color=#0000ff>public</font>:
  Trash(<font color=#0000ff>double</font> wt) : _weight(wt) {}
  <font color=#0000ff>virtual</font> <font color=#0000ff>double</font> value() <font color=#0000ff>const</font> = 0;
  <font color=#0000ff>double</font> weight() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> _weight; }
  <font color=#0000ff>virtual</font> ~Trash() {}
  <font color=#0000ff>class</font> Info {
    std::string _id;
    <font color=#0000ff>double</font> _data;
  <font color=#0000ff>public</font>:
    Info(std::string ident, <font color=#0000ff>double</font> dat)
      : _id(ident), _data(dat) {}
    <font color=#0000ff>double</font> data() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> _data; }
    std::string id() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> _id; }
    <font color=#0000ff>friend</font> std::ostream&amp; <font color=#0000ff>operator</font>&lt;&lt;(
      std::ostream&amp; os, <font color=#0000ff>const</font> Info&amp; info) {
      <font color=#0000ff>return</font> os &lt;&lt; info._id &lt;&lt; ':' &lt;&lt; info._data;
    }
  };
<font color=#0000ff>protected</font>:
  <font color=#009900>// Remainder of class provides support for</font>
  <font color=#009900>// prototyping:</font>
  <font color=#0000ff>static</font> std::vector&lt;Trash*&gt; prototypes;
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> TrashProtoInit;
  Trash() : _weight(0) {}
<font color=#0000ff>public</font>:
  <font color=#0000ff>static</font> Trash* factory(<font color=#0000ff>const</font> Info&amp; info);
  <font color=#0000ff>virtual</font> std::string id() = 0;  <font color=#009900>// type ident</font>
  <font color=#0000ff>virtual</font> Trash* clone(<font color=#0000ff>const</font> Info&amp;) = 0;
  <font color=#009900>// Stubs, inserted for later use:</font>
  <font color=#0000ff>virtual</font> <font color=#0000ff>bool</font> 
  addToBin(std::vector&lt;TypedBin*&gt;&amp;) { 
    <font color=#0000ff>return</font> <font color=#0000ff>false</font>; 
  }
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> accept(Visitor&amp;) {};
};
#endif <font color=#009900>// TRASH_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The basic part of the <B>Trash</B> class
remains as before. The rest of the class supports the prototyping pattern. The
<B>id(&#160;)</B> member function returns a <B>string</B> that can be compared
with the <B>id(&#160;)</B> of an <B>Info</B> object to determine whether this is
the prototype that should be cloned (of course, the evaluation can be much more
sophisticated than that if you need it). Both <B>id(&#160;)</B> and
<B>clone(&#160;)</B> are pure <B>virtual</B> functions so they must be
overridden in derived
classes.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I142">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I143"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The last two member functions,
<B>addToBin(&#160;)</B> and <B>accept(&#160;)</B>, are &#8220;stubs&#8221; which
will be used in later versions of the trash sorting problem. It&#8217;s
necessary to have these virtual functions in the base class, but in the early
examples there&#8217;s no need for them, so they are not pure virtuals so as not
to intrude.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I143">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I144"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>factory(&#160;) </B>member
function has the same declaration, but the definition is what handles the
prototyping. Here is the implementation
file:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I144">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I145"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:Trash.cpp {O}</font>
#include <font color=#004488>"Trash.h"</font>
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

Trash* Trash::factory(<font color=#0000ff>const</font> Info&amp; info) {
  vector&lt;Trash*&gt;::iterator it;
  <font color=#0000ff>for</font>(it = prototypes.begin();
    it != prototypes.end(); it++) {
    <font color=#009900>// Somehow determine the new type</font>
    <font color=#009900>// to create, and clone one:</font>
    <font color=#0000ff>if</font> (info.id() == (*it)-&gt;id())
      <font color=#0000ff>return</font> (*it)-&gt;clone(info);
  }
  cerr &lt;&lt; <font color=#004488>"Prototype not found for "</font>
    &lt;&lt; info &lt;&lt; endl;
  <font color=#009900>// "Default" to first one in the vector:</font>
  <font color=#0000ff>return</font> (*prototypes.begin())-&gt;clone(info);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>string</B> inside the <B>Info
</B>object contains the type name of the <B>Trash </B>to be created; this
<B>string</B> is compared to the <B>id(&#160;)</B> values of the objects in
<B>prototypes</B>. If there&#8217;s a match, then that&#8217;s the object to
create.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I145">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I146"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, the appropriate prototype
object might not be in the <B>prototypes</B> list. In this case, the
<B>return</B> in the inner loop is never executed and you&#8217;ll drop out at
the end, where a default value is created. It might be more appropriate to throw
an exception here.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I146">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I147"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As you can see from the code,
there&#8217;s nothing that knows about specific types of <B>Trash</B>. The
beauty of this design is that this code doesn&#8217;t need to be changed,
regardless of the different situations it will be used
in.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I147">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I148"></a>
</FONT><BR></P></DIV>
<A NAME="Heading356"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Trash subclasses</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To fit into the prototyping scheme, each
new subclass of <B>Trash</B> must follow some rules. First, it must create a
<B>protected</B> default constructor, so that no one but <B>TrashProtoInit
</B>may use it. <B>TrashProtoInit </B>is a singleton, creating one and only one
prototype<B> </B>object for each subtype. This guarantees that the <B>Trash</B>
subtype will be properly represented in the <B>prototypes</B>
container.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I148">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I149"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">After defining the &#8220;ordinary&#8221;
member functions and data that the <B>Trash</B> object will actually use, the
class must also override the <B>id(&#160;)</B> member (which in this case
returns a <B>string</B> for comparison) and the <B>clone(&#160;)</B> function,
which must know how to pull the appropriate information out of the <B>Info</B>
object in order to create the object
correctly.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I149">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I150"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here are the different types of
<B>Trash</B>, each in their own
file.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I150">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I151"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:Aluminum.h</font>
<font color=#009900>// The Aluminum class with prototyping</font>
#ifndef ALUMINUM_H
#define ALUMINUM_H
#include <font color=#004488>"Trash.h"</font>

<font color=#0000ff>class</font> Aluminum : <font color=#0000ff>public</font> Trash {
  <font color=#0000ff>static</font> <font color=#0000ff>double</font> val;
<font color=#0000ff>protected</font>:
  Aluminum() {}
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> TrashProtoInit;
<font color=#0000ff>public</font>:
  Aluminum(<font color=#0000ff>double</font> wt) : Trash(wt) {}
  <font color=#0000ff>double</font> value() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> val; }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> value(<font color=#0000ff>double</font> newVal) {
    val = newVal;
  }
  std::string id() { <font color=#0000ff>return</font> <font color=#004488>"Aluminum"</font>; }
  Trash* clone(<font color=#0000ff>const</font> Info&amp; info) {
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> Aluminum(info.data());
  }
};
#endif <font color=#009900>// ALUMINUM_H ///:~</font></PRE></FONT></BLOCKQUOTE>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:Paper.h</font>
<font color=#009900>// The Paper class with prototyping</font>
#ifndef PAPER_H
#define PAPER_H
#include <font color=#004488>"Trash.h"</font>

<font color=#0000ff>class</font> Paper : <font color=#0000ff>public</font> Trash {
  <font color=#0000ff>static</font> <font color=#0000ff>double</font> val;
<font color=#0000ff>protected</font>:
  Paper() {}
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> TrashProtoInit;
<font color=#0000ff>public</font>:
  Paper(<font color=#0000ff>double</font> wt) : Trash(wt) {}
  <font color=#0000ff>double</font> value() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> val; }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> value(<font color=#0000ff>double</font> newVal) {
    val = newVal;
  }
  std::string id() { <font color=#0000ff>return</font> <font color=#004488>"Paper"</font>; }
  Trash* clone(<font color=#0000ff>const</font> Info&amp; info) {
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> Paper(info.data());
  }
};
#endif <font color=#009900>// PAPER_H ///:~</font></PRE></FONT></BLOCKQUOTE>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:Glass.h</font>
<font color=#009900>// The Glass class with prototyping</font>
#ifndef GLASS_H
#define GLASS_H
#include <font color=#004488>"Trash.h"</font>

<font color=#0000ff>class</font> Glass : <font color=#0000ff>public</font> Trash {
  <font color=#0000ff>static</font> <font color=#0000ff>double</font> val;
<font color=#0000ff>protected</font>:
  Glass() {}
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> TrashProtoInit;
<font color=#0000ff>public</font>:
  Glass(<font color=#0000ff>double</font> wt) : Trash(wt) {}
  <font color=#0000ff>double</font> value() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> val; }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> value(<font color=#0000ff>double</font> newVal) {
    val = newVal;
  }
  std::string id() { <font color=#0000ff>return</font> <font color=#004488>"Glass"</font>; }
  Trash* clone(<font color=#0000ff>const</font> Info&amp; info) {
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> Glass(info.data());
  }
};
#endif <font color=#009900>// GLASS_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">And here&#8217;s a new type of
<B>Trash</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I151">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I152"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:Cardboard.h</font>
<font color=#009900>// The Cardboard class with prototyping</font>
#ifndef CARDBOARD_H
#define CARDBOARD_H
#include <font color=#004488>"Trash.h"</font>

<font color=#0000ff>class</font> Cardboard : <font color=#0000ff>public</font> Trash {
  <font color=#0000ff>static</font> <font color=#0000ff>double</font> val;
<font color=#0000ff>protected</font>:
  Cardboard() {}
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> TrashProtoInit;
<font color=#0000ff>public</font>:
  Cardboard(<font color=#0000ff>double</font> wt) : Trash(wt) {}
  <font color=#0000ff>double</font> value() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> val; }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> value(<font color=#0000ff>double</font> newVal) {
    val = newVal;
  }
  std::string id() { <font color=#0000ff>return</font> <font color=#004488>"Cardboard"</font>; }
  Trash* clone(<font color=#0000ff>const</font> Info&amp; info) {
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> Cardboard(info.data());
  }
};
#endif <font color=#009900>// CARDBOARD_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The static <B>val</B> data members must
be defined and initialized in a separate code
file:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I152">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I153"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:TrashStat.cpp {O}</font>
<font color=#009900>// Contains the static definitions for </font>
<font color=#009900>// the Trash type's "val" data members</font>
#include <font color=#004488>"Trash.h"</font>
#include <font color=#004488>"Aluminum.h"</font>
#include <font color=#004488>"Paper.h"</font>
#include <font color=#004488>"Glass.h"</font>
#include <font color=#004488>"Cardboard.h"</font>

<font color=#0000ff>double</font> Aluminum::val = 1.67;
<font color=#0000ff>double</font> Paper::val = 0.10;
<font color=#0000ff>double</font> Glass::val = 0.23;
<font color=#0000ff>double</font> Cardboard::val = 0.14;
<font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s one other issue:
initialization of the static data members. <B>TrashProtoInit </B>must create the
prototype objects and add them to the <B>static Trash::prototypes </B>vector. So
it&#8217;s <I>very</I> important that you control the order of initialization of
the <B>static</B> objects, so the <B>prototypes</B> vector is created before any
of the prototype objects, which depend on the prior existence of
<B>prototypes</B>. The most straightforward way to do this is to put all the
definitions in a single file, in the order in which you want them
initialized.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I153">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I154"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>TrashProtoInit</B> must be defined
separately because it inserts the actual prototypes into the <B>vector</B>, and
throughout the chapter we&#8217;ll be inheriting new types of <B>Trash</B> from
the existing types. By making this one class in a separate file, a different
version can be created and linked in for the new situations, leaving the rest of
the code in the system
alone.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I154">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I155"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:TrashProtoInit.cpp {O}</font>
<font color=#009900>// Performs initialization of all the prototypes.</font>
<font color=#009900>// Create a different version of this file to</font>
<font color=#009900>// make different kinds of Trash.</font>
#include <font color=#004488>"Trash.h"</font>
#include <font color=#004488>"Aluminum.h"</font>
#include <font color=#004488>"Paper.h"</font>
#include <font color=#004488>"Glass.h"</font>
#include <font color=#004488>"Cardboard.h"</font>

<font color=#009900>// Allocate the static member object:</font>
std::vector&lt;Trash*&gt; Trash::prototypes;

<font color=#0000ff>class</font> TrashProtoInit {
  Aluminum a;
  Paper p;
  Glass g;
  Cardboard c;
  TrashProtoInit() {
    Trash::prototypes.push_back(&amp;a);
    Trash::prototypes.push_back(&amp;p);
    Trash::prototypes.push_back(&amp;g);
    Trash::prototypes.push_back(&amp;c);
  }
  <font color=#0000ff>static</font> TrashProtoInit singleton;
};

TrashProtoInit 
  TrashProtoInit::singleton; <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is taken a step further by making
<B>TrashProtoInit</B> a singleton (the constructor is <B>private</B>), even
though the class definition is not available in a header file so it would seem
safe enough to assume that no one could accidentally make a second
instance.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I155">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I156"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Unfortunately, this is one more separate
piece of code you must maintain whenever you add a new type to the system.
However, it&#8217;s not too bad since the linker should give you an error
message if you forget (since <B>prototypes </B>is defined in this file as well).
The really difficult problems come when you <I>don&#8217;t</I> get any warnings
or errors if you do something
wrong.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I156">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I157"></a>
</FONT><BR></P></DIV>
<A NAME="Heading357"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Parsing Trash from an external file</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The information about <B>Trash</B>
objects will be read from an outside file. The file has all of the necessary
information about each piece of trash in a single entry in the form
<B>Trash:weight</B>. There are multiple entries on a line, separated by
commas:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I157">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I158"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//:! C11:Trash.dat</font>
Glass:54, Paper:22, Paper:11, Glass:17,
Aluminum:89, Paper:88, Aluminum:76, Cardboard:96,
Aluminum:25, Aluminum:34, Glass:11, Glass:68,
Glass:43, Aluminum:27, Cardboard:44, Aluminum:18,
Paper:91, Glass:63, Glass:50, Glass:80,
Aluminum:81, Cardboard:12, Glass:12, Glass:54,
Aluminum:36, Aluminum:93, Glass:93, Paper:80,
Glass:36, Glass:12, Glass:60, Paper:66,
Aluminum:36, Cardboard:22,
<font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To parse this, the line is read and the
<A NAME="Index695"></A><B>string </B>member function
<A NAME="Index696"></A><B>find(&#160;)</B> produces the index of the
&#8216;<B>:</B>&#8217;. This is first used with the <B>string </B>member
function <A NAME="Index697"></A><A NAME="Index698"></A><B>substr(&#160;) </B>to
extract the name of the trash type, and next to get the weight that is turned
into a <B>double </B>with the <B>atof(&#160;) </B>function (from
<B>&lt;cstdlib&gt;</B>).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I158">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I159"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Trash </B>file parser is placed in
a separate file since it will be reused throughout this chapter. To facilitate
this reuse, the function <B>fillBin(&#160;)</B> which does the work takes as its
first argument the name of the file to open and read, and as its second argument
a reference to an object of type <B>Fillable</B>. This uses what I&#8217;ve
named the &#8220;interface&#8221; idiom at the beginning of the chapter, and the
only attribute for this particular interface is that &#8220;it can be
filled,&#8221; via a member function <B>addTrash(&#160;)</B>. Here&#8217;s the
header file for
<B>Fillable</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I159">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I160"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:Fillable.h</font>
<font color=#009900>// Any object that can be filled with Trash</font>
#ifndef FILLABLE_H
#define FILLABLE_H

<font color=#0000ff>class</font> Fillable {
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> addTrash(Trash* t) = 0;
};
#endif <font color=#009900>// FILLABLE_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Notice that it follows the interface
idiom of having no non-static data members, and all pure <B>virtual</B> member
functions.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I160">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I161"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This way, any class which implements this
interface (typically using multiple inheritance) can be filled using
<B>fillBin(&#160;)</B>. Here&#8217;s the header
file:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I161">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I162"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:fillBin.h</font>
<font color=#009900>// Open a file and parse its contents into</font>
<font color=#009900>// Trash objects, placing each into a vector</font>
#ifndef FILLBIN_H
#define FILLBIN_H
#include <font color=#004488>"Fillablevector.h"</font>
#include &lt;vector&gt;
#include &lt;string&gt;

<font color=#0000ff>void</font> 
fillBin(std::string filename, Fillable&amp; bin);

<font color=#009900>// Special case to handle vector:</font>
<font color=#0000ff>inline</font> <font color=#0000ff>void</font> fillBin(std::string filename, 
  std::vector&lt;Trash*&gt;&amp; bin) {
  Fillablevector fv(bin);
  fillBin(filename, fv);
}
#endif <font color=#009900>// FILLBIN_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The overloaded version will be discussed
shortly. First, here is the
implementation:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I162">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I163"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:fillBin.cpp {O}</font>
<font color=#009900>// Implementation of fillBin()</font>
#include <font color=#004488>"fillBin.h"</font>
#include <font color=#004488>"Fillable.h"</font><A NAME=<font color=#004488>"AAA"</font>></A>
#include <font color=#004488>"..</font><font color=#004488>/C04</font><font color=#004488>/trim.h"</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>void</font> fillBin(string filename, Fillable&amp; bin) {
  ifstream in(filename.c_str());
  assure(in, filename.c_str());
  string s;
  <font color=#0000ff>while</font>(getline(in, s)) {
    <font color=#0000ff>int</font> comma = s.find(',');
    <font color=#009900>// Parse each line into entries:</font>
    <font color=#0000ff>while</font>(comma != string::npos) {
      string e = trim(s.substr(0,comma));
      <font color=#009900>// Parse each entry:</font>
      <font color=#0000ff>int</font> colon = e.find(':');
      string type = e.substr(0, colon);
      <font color=#0000ff>double</font> weight = 
        atof(e.substr(colon + 1).c_str());
      bin.addTrash(
        Trash::factory(
          Trash::Info(type, weight)));
      <font color=#009900>// Move to next part of line:</font>
      s = s.substr(comma + 1);
      comma = s.find(',');
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">After the file is opened, each line is
read and parsed into entries by looking for the separating comma, then each
entry is parsed into its type and weight by looking for the separating colon.
Note the convenience of using the <B>trim(&#160;)</B> function from chapter 17
to remove the white space from both ends of a <B>string</B>. Once the type and
weight are discovered, an <B>Info </B>object is created from that data and
passed to the <B>factory(&#160;)</B>. The result of this call is a <B>Trash*</B>
which is passed to the<B> addTrash(&#160;)</B> function of the <B>bin</B> (which
is the only function, remember, that a <B>Fillable</B>
guarantees).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I163">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I164"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Anything that supports the
<B>Fillable</B> interface can be used with <B>fillBin(&#160;)</B>. Of course,
<B>vector</B> doesn&#8217;t implement <B>Fillable</B>, so it won&#8217;t work.
Since <B>vector</B> is used in most of the examples, it makes sense to add the
second overloaded <B>fillBin(&#160;)</B> function that takes a <B>vector</B>, as
seen previously in <B>fillBin.h</B>. But how to make a <B>vector&lt;Trash*&gt;
</B>adapt to the <B>Fillable </B>interface, which says it must have an
<B>addTrash(&#160;) </B>member function? The key is in the word
&#8220;adapt&#8221;; we use the adapter pattern to create a class that has a
<B>vector </B>and is also
<B>Fillable</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I164">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I165"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">By saying &#8220;is also
<B>Fillable</B>,&#8221; the hint is strong (is-a) to inherit from
<B>Fillable</B>. But what about the <B>vector&lt;Trash*&gt;</B>? Should this new
class inherit from that? We don&#8217;t actually want to be making a new kind of
<B>vector</B>, which would force everyone to only use our <B>vector</B> in this
situation. Instead, we want someone to be able to have their own <B>vector</B>
and say &#8220;please fill this.&#8221; So the new class should just keep a
reference to that
<B>vector</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I165">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I166"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:Fillablevector.h</font>
<font color=#009900>// Adapter that makes a vector&lt;Trash*&gt; Fillable</font>
#ifndef FILLABLEVECTOR_H
#define FILLABLEVECTOR_H
#include <font color=#004488>"Trash.h"</font>
#include <font color=#004488>"Fillable.h"</font>
#include &lt;vector&gt;

<font color=#0000ff>class</font> Fillablevector : <font color=#0000ff>public</font> Fillable {
  std::vector&lt;Trash*&gt;&amp; v;
<font color=#0000ff>public</font>:
  Fillablevector(std::vector&lt;Trash*&gt;&amp; vv) 
    : v(vv) {}
  <font color=#0000ff>void</font> addTrash(Trash* t) { v.push_back(t); }
};
#endif <font color=#009900>// FILLABLEVECTOR_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that the only job of this
class is to connect <B>Fillable</B>&#8217;s <B>addTrash(&#160;)</B> member
function to <B>vector</B>&#8217;s <B>push_back(&#160;)</B> (that&#8217;s the
&#8220;adapter&#8221; motivation). With this class in hand, the overloaded
<B>fillBin(&#160;)</B> member function can be used with a <B>vector</B> in
<B>fillBin.h</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I166">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I167"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>inline</font> <font color=#0000ff>void</font> fillBin(std::string filename, 
  std::vector&lt;Trash*&gt;&amp; bin) {
  Fillablevector fv(bin);
  fillBin(filename, fv);
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Notice that the adapter object <B>fv</B>
only exists for the duration of the function call, and it wraps <B>bin</B> in an
interface that works with the other <B>fillBin(&#160;)</B>
function.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I167">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I168"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This approach works for any container
class that&#8217;s used frequently. Alternatively, the container can multiply
inherit from <B>Fillable</B>. (You&#8217;ll see this later, in
<B>DynaTrash.cpp</B>.)
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I168">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I169"></a>
</FONT><BR></P></DIV>
<A NAME="Heading358"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Recycling with prototyping</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now you can see the new version of the
recycling solution using the
<A NAME="Index699"></A><A NAME="Index700"></A>prototyping
technique:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I169">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I170"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:Recycle3.cpp</font>
<font color=#009900>//{L} TrashProtoInit ../TestSuite/Test</font>
<font color=#009900>//{L} fillBin Trash TrashStat</font>
<font color=#009900>// Recycling with RTTI and Prototypes</font>
#include <font color=#004488>"Trash.h"</font>
#include <font color=#004488>"Aluminum.h"</font>
#include <font color=#004488>"Paper.h"</font>
#include <font color=#004488>"Glass.h"</font>
#include <font color=#004488>"fillBin.h"</font>
#include <font color=#004488>"sumValue.h"</font>
#include <font color=#004488>"..</font><font color=#004488>/purge.h"</font>
#include &lt;fstream&gt;
#include &lt;vector&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;
ofstream out(<font color=#004488>"Recycle3.out"</font>);

<font color=#0000ff>int</font> main() {
  vector&lt;Trash*&gt; bin;
  <font color=#009900>// Fill up the Trash bin:</font>
  fillBin(<font color=#004488>"Trash.dat"</font>, bin);
  vector&lt;Aluminum*&gt; alBin;
  vector&lt;Paper*&gt; paperBin;
  vector&lt;Glass*&gt; glassBin;
  vector&lt;Trash*&gt;::iterator it = bin.begin();
  <font color=#0000ff>while</font>(it != bin.end()) {
    <font color=#009900>// Sort the Trash:</font>
    Aluminum* ap = 
      <font color=#0000ff>dynamic_cast</font>&lt;Aluminum*&gt;(*it);
    Paper* pp = <font color=#0000ff>dynamic_cast</font>&lt;Paper*&gt;(*it);
    Glass* gp = <font color=#0000ff>dynamic_cast</font>&lt;Glass*&gt;(*it);
    <font color=#0000ff>if</font>(ap) alBin.push_back(ap);
    <font color=#0000ff>if</font>(pp) paperBin.push_back(pp);
    <font color=#0000ff>if</font>(gp) glassBin.push_back(gp);
    it++;
  }
  sumValue(alBin);
  sumValue(paperBin);
  sumValue(glassBin);
  sumValue(bin);
  purge(bin);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The process of opening the data file
containing <B>Trash</B> descriptions and the parsing of that file have been
wrapped into <B>fillBin(&#160;)</B>, so now it&#8217;s no longer a part of our
design focus. You will see that throughout the rest of the chapter, no matter
what new classes are added, <B>fillBin(&#160;)</B> will continue to work without
change, which indicates a good
design.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I170">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I171"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In terms of object creation, this design
does indeed severely localize the changes you need to make to add a new type to
the system. However, there&#8217;s a significant problem in the use of RTTI that
shows up clearly here. The program seems to run fine, and yet it never detects
any cardboard, even though there is cardboard in the list of trash data! This
happens <I>because</I> of the use of RTTI, which looks for only the types that
you tell it to look for. The clue that <A NAME="Index701"></A>RTTI is being
misused is that <I>every type in the system </I>is being tested, rather than a
single type or subset of types. But if you forget to test for your new type, the
compiler has nothing to say about it.

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I171">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I172"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As you will see later, there are ways to
use polymorphism instead when you&#8217;re testing for every type. But if you
use RTTI a lot in this fashion, and you add a new type to your system, you can
easily forget to make the necessary changes in your program and produce a
difficult-to-find bug. So it&#8217;s worth trying to eliminate RTTI in this
case, not just for aesthetic reasons &#8211; it produces more maintainable
code.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I172">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I173"></a>
</FONT><A NAME="_Toc375545416"></A><A NAME="_Toc408018802"></A><A NAME="_Toc519042142"></A><BR></P></DIV>
<A NAME="Heading359"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Abstracting usage</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">With creation out of the way, it&#8217;s
time to tackle the remainder of the design: where the classes are used. Since
it&#8217;s the act of sorting into bins that&#8217;s particularly ugly and
exposed, why not take that process and hide it inside a class? This is simple
&#8220;complexity hiding,&#8221; the principle of &#8220;If you must do
something ugly, at least localize the ugliness.&#8221; In an OOP language, the
best place to hide complexity is inside a class. Here&#8217;s a first
cut:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I173">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I174"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><IMG SRC="TicV206.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>TrashSorter</B> object holds a
<B>vector </B>that somehow connects to <B>vector</B>s holding specific types of
<B>Trash</B>. The most convenient solution would be a
<B>vector&lt;vector&lt;Trash*&gt;&gt;</B>, but it&#8217;s too early to tell if
that would work out best.<B>
</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I174">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I175"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In addition, we&#8217;d like to have a
<B>sort(&#160;) </B>function as part of the <B>TrashSorter </B>class. But,
keeping in mind that the goal is easy addition of new types of <B>Trash</B>, how
would the statically-coded <B>sort(&#160;) </B>function deal with the fact that
a new type has been added? To solve this, the type information must be removed
from <B>sort(&#160;)</B> so all it needs to do is call a generic function which
takes care of the details of type. This, of course, is another way to describe a
<B>virtual</B> function. So <B>sort(&#160;)</B> will simply move through the
<B>vector</B> of <B>Trash</B> bins and call a virtual function for each.
I&#8217;ll call the function <B>grab(Trash*)</B>, so the structure now looks
like this:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I175">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I176"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><IMG SRC="TicV207.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">However, <B>TrashSorter</B> needs to call
<B>grab(&#160;)</B> polymorphically, through a common base class for all the
<B>vector</B>s. This base class is very simple, since it only needs to establish
the interface for the <B>grab(&#160;)</B>
function.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I176">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I177"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now there&#8217;s a choice. Following the
above diagram, you could put a <B>vector </B>of <B>trash </B>pointers as a
member object of each subclassed <B>Tbin</B>. However, you will want to treat
each <B>Tbin</B> as a <B>vector</B>, and perform all the <B>vector</B>
operations on it. You could create a new interface and forward all those
operations, but that produces work and potential bugs. The type we&#8217;re
creating is really a <B>Tbin</B> <I>and</I> a <B>vector</B>, which suggests
multiple inheritance. However, it turns out that&#8217;s not quite necessary,
for the following
reason.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I177">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I178"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each time a new type is added to the
system the programmer will have to go in and derive a new class for the
<B>vector </B>that holds the new type of <B>Trash</B>, along with its
<B>grab(&#160;)</B> function. The code the programmer writes will actually be
<I>identical code except for the type it&#8217;s working with</I>. That last
phrase is the key to introduce a template, which will do all the work of adding
a new type. Now the diagram looks more complicated, although the process of
adding a new type to the system will be simple. Here, <B>TrashBin</B> can
inherit from <B>TBin</B>, which inherits from <B>vector&lt;Trash*&gt;</B> like
this (the multiple-lined arrows indicated template
instantiation):
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I178">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I179"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><IMG SRC="TicV208.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The reason <B>TrashBin</B> must be a
template is so it can automatically generate the <B>grab(&#160;)</B> function. A
further templatization will allow the <B>vector</B>s to hold specific
types.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I179">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I180"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">That said, we can look at the whole
program to see how all this is implemented.

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I180">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I181"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:Recycle4.cpp</font>
<font color=#009900>//{L} TrashProtoInit ../TestSuite/Test</font>
<font color=#009900>//{L} fillBin Trash TrashStat</font>
<font color=#009900>// Adding TrashBins and TrashSorters</font>
#include <font color=#004488>"Trash.h"</font>
#include <font color=#004488>"Aluminum.h"</font>
#include <font color=#004488>"Paper.h"</font>
#include <font color=#004488>"Glass.h"</font>
#include <font color=#004488>"Cardboard.h"</font>
#include <font color=#004488>"fillBin.h"</font>
#include <font color=#004488>"sumValue.h"</font>
#include <font color=#004488>"..</font><font color=#004488>/purge.h"</font>
#include &lt;fstream&gt;
#include &lt;vector&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;
ofstream out(<font color=#004488>"Recycle4.out"</font>);

<font color=#0000ff>class</font> TBin : <font color=#0000ff>public</font> vector&lt;Trash*&gt; {
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> <font color=#0000ff>bool</font> grab(Trash*) = 0;
};

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> TrashType&gt;
<font color=#0000ff>class</font> TrashBin : <font color=#0000ff>public</font> TBin {
<font color=#0000ff>public</font>:
  <font color=#0000ff>bool</font> grab(Trash* t) {
    TrashType* tp = <font color=#0000ff>dynamic_cast</font>&lt;TrashType*&gt;(t);
    <font color=#0000ff>if</font>(!tp) <font color=#0000ff>return</font> <font color=#0000ff>false</font>; <font color=#009900>// Not grabbed</font>
    push_back(tp);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>; <font color=#009900>// Object grabbed</font>
  }
};

<font color=#0000ff>class</font> TrashSorter : <font color=#0000ff>public</font> vector&lt;TBin*&gt; {
<font color=#0000ff>public</font>:
  <font color=#0000ff>bool</font> sort(Trash* t) {
    <font color=#0000ff>for</font>(iterator it = begin(); it != end(); it++)
      <font color=#0000ff>if</font>((*it)-&gt;grab(t))
        <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
    <font color=#0000ff>return</font> <font color=#0000ff>false</font>;
  }
  <font color=#0000ff>void</font> sortBin(vector&lt;Trash*&gt;&amp; bin) {
    vector&lt;Trash*&gt;::iterator it;
    <font color=#0000ff>for</font>(it = bin.begin(); it != bin.end(); it++)
      <font color=#0000ff>if</font>(!sort(*it))
        cerr &lt;&lt; <font color=#004488>"bin not found"</font> &lt;&lt; endl;
  }
  ~TrashSorter() { purge(*<font color=#0000ff>this</font>); }
};

<font color=#0000ff>int</font> main() {
  vector&lt;Trash*&gt; bin;
  <font color=#009900>// Fill up the Trash bin:</font>
  fillBin(<font color=#004488>"Trash.dat"</font>, bin);
  TrashSorter tbins;
  tbins.push_back(<font color=#0000ff>new</font> TrashBin&lt;Aluminum&gt;);
  tbins.push_back(<font color=#0000ff>new</font> TrashBin&lt;Paper&gt;);
  tbins.push_back(<font color=#0000ff>new</font> TrashBin&lt;Glass&gt;);
  tbins.push_back(<font color=#0000ff>new</font> TrashBin&lt;Cardboard&gt;);
  tbins.sortBin(bin);
  <font color=#0000ff>for</font>(TrashSorter::iterator it = tbins.begin(); 
    it != tbins.end(); it++)
    sumValue(**it);
  sumValue(bin);
  purge(bin);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>TrashSorter</B> needs to call each
<B>grab(&#160;)</B> member function and get a different result depending on what
type of <B>Trash</B> the current <B>vector</B> is holding. That is, each
<B>vector</B> must be aware of the type it holds. This &#8220;awareness&#8221;
is accomplished with a <B>virtual </B>function, the <B>grab(&#160;)</B>
function, which thus eliminates at least the outward appearance of the use of
RTTI. The implementation of <B>grab(&#160;) </B><I>does</I> use RTTI, but
it&#8217;s templatized so as long as you put a new <B>TrashBin</B> in the
<B>TrashSorter</B> when you add a type, everything else is taken care
of.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I181">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I182"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Memory is managed by denoting <B>bin</B>
as the &#8220;master container,&#8221; the one responsible for cleanup. With
this rule in place, calling <B>purge(&#160;)</B> for <B>bin</B> cleans up all
the <B>Trash</B> objects. In addition, <B>TrashSorter</B> assumes that it
&#8220;owns&#8221; the pointers it holds, and cleans up all the <B>TrashBin</B>
objects during
destruction.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I182">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I183"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A basic OOP design principle is
&#8220;Use data members for variation in state, use
<A NAME="Index702"></A>polymorphism for variation in behavior.&#8221; Your first
thought might be that the <B>grab(&#160;)</B> member function certainly behaves
differently for a <B>vector</B> that holds <B>Paper</B> than for one that holds
<B>Glass</B>. But what it does is strictly dependent on the type, and nothing
else.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I183">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I184"></a>
</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">TbinList holds a set of
Tbin pointers, so that sort(&#160;) can iterate through the Tbins when
it&#8217;s looking for a match for the Trash object you&#8217;ve handed
it.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">sortBin(&#160;)
allows you to pass an entire Tbin in, and it moves through the Tbin, picks out
each piece of Trash, and sorts it into the appropriate specific Tbin. Notice the
genericity of this code: it doesn&#8217;t change at all if new types are added.
If the bulk of your code doesn&#8217;t need changing when a new type is added
(or some other change occurs) then you have an easily-extensible
system.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Now you can
see how easy it is to add a new type. Few lines must be changed to support the
addition. If it&#8217;s really important, you can squeeze out even more by
further manipulating the
design.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">One member
function call causes the contents of bin to be sorted into the respective
specifically-typed
bins.</FONT><A NAME="_Toc375545417"></A><A NAME="_Toc408018803"></A><A NAME="_Toc519042143"></A></OL><A NAME="Heading360"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Applying double dispatching</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The above design is certainly
satisfactory. Adding new types to the system consists of adding or modifying
distinct classes without causing code changes to be propagated throughout the
system. In addition, RTTI is not as &#8220;misused&#8221; as it was in
<B>Recycle1.cpp</B>. However, it&#8217;s possible to go one step further and
eliminate RTTI altogether from the operation of sorting the trash into
bins.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I184">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I185"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To accomplish this, you must first take
the perspective that all type-dependent activities &#8211; such as detecting the
type of a piece of trash and putting it into the appropriate bin &#8211; should
be controlled through polymorphism and dynamic
binding.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I185">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I186"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The previous examples first sorted by
type, then acted on sequences of elements that were all of a particular type.
But whenever you find yourself picking out particular types, stop and think. The
whole idea of polymorphism (dynamically-bound member function calls) is to
handle type-specific information for you. So why are you hunting for
types?
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I186">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I187"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The multiple-dispatch pattern
demonstrated at the beginning of this chapter uses <B>virtual</B> functions to
determine all type information, thus eliminating
RTTI.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I187">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I188"></a>
</FONT><A NAME="_Toc408018804"></A><A NAME="_Toc519042144"></A><BR></P></DIV>
<A NAME="Heading361"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Implementing the double dispatch</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the <B>Trash</B> hierarchy we will now
make use of the &#8220;stub&#8221; virtual function <B>addToBin(&#160;)</B> that
was added to the base class <B>Trash</B> but unused up until now. This takes an
argument of a container of <B>TypedBin</B>. A <B>Trash </B>object uses
<B>addToBin(&#160;) </B>with this container to step through and try to add
itself to the appropriate bin, and this is where you&#8217;ll see the double
dispatch.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I188">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I189"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The new hierarchy is <B>TypedBin</B>, and
it contains its own member function called <B>add(&#160;)</B> that is also used
polymorphically. But here&#8217;s an additional twist: <B>add(&#160;)</B> is
<I>overloaded</I> to take arguments of the different types of <B>Trash</B>. So
an essential part of the double dispatching scheme also involves overloading (or
at least having a group of virtual functions to call; overloading happens to be
particularly convenient
here).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I189">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I190"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:TypedBin.h</font>
#ifndef TYPEDBIN_H
#define TYPEDBIN_H
#include <font color=#004488>"Trash.h"</font>
#include <font color=#004488>"Aluminum.h"</font>
#include <font color=#004488>"Paper.h"</font>
#include <font color=#004488>"Glass.h"</font>
#include <font color=#004488>"Cardboard.h"</font>
#include &lt;vector&gt;

<font color=#009900>// Template to generate double-dispatching</font>
<font color=#009900>// trash types by inheriting from originals:</font>
<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> TrashType&gt; 
<font color=#0000ff>class</font> DD : <font color=#0000ff>public</font> TrashType {
<font color=#0000ff>protected</font>:
  DD() : TrashType(0) {}
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> TrashProtoInit;
<font color=#0000ff>public</font>:
  DD(<font color=#0000ff>double</font> wt) : TrashType(wt) {}
  <font color=#0000ff>bool</font> addToBin(std::vector&lt;TypedBin*&gt;&amp; tb) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; tb.size(); i++)
      <font color=#0000ff>if</font>(tb[i]-&gt;add(<font color=#0000ff>this</font>))
        <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
    <font color=#0000ff>return</font> <font color=#0000ff>false</font>;
  }
  <font color=#009900>// Override clone() to create this new type:</font>
  Trash* clone(<font color=#0000ff>const</font> Trash::Info&amp; info) {
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> DD(info.data());
  }
};

<font color=#009900>// vector&lt;Trash*&gt; that knows how to </font>
<font color=#009900>// grab the right type</font>
<font color=#0000ff>class</font> TypedBin : <font color=#0000ff>public</font> std::vector&lt;Trash*&gt; {
<font color=#0000ff>protected</font>:
  <font color=#0000ff>bool</font> addIt(Trash* t) {
    push_back(t);
    <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
  }
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> <font color=#0000ff>bool</font> add(DD&lt;Aluminum&gt;*) {
    <font color=#0000ff>return</font> <font color=#0000ff>false</font>;
  }
  <font color=#0000ff>virtual</font> <font color=#0000ff>bool</font> add(DD&lt;Paper&gt;*) {
    <font color=#0000ff>return</font> <font color=#0000ff>false</font>;
  }
  <font color=#0000ff>virtual</font> <font color=#0000ff>bool</font> add(DD&lt;Glass&gt;*) {
    <font color=#0000ff>return</font> <font color=#0000ff>false</font>;
  }
  <font color=#0000ff>virtual</font> <font color=#0000ff>bool</font> add(DD&lt;Cardboard&gt;*) {
    <font color=#0000ff>return</font> <font color=#0000ff>false</font>;
  }
};

<font color=#009900>// Template to generate specific TypedBins:</font>
<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> TrashType&gt;
<font color=#0000ff>class</font> BinOf : <font color=#0000ff>public</font> TypedBin {
<font color=#0000ff>public</font>:
  <font color=#009900>// Only overrides add() for this specific type:</font>
  <font color=#0000ff>bool</font> add(TrashType* t) { <font color=#0000ff>return</font> addIt(t); }
};
#endif <font color=#009900>// TYPEDBIN_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In each particular subtype of
<B>Aluminum</B>, <B>Paper</B>, <B>Glass,</B> and <B>Cardboard</B>, the
<B>addToBin(&#160;)</B> member function is implemented, but it <I>looks</I> like
the code is exactly the same in each case. The code in each <B>addToBin(&#160;)
</B>calls <B>add(&#160;)</B> for each <B>TypedBin</B> object in the array. But
notice the argument: <B>this</B>. The type of <B>this</B> is different for each
subclass of <B>Trash</B>, so the code is different. So this is the first part of
the double dispatch, because once you&#8217;re inside this member function you
know you&#8217;re <B>Aluminum</B>, or <B>Paper</B>, etc. During the call to
<B>add(&#160;)</B>, this information is passed via the type of <B>this</B>. The
compiler resolves the call to the proper overloaded version of
<B>add(&#160;)</B>. But<B> </B>since <B>tb[i]</B> produces a pointer to the base
type <B>TypedBin</B>,<B> </B>this call will end up calling a different member
function depending on the type of <B>TypedBin</B> that&#8217;s currently
selected. That is the second
dispatch.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I190">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I191"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that the overloaded
<B>add(&#160;)</B> methods all return <B>false</B>. If the member function is
not overloaded in a derived class, it will continue to return <B>false</B>, and
the caller (<B>addToBin(&#160;)</B>, in this case) will assume that the current
<B>Trash</B> object has not been added successfully to a container, and continue
searching for the right
container.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I191">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I192"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In each of the subclasses of
<B>TypedBin</B>, only one overloaded member function is overridden, according to
the type of bin that&#8217;s being created. For example, <B>CardboardBin</B>
overrides <B>add(DD&lt;Cardboard&gt;)</B>. The overridden member function adds
the <B>Trash</B> pointer to its container and returns <B>true</B>, while all the
rest of the <B>add(&#160;) </B>methods in <B>CardboardBin </B>continue to return
<B>false</B>, since they haven&#8217;t been overridden. With
<A NAME="Index703"></A><A NAME="Index704"></A>C++ <B>template</B>s, you
don&#8217;t have to explicitly write the subclasses or place the
<B>addToBin(&#160;)</B> member function in <B>Trash</B>.

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I192">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I193"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To set up for prototyping the new types
of trash, there must be a different initializer
file:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I193">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I194"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:DDTrashProtoInit.cpp {O}</font>
#include <font color=#004488>"TypedBin.h"</font>
#include <font color=#004488>"Aluminum.h"</font>
#include <font color=#004488>"Paper.h"</font>
#include <font color=#004488>"Glass.h"</font>
#include <font color=#004488>"Cardboard.h"</font>

std::vector&lt;Trash*&gt; Trash::prototypes;

<font color=#0000ff>class</font> TrashProtoInit {
  DD&lt;Aluminum&gt; a;
  DD&lt;Paper&gt; p;
  DD&lt;Glass&gt; g;
  DD&lt;Cardboard&gt; c;
  TrashProtoInit() {
    Trash::prototypes.push_back(&amp;a);
    Trash::prototypes.push_back(&amp;p);
    Trash::prototypes.push_back(&amp;g);
    Trash::prototypes.push_back(&amp;c);
  }
  <font color=#0000ff>static</font> TrashProtoInit singleton;
};

TrashProtoInit 
  TrashProtoInit::singleton; <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s the rest of the
program:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I194">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I195"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:DoubleDispatch.cpp</font>
<font color=#009900>//{L} DDTrashProtoInit ../TestSuite/Test</font>
<font color=#009900>//{L} fillBin Trash TrashStat</font>
<font color=#009900>//{-msc}</font>
<font color=#009900>// Using multiple dispatching to handle more than</font>
<font color=#009900>// one unknown type during a member function call</font>
#include <font color=#004488>"TypedBin.h"</font>
#include <font color=#004488>"fillBin.h"</font>
#include <font color=#004488>"sumValue.h"</font>
#include <font color=#004488>"..</font><font color=#004488>/purge.h"</font>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;
ofstream out(<font color=#004488>"DoubleDispatch.out"</font>);

<font color=#0000ff>class</font> TrashBinSet : <font color=#0000ff>public</font> vector&lt;TypedBin*&gt; {
<font color=#0000ff>public</font>:
  TrashBinSet() {
    push_back(<font color=#0000ff>new</font> BinOf&lt;DD&lt;Aluminum&gt; &gt;);
    push_back(<font color=#0000ff>new</font> BinOf&lt;DD&lt;Paper&gt; &gt;);
    push_back(<font color=#0000ff>new</font> BinOf&lt;DD&lt;Glass&gt; &gt;);
    push_back(<font color=#0000ff>new</font> BinOf&lt;DD&lt;Cardboard&gt; &gt;);
  };
  <font color=#0000ff>void</font> sortIntoBins(vector&lt;Trash*&gt;&amp; bin) {
    vector&lt;Trash*&gt;::iterator it;
    <font color=#0000ff>for</font>(it = bin.begin(); it != bin.end(); it++)
      <font color=#009900>// Perform the double dispatch:</font>
      <font color=#0000ff>if</font>(!(*it)-&gt;addToBin(*<font color=#0000ff>this</font>))
        cerr &lt;&lt; <font color=#004488>"Couldn't add "</font> &lt;&lt; *it &lt;&lt; endl;
  }
  ~TrashBinSet() { purge(*<font color=#0000ff>this</font>); }
};

<font color=#0000ff>int</font> main() {
  vector&lt;Trash*&gt; bin;
  TrashBinSet bins;
  <font color=#009900>// fillBin() still works, without changes, but</font>
  <font color=#009900>// different objects are cloned:</font>
  fillBin(<font color=#004488>"Trash.dat"</font>, bin);
  <font color=#009900>// Sort from the master bin into the</font>
  <font color=#009900>// individually-typed bins:</font>
  bins.sortIntoBins(bin);
  TrashBinSet::iterator it;
  <font color=#0000ff>for</font>(it = bins.begin(); it != bins.end(); it++)
    sumValue(**it);
  <font color=#009900>// ... and for the master bin</font>
  sumValue(bin);
  purge(bin);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>TrashBinSet</B> encapsulates all of
the different types of <B>TypedBin</B>s, along with the
<B>sortIntoBins(&#160;)</B> member function, which is where all the double
dispatching takes place. You can see that once the structure is set up, sorting
into the various <B>TypedBin</B>s is remarkably easy. In addition, the
efficiency of two virtual calls and the double dispatch is probably better than
any other way you could
sort.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I195">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I196"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Notice the ease of use of this system in
<B>main(&#160;)</B>, as well as the complete independence of any specific type
information within <B>main(&#160;)</B>. All other methods that talk only to the
<B>Trash</B> base-class interface will be equally invulnerable to changes in
<B>Trash</B> types.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I196">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I197"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The changes necessary to add a new type
are relatively isolated: you inherit the new type of <B>Trash</B> with its
<B>addToBin(&#160;)</B> member function, then make a small modification to
<B>TypedBin</B>, and finally you add a new type into the vector in
<B>TrashBinSet</B> and modify
<B>DDTrashProtoInit.cpp</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I197">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I198"></a>
</FONT><A NAME="_Toc408018805"></A><A NAME="_Toc519042145"></A><BR></P></DIV>
<A NAME="Heading362"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Applying the visitor pattern</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now consider applying a design pattern
with an entirely different goal to the trash-sorting problem. As demonstrated
earlier in this chapter, the visitor pattern&#8217;s goal is to allow the
addition of new polymorphic operations to a frozen inheritance
hierarchy.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I198">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I199"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For this pattern, we are no longer
concerned with optimizing the addition of new types of <B>Trash </B>to the
system. Indeed, this pattern makes adding a new type of <B>Trash </B><I>more</I>
complicated. It looks like this:
<IMG SRC="TicV209.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now, if <B>t</B> is a <B>Trash
</B>pointer to an <B>Aluminum</B> object, the
code:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I199">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I200"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>PriceVisitor pv;
t-&gt;accept(pv);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">causes two polymorphic member function
calls: the first one to select <B>Aluminum</B>&#8217;s version of
<B>accept(&#160;)</B>, and the second one within <B>accept(&#160;)</B> when the
specific version of <B>visit(&#160;)</B> is called dynamically using the
base-class <B>Visitor</B> pointer
<B>v</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I200">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I201"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This configuration means that new
functionality can be added to the system in the form of new subclasses of
<B>Visitor</B>. The <B>Trash </B>hierarchy doesn&#8217;t need to be touched.
This is the prime benefit of the visitor pattern: you can add new polymorphic
functionality to a class hierarchy without touching that hierarchy (once the
<B>accept(&#160;)</B> methods have been installed). Note that the benefit is
helpful here but not exactly what we started out to accomplish, so at first
blush you might decide that this isn&#8217;t the desired
solution.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I201">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I202"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">But look at one thing that&#8217;s been
accomplished: the visitor solution avoids sorting from the master <B>Trash</B>
sequence into individual typed sequences. Thus, you can leave everything in the
single master sequence and simply pass through that sequence using the
appropriate visitor to accomplish the goal. Although this behavior seems to be a
side effect of visitor, it does give us what we want (avoiding
RTTI).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I202">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I203"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index705"></A><A NAME="Index706"></A>double dispatching in the visitor
pattern takes care of determining both the type of <B>Trash </B>and the type of
<B>Visitor</B>.<B> </B>In the following example, there are two implementations
of <B>Visitor</B>: <B>PriceVisitor</B> to both determine and sum the price, and
<B>WeightVisitor</B> to keep track of the
weights.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I203">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I204"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see all of this implemented in
the new, improved version of the recycling program. As with
<B>DoubleDispatch.cpp</B>, the <B>Trash</B> class has had an extra member
function stub (<B>accept(&#160;)</B>)<B> </B>inserted in it to allow for this
example.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I204">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I205"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since there&#8217;s nothing concrete in
the <B>Visitor</B> base class, it can be created as an
<B>interface</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I205">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I206"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:Visitor.h</font>
<font color=#009900>// The base interface for visitors</font>
<font color=#009900>// and template for visitable Trash types</font>
#ifndef VISITOR_H
#define VISITOR_H
#include <font color=#004488>"Trash.h"</font>
#include <font color=#004488>"Aluminum.h"</font>
#include <font color=#004488>"Paper.h"</font>
#include <font color=#004488>"Glass.h"</font>
#include <font color=#004488>"Cardboard.h"</font>

<font color=#0000ff>class</font> Visitor {
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> visit(Aluminum* a) = 0;
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> visit(Paper* p) = 0;
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> visit(Glass* g) = 0;
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> visit(Cardboard* c) = 0;
};

<font color=#009900>// Template to generate visitable </font>
<font color=#009900>// trash types by inheriting from originals:</font>
<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> TrashType&gt; 
<font color=#0000ff>class</font> Visitable : <font color=#0000ff>public</font> TrashType {
<font color=#0000ff>protected</font>:
  Visitable () : TrashType(0) {}
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> TrashProtoInit;
<font color=#0000ff>public</font>:
  Visitable(<font color=#0000ff>double</font> wt) : TrashType(wt) {}
  <font color=#009900>// Remember "this" is pointer to current type:</font>
  <font color=#0000ff>void</font> accept(Visitor&amp; v) { v.visit(<font color=#0000ff>this</font>); }
  <font color=#009900>// Override clone() to create this new type:</font>
  Trash* clone(<font color=#0000ff>const</font> Trash::Info&amp; info) {
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> Visitable(info.data());
  }
};
#endif <font color=#009900>// VISITOR_H ///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As before, a different version of the
initialization file is
necessary:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I206">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I207"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:VisitorTrashPInit.cpp {O}</font>
#include <font color=#004488>"Visitor.h"</font>

std::vector&lt;Trash*&gt; Trash::prototypes;

<font color=#0000ff>class</font> TrashProtoInit {
  Visitable&lt;Aluminum&gt; a;
  Visitable&lt;Paper&gt; p;
  Visitable&lt;Glass&gt; g;
  Visitable&lt;Cardboard&gt; c;
  TrashProtoInit() {
    Trash::prototypes.push_back(&amp;a);
    Trash::prototypes.push_back(&amp;p);
    Trash::prototypes.push_back(&amp;g);
    Trash::prototypes.push_back(&amp;c);
  }
  <font color=#0000ff>static</font> TrashProtoInit singleton;
};

TrashProtoInit 
  TrashProtoInit::singleton; <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The rest of the program creates specific
<B>Visitor</B> types and sends them through a single list of <B>Trash</B>
objects:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I207">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I208"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:TrashVisitor.cpp</font>
<font color=#009900>//{L} VisitorTrashPInit ../TestSuite/Test</font>
<font color=#009900>//{L} fillBin Trash TrashStat </font>
<font color=#009900>//{-msc}</font>
<font color=#009900>// The "visitor" pattern</font>
#include <font color=#004488>"Visitor.h"</font>
#include <font color=#004488>"fillBin.h"</font>
#include <font color=#004488>"..</font><font color=#004488>/purge.h"</font>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;
ofstream out(<font color=#004488>"TrashVisitor.out"</font>);

<font color=#009900>// Specific group of algorithms packaged</font>
<font color=#009900>// in each implementation of Visitor:</font>
<font color=#0000ff>class</font> PriceVisitor : <font color=#0000ff>public</font> Visitor {
  <font color=#0000ff>double</font> alSum; <font color=#009900>// Aluminum</font>
  <font color=#0000ff>double</font> pSum; <font color=#009900>// Paper</font>
  <font color=#0000ff>double</font> gSum; <font color=#009900>// Glass</font>
  <font color=#0000ff>double</font> cSum; <font color=#009900>// Cardboard</font>
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> visit(Aluminum* al) {
    <font color=#0000ff>double</font> v = al-&gt;weight() * al-&gt;value();
    out &lt;&lt; <font color=#004488>"value of Aluminum= "</font> &lt;&lt; v &lt;&lt; endl;
    alSum += v;
  }
  <font color=#0000ff>void</font> visit(Paper* p) {
    <font color=#0000ff>double</font> v = p-&gt;weight() * p-&gt;value();
    out &lt;&lt; 
      <font color=#004488>"value of Paper= "</font> &lt;&lt; v &lt;&lt; endl;
    pSum += v;
  }
  <font color=#0000ff>void</font> visit(Glass* g) {
    <font color=#0000ff>double</font> v = g-&gt;weight() * g-&gt;value();
    out &lt;&lt; 
      <font color=#004488>"value of Glass= "</font> &lt;&lt; v &lt;&lt; endl;
    gSum += v;
  }
  <font color=#0000ff>void</font> visit(Cardboard* c) {
    <font color=#0000ff>double</font> v = c-&gt;weight() * c-&gt;value();
    out &lt;&lt; 
      <font color=#004488>"value of Cardboard = "</font> &lt;&lt; v &lt;&lt; endl;
    cSum += v;
  }
  <font color=#0000ff>void</font> total(ostream&amp; os) {
    os &lt;&lt;
      <font color=#004488>"Total Aluminum: $"</font> &lt;&lt; alSum &lt;&lt; <font color=#004488>"\n"</font> &lt;&lt;
      <font color=#004488>"Total Paper: $"</font> &lt;&lt; pSum &lt;&lt; <font color=#004488>"\n"</font> &lt;&lt;
      <font color=#004488>"Total Glass: $"</font> &lt;&lt; gSum &lt;&lt; <font color=#004488>"\n"</font> &lt;&lt;
      <font color=#004488>"Total Cardboard: $"</font> &lt;&lt; cSum &lt;&lt; endl;
  }
};

<font color=#0000ff>class</font> WeightVisitor : <font color=#0000ff>public</font> Visitor {
  <font color=#0000ff>double</font> alSum; <font color=#009900>// Aluminum</font>
  <font color=#0000ff>double</font> pSum; <font color=#009900>// Paper</font>
  <font color=#0000ff>double</font> gSum; <font color=#009900>// Glass</font>
  <font color=#0000ff>double</font> cSum; <font color=#009900>// Cardboard</font>
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> visit(Aluminum* al) {
    alSum += al-&gt;weight();
    out &lt;&lt; <font color=#004488>"weight of Aluminum = "</font>
        &lt;&lt; al-&gt;weight() &lt;&lt; endl;
  }
  <font color=#0000ff>void</font> visit(Paper* p) {
    pSum += p-&gt;weight();
    out &lt;&lt; <font color=#004488>"weight of Paper = "</font> 
      &lt;&lt; p-&gt;weight() &lt;&lt; endl;
  }
  <font color=#0000ff>void</font> visit(Glass* g) {
    gSum += g-&gt;weight();
    out &lt;&lt; <font color=#004488>"weight of Glass = "</font>
        &lt;&lt; g-&gt;weight() &lt;&lt; endl;
  }
  <font color=#0000ff>void</font> visit(Cardboard* c) {
    cSum += c-&gt;weight();
    out &lt;&lt; <font color=#004488>"weight of Cardboard = "</font>
        &lt;&lt; c-&gt;weight() &lt;&lt; endl;
  }
  <font color=#0000ff>void</font> total(ostream&amp; os) {
    os &lt;&lt; <font color=#004488>"Total weight Aluminum:"</font>
       &lt;&lt; alSum &lt;&lt; endl;
    os &lt;&lt; <font color=#004488>"Total weight Paper:"</font>
       &lt;&lt; pSum &lt;&lt; endl;
    os &lt;&lt; <font color=#004488>"Total weight Glass:"</font>
       &lt;&lt; gSum &lt;&lt; endl;
    os &lt;&lt; <font color=#004488>"Total weight Cardboard:"</font> 
       &lt;&lt; cSum &lt;&lt; endl;
  }
};

<font color=#0000ff>int</font> main() {
  vector&lt;Trash*&gt; bin;
  <font color=#009900>// fillBin() still works, without changes, but</font>
  <font color=#009900>// different objects are prototyped:</font>
  fillBin(<font color=#004488>"Trash.dat"</font>, bin);
  <font color=#009900>// You could even iterate through</font>
  <font color=#009900>// a list of visitors!</font>
  PriceVisitor pv;
  WeightVisitor wv;
  vector&lt;Trash*&gt;::iterator it = bin.begin();
  <font color=#0000ff>while</font>(it != bin.end()) {
    (*it)-&gt;accept(pv);
    (*it)-&gt;accept(wv);
    it++;
  }
  pv.total(out);
  wv.total(out);
  purge(bin);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that the shape of
<B>main(&#160;)</B> has changed again. Now there&#8217;s only a single
<B>Trash</B> bin. The two <B>Visitor</B> objects are accepted into every element
in the sequence, and they perform their operations. The visitors keep their own
internal data to tally the total weights and
prices.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I208">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I209"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Finally, there&#8217;s no run-time type
identification other than the inevitable cast to <B>Trash</B> when pulling
things out of the sequence.

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I209">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I210"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One way you can distinguish this solution
from the double dispatching solution described previously is to note that, in
the double dispatching solution, only one of the overloaded methods,
<B>add(&#160;)</B>, was overridden when each subclass was created, while here
<I>each</I> one of the overloaded <B>visit(&#160;)</B> methods is overridden in
every subclass of
<B>Visitor</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I210">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I211"></a>
</FONT><BR></P></DIV>
<A NAME="Heading363"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
More coupling?</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s a lot more code here, and
there&#8217;s definite coupling between the <B>Trash</B> hierarchy and the
<B>Visitor</B> hierarchy. However, there&#8217;s also high cohesion within the
respective sets of classes: they each do only one thing (<B>Trash </B>describes
trash, while <B>Visitor </B>describes actions performed on <B>Trash</B>), which
is an indicator of a good design. Of course, in this case it works well only if
you&#8217;re adding new <B>Visitor</B>s, but it gets in the way when you add new
types of <B>Trash</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I211">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I212"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Low coupling between classes and high
cohesion within a class is definitely an important design goal. Applied
mindlessly, though, it can prevent you from achieving a more elegant design. It
seems that some classes inevitably have a certain intimacy with each other.
These often occur in pairs that could perhaps be called
<A NAME="Index707"></A><I>couplets</I>, for example, containers and iterators.
The <B>Trash-Visitor</B> pair above appears to be another such
couplet.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I212">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I213"></a>
</FONT><A NAME="_Toc375545419"></A><A NAME="_Toc408018806"></A><A NAME="_Toc519042146"></A><BR></P></DIV>
<A NAME="Heading364"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
RTTI considered harmful?</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Various designs in this chapter attempt
to remove RTTI, which might give you the impression that it&#8217;s
&#8220;considered harmful&#8221; (the condemnation used for poor <B>goto</B>).
This isn&#8217;t true; it is the <A NAME="Index708"></A><I>misuse</I> of RTTI
that is the problem. The reason our designs removed RTTI is because the
misapplication of that feature prevented <A NAME="Index709"></A>extensibility,
which contravened the stated goal of adding a new type to the system with as
little impact on surrounding code as possible. Since RTTI is often misused by
having it look for every single type in your system, it causes code to be
non-extensible: when you add a new type, you have to go hunting for all the code
in which RTTI is used, and if you miss any you won&#8217;t get help from the
compiler.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I213">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I214"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">However, RTTI doesn&#8217;t automatically
create non-extensible code. Let&#8217;s revisit the trash recycler once more.
This time, a new tool will be introduced, which I call a <B>TypeMap</B>. It
inherits from a <B>map</B> that holds a variant of <B>type_info </B>object as
the key, and <B>vector&lt;Trash*&gt;</B> as the value. The interface is simple:
you call <B>addTrash(&#160;)</B> to add a new <B>Trash</B> pointer, and the
<B>map </B>class provides the rest of the interface. The keys represent the
types contained in the associated <B>vector</B>. The beauty of this design
(suggested by Larry O&#8217;Brien) is that the <B>TypeMap</B> dynamically adds a
new key-value pair whenever it encounters a new type, so whenever you add a new
type to the system (even if you add the new type at runtime), it
adapts.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I214">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I215"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The example will again build on the
structure of the <B>Trash</B> types, and will use <B>fillBin(&#160;) </B>to
parse and insert the values into the <B>TypeMap</B>. However, <B>TypeMap</B> is
not a <B>vector&lt;Trash*&gt;</B>, and so it must be adapted to work with
<B>fillBin(&#160;)</B> by multiply inheriting from <B>Fillable</B>. In addition,
the Standard C++ <B>type_info</B> class is too restrictive to be used as a key,
so a kind of wrapper class <B>TypeInfo</B> is created, which simply extracts and
stores the <B>type_info</B> <B>char*</B> representation of the type (making the
assumption that, within the realm of a single compiler, this representation will
be unique for each
type).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I215">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I216"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C11:DynaTrash.cpp</font>
<font color=#009900>//{L} TrashProtoInit ../TestSuite/Test</font>
<font color=#009900>//{L} fillBin Trash TrashStat</font>
<font color=#009900>// Using a map of vectors and RTTI</font>
<font color=#009900>// to automatically sort Trash into</font>
<font color=#009900>// vectors. This solution, despite the</font>
<font color=#009900>// use of RTTI, is extensible.</font>
#include <font color=#004488>"Trash.h"</font>
#include <font color=#004488>"fillBin.h"</font>
#include <font color=#004488>"sumValue.h"</font>
#include <font color=#004488>"..</font><font color=#004488>/purge.h"</font>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;typeinfo&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;
ofstream out(<font color=#004488>"DynaTrash.out"</font>);

<font color=#009900>// Must adapt from type_info in Standard C++,</font>
<font color=#009900>// since type_info is too restrictive:</font>
<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> T&gt; <font color=#009900>// T should be a base class</font>
<font color=#0000ff>class</font> TypeInfo {
  string id;
<font color=#0000ff>public</font>:
  TypeInfo(T* t) : id(<font color=#0000ff>typeid</font>(*t).name()) {}
  <font color=#0000ff>const</font> string&amp; name() { <font color=#0000ff>return</font> id; }
  <font color=#0000ff>friend</font> <font color=#0000ff>bool</font> <font color=#0000ff>operator</font>&lt;(<font color=#0000ff>const</font> TypeInfo&amp; lv,
    <font color=#0000ff>const</font> TypeInfo&amp; rv){
    <font color=#0000ff>return</font> lv.id &lt; rv.id;
  }
};

<font color=#0000ff>class</font> TypeMap : 
  <font color=#0000ff>public</font> map&lt;TypeInfo&lt;Trash&gt;, vector&lt;Trash*&gt; &gt;,
  <font color=#0000ff>public</font> Fillable {
<font color=#0000ff>public</font>:
  <font color=#009900>// Satisfies the Fillable interface:</font>
  <font color=#0000ff>void</font> addTrash(Trash* t) {
    (*<font color=#0000ff>this</font>)[TypeInfo&lt;Trash&gt;(t)].push_back(t);
  }
  ~TypeMap() {
    <font color=#0000ff>for</font>(iterator it = begin(); it != end(); it++)
      purge((*it).second);
  }
};

<font color=#0000ff>int</font> main() {
  TypeMap bin;
  fillBin(<font color=#004488>"Trash.dat"</font>, bin); <font color=#009900>// Sorting happens</font>
  TypeMap::iterator it;
  <font color=#0000ff>for</font>(it = bin.begin(); it != bin.end(); it++)
    sumValue((*it).second);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>TypeInfo</B> is templatized because
<B>typeid(&#160;)</B> does not allow the use of <B>void*</B>, which would be the
most general way to solve the problem. So you are required to work with some
specific class, but this class should be the most base of all the classes in
your hierarchy. <B>TypeInfo</B> must define an <B>operator&lt;</B> because a
<B>map</B> needs it to order its
keys.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I216">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I217"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although powerful, the definition for
<B>TypeMap</B> is simple; the <B>addTrash(&#160;)</B> member function does most
of the work. When you add a new <B>Trash </B>pointer, the a
<B>TypeInfo&lt;Trash&gt; </B>object for that type is generated. This is used as
a key to determine whether a <B>vector</B> holding objects of that type is
already present in the <B>map</B>. If so, the <B>Trash </B>pointer is added to
that <B>vector</B>. If not, the <B>TypeInfo </B>object and a new <B>vector</B>
are added as a key-value
pair.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I217">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I218"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An iterator to the map, when
dereferenced, produces a <B>pair </B>object where the key<B>
</B>(<B>TypeInfo</B>)<B> </B>is the <B>first</B> member, and the value
(<B>Vector&lt;Trash*&gt;</B>)<B> </B>is the <B>second </B>member. And
that&#8217;s all there is to
it.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I218">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I219"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>TypeMap </B>takes advantage of the
design of <B>fillBin(&#160;)</B>, which doesn&#8217;t just try to fill a
<B>vector</B> but instead anything that implements the <B>Fillable</B> interface
with its <B>addTrash(&#160;)</B> member function. Since <B>TypeMap </B>is
multiply inherited from <B>Fillable</B>, it can be used as an argument to
<B>fillBin(&#160;)</B> like
this:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I219">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I220"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>fillBin(<font color=#004488>"Trash.dat"</font>, bin);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An interesting thing about this design is
that even though it wasn&#8217;t created to handle the sorting,
<B>fillBin(&#160;)</B> is performing a sort every time it inserts a <B>Trash</B>
pointer into <B>bin</B>. When the <B>Trash</B> is thrown into <B>bin</B>
it&#8217;s immediately sorted by <B>TypeMap</B>&#8217;s internal sorting
mechanism. Stepping through the <B>TypeMap</B> and operating on each individual
<B>vector</B> becomes a simple matter, and uses ordinary STL
syntax.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I220">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I221"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As you can see, adding a new type to the
system won&#8217;t affect this code at all, nor the code in <B>TypeMap</B>. This
is certainly the smallest solution to the problem, and arguably the most elegant
as well. It does rely heavily on RTTI, but notice that each key-value pair in
the <B>map</B> is looking for only one type. In addition, there&#8217;s no way
you can &#8220;forget&#8221; to add the proper code to this system when you add
a new type, since there isn&#8217;t any code you need to add, other than that
which supports the prototyping process (and you&#8217;ll find out right away if
you forget
that).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I221">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I222"></a>
</FONT><A NAME="_Toc408018807"></A><A NAME="_Toc519042147"></A><BR></P></DIV>
<A NAME="Heading365"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Summary</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Coming up with a design such as
<B>TrashVisitor.cpp </B>that contains a larger amount of code than the earlier
designs can seem at first to be counterproductive. It pays to notice what
you&#8217;re trying to accomplish with various designs. Design patterns in
general strive to <I>separate the things that change from the things that stay
the same</I>. The &#8220;things that change&#8221; can refer to many different
kinds of changes. Perhaps the change occurs because the program is placed into a
new environment or because something in the current environment changes (this
could be: &#8220;The user wants to add a new shape to the diagram currently on
the screen&#8221;). Or, as in this case, the change could be the evolution of
the code body. While previous versions of the trash-sorting example emphasized
the addition of new <I>types</I> of <B>Trash </B>to the system,
<B>TrashVisitor.cpp</B> allows you to easily add new <I>functionality</I>
without disturbing the <B>Trash</B> hierarchy. There&#8217;s more code in
<B>TrashVisitor.cpp</B>, but adding new functionality to <B>Visitor</B> is
cheap. If this is something that happens a lot, then it&#8217;s worth the extra
effort and code to make it happen more
easily.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I222">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I223"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The discovery of the
<A NAME="Index710"></A>vector of change is no trivial matter; it&#8217;s not
something that an analyst can usually detect before the program sees its initial
design. The necessary information will probably not appear until later phases in
the project: sometimes only at the design or implementation phases do you
discover a deeper or more subtle need in your system. In the case of adding new
types (which was the focus of most of the &#8220;recycle&#8221; examples) you
might realize that you need a particular inheritance hierarchy only when you are
in the maintenance phase and you begin extending the
system!
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I223">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I224"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the most important things that
you&#8217;ll learn by studying design patterns seems to be an about-face from
what has been promoted so far in this book. That is: &#8220;OOP is all about
polymorphism.&#8221; This statement can produce the &#8220;two-year-old with a
hammer&#8221; syndrome (everything looks like a nail). Put another way,
it&#8217;s hard enough to &#8220;get&#8221; polymorphism, and once you do, you
try to cast all your designs into that one particular
mold.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I224">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I225"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What design patterns say is that OOP
isn&#8217;t just about polymorphism. It&#8217;s about &#8220;separating the
things that change from the things that stay the same.&#8221;
<A NAME="Index711"></A>Polymorphism is an especially important way to do this,
and it turns out to be helpful if the programming language directly supports
polymorphism (so you don&#8217;t have to wire it in yourself, which would tend
to make it prohibitively expensive). But design patterns in general show
<I>other</I> ways to accomplish the basic goal, and once your eyes have been
opened to this you will begin to search for more creative
designs.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I225">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I226"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since the <I>Design Patterns</I> book
came out and made such an impact, people have been searching for other patterns.
You can expect to see more of these appear as time goes on. Here are some sites
recommended by Jim Coplien, of C++ fame (<I>http://www.bell-labs.com/~cope</I>),
who is one of the main proponents of the patterns
movement:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I226">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I227"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">http://st-www.cs.uiuc.edu/users/patterns</FONT><BR><FONT FACE="Georgia">http://c2.com/cgi/wiki</FONT><BR><FONT FACE="Georgia">http://c2.com/ppr</FONT><BR><FONT FACE="Georgia">http://www.bell-labs.com/people/cope/Patterns/Process/index.html</FONT><BR><FONT FACE="Georgia">http://www.bell-labs.com/cgi-user/OrgPatterns/OrgPatterns</FONT><BR><FONT FACE="Georgia">http://st-www.cs.uiuc.edu/cgi-bin/wikic/wikic</FONT><BR><FONT FACE="Georgia">http://www.cs.wustl.edu/~schmidt/patterns.html</FONT><BR><FONT FACE="Georgia">http://www.espinc.com/patterns/overview.html</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P>Also note there has been a yearly conference on design
patterns, called PLOP, that produces a published proceedings. The third one of
these proceedings came out in late 1997 (all published by
Addison-Wesley).<A NAME="_Toc375545420"></A><A NAME="_Toc408018808"></A><A NAME="_Toc519042148"></A><BR></P></DIV>
<A NAME="Heading366"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Exercises</H2></FONT>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Using
<B>SingletonPattern.cpp</B> as a starting point, create a class that manages a
fixed number of its own objects. Assume the objects are database connections and
you only have a license to use a fixed quantity of these at any one
time.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I227">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I228"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
a minimal Observer-Observable design in two classes, without base classes and
without the extra arguments in <B>Observer.h</B> and the member functions in
<B>Observable.h</B>. Just create the bare minimum in the two classes, then
demonstrate your design by creating one <B>Observable</B> and many
<B>Observer</B>s, and cause the <B>Observable</B> to update the
<B>Observer</B>s.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I228">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I229"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Change
<B>InnerClassIdiom.cpp</B> so that <B>Outer</B> uses multiple inheritance
instead of the inner class
idiom.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I229">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I230"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Add
a class <B>Plastic</B> to
TrashVisitor.cpp.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I230">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I231"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Add
a class <B>Plastic</B> to
DynaTrash.cpp.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I231">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I232"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Explain
how <B>AbstractFactory.cpp</B> demonstrates <I>Double Dispatching</I> and the
<I>Factory
Method</I>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I232">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I233"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>ShapeFactory2.cpp</B> so that it uses an <I>Abstract Factory</I> to create
different sets of shapes (for example, one particular type of factory object
creates &#8220;thick shapes,&#8221; another creates &#8220;thin shapes,&#8221;
but each factory object can create all the shapes: circles, squares, triangles
etc.).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I233">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I234"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
a business-modeling environment with three types of <B>Inhabitant</B>:
<B>Dwarf</B> (for engineers), <B>Elf</B> (for marketers) and <B>Troll</B> (for
managers). Now create a class called <B>Project</B> that creates the different
inhabitants and causes them to <B>interact(&#160;)</B> with each other using
multiple
dispatching.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I234">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I235"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
the above example to make the interactions more detailed. Each <B>Inhabitant</B>
can randomly produce a <B>Weapon</B> using <B>getWeapon(&#160;)</B>: a
<B>Dwarf</B> uses <B>Jargon</B> or <B>Play</B>, an <B>Elf</B> uses
<B>InventFeature</B> or <B>SellImaginaryProduct</B>, and a <B>Troll</B> uses
<B>Edict</B> and <B>Schedule</B>. You must decide which weapons
&#8220;win&#8221; and &#8220;lose&#8221; in each interaction (as in
<B>PaperScissorsRock.cpp</B>). Add a <B>battle(&#160;)</B> member function to
<B>Project</B> that takes two <B>Inhabitant</B>s and matches them against each
other. Now create a <B>meeting(&#160;)</B> member function for <B>Project</B>
that creates groups of <B>Dwarf</B>, <B>Elf</B> and <B>Manager</B> and battles
the groups against each other until only members of one group are left standing.
These are the
&#8220;winners.&#8221;
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I235">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER11_I236"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Implement
<I>Chain of Responsibility</I> to create an &#8220;expert system&#8221; that
solves problems by successively trying one solution after another until one
matches. You should be able to dynamically add solutions to the expert system.
The test for solution should just be a string match, but when a solution fits,
the expert system should return the appropriate type of problemSolver object.
What other pattern/patterns show up
here?
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER11_I236">Comment</a>&nbsp;]

</FONT></OL>
<HR><DIV ALIGN="LEFT"><P><A NAME="fn28" HREF="#fnB28">[28]</A><FONT FACE="Georgia" SIZE=2>
Conveniently, the examples are in C++.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn29" HREF="#fnB29">[29]</A><FONT FACE="Georgia" SIZE=2>James
O. Coplien, <I>Advanced C++ Programming Styles and Idioms</I>, Addison-Wesley,
1992.</FONT><BR></P></DIV>

<DIV ALIGN="CENTER">
    <FONT FACE="Verdana, Tahoma, Arial, Helvetica, Sans" size = "-1">
     [ <a href="Chap10.htm">Previous Chapter</a> ] 
    
    [ <a href="SimpCont.htm">Short TOC</a> ] 
    [ <a href="Contents.htm">Table of Contents</a> ] 
  
        [ <a href="DocIdx.htm">Index</a> ]
        
     [ <a href="AppendA.htm">Next Chapter</a> ] 
    </FONT>
    <BR>
 Last Update:08/19/2001</P></DIV>

</BODY>

</HTML>

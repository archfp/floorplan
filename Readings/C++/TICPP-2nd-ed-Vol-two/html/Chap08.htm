<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:C:\TEMP\TicV2\html\TicV2.rtf
Application Directory:C:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:08/19/2001
Translation Time:14:25:02
Translation Platform:Win32
Number of Output files:19
This File:C:\TEMP\TicV2\html\Chap08.htm
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html">
<TITLE>8: STL Algorithms</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF"><DIV ALIGN="CENTER">
  <a href="http://www.MindView.net">
  <img src="mindview.gif" alt="MindView Inc." BORDER = "0"></a>
  <CENTER>
    <FONT FACE="Verdana, Tahoma, Arial, Helvetica, Sans" size = "-1">
    [ <a href="README.txt">Viewing Hints</a> ]
    [ <a href="RevisionHistory.htm">Revision History</a> ]
    [ <a href="http://www.mindview.net/Books/TICPP/ThinkingInCPP2e.html">Book Home Page</a> ]
    [ <a href="http://www.mindview.net/Etc/MailingList.html">Free Newsletter</a> ] <br>
    [ <a href="http://www.mindview.net/Seminars">Seminars</a> ]
    [ <a href="http://www.mindview.net/CDs">Seminars on CD ROM</a> ]
    [ <a href="http://www.mindview.net/Services">Consulting</a> ]
    </FONT>
  <H2><FONT FACE="Verdana, Tahoma, Arial, Helvetica, Sans">
  Thinking in C++, 2nd edition, Volume 2<br>
  <small>Revision 4.0</small></FONT></H2>
  <H3><FONT FACE="Verdana, Tahoma, Arial, Helvetica, Sans">
  by Bruce Eckel &amp; Chuck Allison<br>&copy;2001 MindView, Inc.</FONT></H3>
  
    <FONT FACE="Verdana, Tahoma, Arial, Helvetica, Sans" size = "-1">
     [ <a href="Chap07.htm">Previous Chapter</a> ] 
    
    [ <a href="SimpCont.htm">Short TOC</a> ] 
    [ <a href="Contents.htm">Table of Contents</a> ] 
  
        [ <a href="DocIdx.htm">Index</a> ]
        
     [ <a href="Part3.htm">Next Chapter</a> ] 
    </FONT>
    
  </CENTER>
  </P></DIV><A NAME="_Toc519042058"></A><A NAME="Heading247"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H1 ALIGN="LEFT">
8: STL Algorithms<A NAME="STLAlgorithmsChapter"></A></H1></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana" SIZE=4><a NAME="TIC2V2_CHAPTER8_I1"></a>
The
other half of the STL is the algorithms, which are templatized functions
designed to work with the containers (or, as you will see, anything that can
behave like a container, including arrays<B> </B>and <B>string</B>
objects).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The STL was originally designed around
the algorithms. The goal was that you use algorithms for almost every piece of
code that you write. In this sense it was a bit of an experiment, and only time
will tell how well it works. The real test will be in how easy or difficult it
is for the average programmer to adapt. At the end of this chapter you&#8217;ll
be able to decide for yourself whether you find the algorithms addictive or too
confusing to remember. If you&#8217;re like me, you&#8217;ll resist them at
first but then tend to use them more and
more.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I1">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I2"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Before you make your judgment, however,
there&#8217;s one other thing to consider. The STL algorithms provide a
<I>vocabulary</I> with which to describe solutions. That is, once you become
familiar with the algorithms you&#8217;ll have a new set of words with which to
discuss what you&#8217;re doing, and these words are at a higher level than what
you&#8217;ve had before. You don&#8217;t have to say &#8220;this loop moves
through and assigns from here to there ... oh, I see, it&#8217;s copying!&#8221;
Instead, you say <B>copy(&#160;)</B>. This is the kind of thing we&#8217;ve been
doing in computer programming from the beginning &#8211; creating more dense
ways to express <I>what</I> we&#8217;re doing and spending less time saying
<I>how</I> we&#8217;re doing it. Whether the STL algorithms and <I>generic
programming </I>are a great success in accomplishing this remains to be seen,
but that is certainly the
objective.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I2">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I3"></a>
</FONT><A NAME="_Toc519042059"></A><BR></P></DIV>
<A NAME="Heading248"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Function objects</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A concept that is used heavily in the STL
algorithms is the <I>function object</I>, which was introduced in the previous
chapter. A function object has an overloaded <B>operator(&#160;)</B>, and the
result is that a template function can&#8217;t tell whether you&#8217;ve handed
it a pointer to a function or an object that has an <B>operator(&#160;)</B>; all
the template function knows is that it can attach an argument list to the object
<I>as if</I> it were a pointer to a
function:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I3">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I4"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:FuncObject.cpp</font>
<font color=#009900>// Simple function objects</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> UnaryFunc, <font color=#0000ff>class</font> T&gt;
<font color=#0000ff>void</font> callFunc(T&amp; x, UnaryFunc f) {
  f(x);
}

<font color=#0000ff>void</font> g(<font color=#0000ff>int</font>&amp; x) {
  x = 47;
}

<font color=#0000ff>struct</font> UFunc {
  <font color=#0000ff>void</font> <font color=#0000ff>operator</font>()(<font color=#0000ff>int</font>&amp; x) {
    x = 48;
  }
};

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> y = 0;
  callFunc(y, g);
  cout &lt;&lt; y &lt;&lt; endl;
  y = 0;
  callFunc(y, UFunc());
  cout &lt;&lt; y &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The template <B>callFunc(&#160;)</B> says
&#8220;give me an <B>f</B> and an <B>x</B>, and I&#8217;ll write the code
<B>f(x)</B>.&#8221; In <B>main(&#160;)</B>, you can see that it doesn&#8217;t
matter if <B>f</B> is a pointer to a function (as in the case of
<B>g(&#160;)</B>), or if it&#8217;s a function object (which is created as a
temporary object by the expression <B>UFunc(&#160;)</B>). Notice you can only
accomplish this genericity with a template function; a non-template function is
too particular about its argument types to allow such a thing. The STL
algorithms use this flexibility to take either a function pointer or a function
object, but you&#8217;ll usually find that creating a function object is more
powerful and flexible.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I4">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I5"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The function object is actually a
variation on the theme of a <I>callback</I>, which is described in the design
patterns chapter. A callback allows you to vary the behavior of a function or
object by passing, as an argument, a way to execute some other piece of code.
Here, we are handing <B>callFunc(&#160;)</B> a pointer to a function or a
function object.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I5">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I6"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following descriptions of function
objects should not only make that topic clear, but also give you an introduction
to the way the STL algorithms
work.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I6">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I7"></a>
</FONT><A NAME="_Toc519042060"></A><BR></P></DIV>
<A NAME="Heading249"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Classification of function objects</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Just as the STL classifies iterators
(based on their capabilities), it also classifies function objects based on the
number of arguments that their <B>operator(&#160;)</B> takes and the kind of
value returned by that operator (of course, this is also true for function
pointers when you treat them as function objects). The classification of
function objects in the STL is based on whether the <B>operator(&#160;)</B>
takes zero, one or two arguments, and if it returns a <B>bool</B> or
non-<B>bool</B> value.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I7">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I8"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Generator</B>: Takes no arguments, and
returns a value of the desired type. A <B>RandomNumberGenerator</B> is a special
case.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I8">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I9"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>UnaryFunction</B>: Takes a single
argument of any type and returns a value which may be of a different
type.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I9">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I10"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>BinaryFunction</B>: Takes two
arguments of any two types and returns a value of any
type.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I10">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I11"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A special case of the unary and binary
functions is the <I>predicate</I>, which simply means a function that returns a
<B>bool</B>. A predicate is a function you use to make a<B>
true</B>/<B>false</B>
decision.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I11">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I12"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Predicate</B>: This can also be called
a <B>UnaryPredicate</B>. It takes a single argument of any type and returns a
<B>bool</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I12">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I13"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>BinaryPredicate</B>: Takes two
arguments of any two types and returns a
<B>bool</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I13">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I14"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>StrictWeakOrdering</B>: A binary
predicate that says that if you have two objects and neither one is less than
the other, they can be regarded as equivalent to each
other.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I14">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I15"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In addition, there are sometimes
qualifications on object types that are passed to an algorithm. These
qualifications are given in the template argument type identifier
name:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I15">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I16"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>LessThanComparable</B>: A class that
has a less-than
<B>operator&lt;</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I16">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I17"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Assignable</B>: A class that has an
assignment <B>operator=</B> for its own
type.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I17">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I18"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>EqualityComparable</B>: A class that
has an equivalence <B>operator==</B> for its own
type.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I18">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I19"></a>
</FONT><A NAME="_Toc519042061"></A><BR></P></DIV>
<A NAME="Heading250"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Automatic creation of function objects</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The STL has, in the header file
<B>&lt;functional&gt;</B>, a set of templates that will automatically create
function objects for you. These generated function objects are admittedly
simple, but the goal is to provide very basic functionality that will allow you
to compose more complicated function objects, and in many situations this is all
you&#8217;ll need. Also, you&#8217;ll see that there are some <I>function object
adapters</I> that allow you to take the simple function objects and make them
slightly more
complicated.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I19">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I20"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here are the templates that generate
function objects, along with the expressions that they effect.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=68 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Name</FONT><BR></P></DIV>
</TH>
<TH WIDTH=76 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Type</FONT><BR></P></DIV>
</TH>
<TH WIDTH=166 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Result produced by generated function
object</FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">plus</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">BinaryFunction</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">arg1 + arg2</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">minus</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">BinaryFunction</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">arg1 - arg2</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">multiplies</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">BinaryFunction</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">arg1 * arg2</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">divides</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">BinaryFunction</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">arg1 / arg2</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">modulus</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">BinaryFunction</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">arg1 % arg2</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">negate</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">UnaryFunction</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">- arg1</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">equal_to</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">BinaryPredicate</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">arg1 == arg2</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">not_equal_to</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">BinaryPredicate</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">arg1 != arg2</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">greater</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">BinaryPredicate</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">arg1 &gt; arg2</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">less</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">BinaryPredicate</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">arg1 &lt; arg2</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">greater_equal</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">BinaryPredicate</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">arg1 &gt;= arg2</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">less_equal</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">BinaryPredicate</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">arg1 &lt;= arg2</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">logical_and</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">BinaryPredicate</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">arg1 &amp;&amp; arg2</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">logical_or</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">BinaryPredicate</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">arg1 || arg2</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">logical_not</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">UnaryPredicate</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">!arg1</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">not1(&#160;)</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Unary Logical</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">!(UnaryPredicate(arg1))</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">not2(&#160;)</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Binary Logical</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">!(BinaryPredicate(arg1,
arg2))</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example provides simple
tests for each of the built-in basic function object templates. This way, you
can see how to use each one, along with their resulting
behavior.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I20">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I21"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:FunctionObjects.cpp</font>
<font color=#009900>// Using the predefined function object templates</font>
<font color=#009900>// in the Standard C++ library</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>// This will be defined shortly:</font>
#include <font color=#004488>"Generators.h"</font>
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>template</font>&lt;<font color=#0000ff>typename</font> T&gt; 
<font color=#0000ff>void</font> print(vector&lt;T&gt;&amp; v, <font color=#0000ff>char</font>* msg = <font color=#004488>""</font>) {
  <font color=#0000ff>if</font>(*msg != 0)
    cout &lt;&lt; msg &lt;&lt; <font color=#004488>":"</font> &lt;&lt; endl;
  copy(v.begin(), v.end(), 
    ostream_iterator&lt;T&gt;(cout, <font color=#004488>" "</font>));
  cout &lt;&lt; endl;
}

<font color=#0000ff>template</font>&lt;<font color=#0000ff>typename</font> Contain, <font color=#0000ff>typename</font> UnaryFunc&gt; 
<font color=#0000ff>void</font> testUnary(Contain&amp; source, Contain&amp; dest,
  UnaryFunc f) {
  transform(source.begin(), source.end(), 
    dest.begin(), f);
}

<font color=#0000ff>template</font>&lt;<font color=#0000ff>typename</font> Contain1, <font color=#0000ff>typename</font> Contain2, 
  <font color=#0000ff>typename</font> BinaryFunc&gt; 
<font color=#0000ff>void</font> testBinary(Contain1&amp; src1, Contain1&amp; src2,
  Contain2&amp; dest, BinaryFunc f) {
  transform(src1.begin(), src1.end(), 
    src2.begin(), dest.begin(), f);
}

<font color=#009900>// Executes the expression, then stringizes the</font>
<font color=#009900>// expression into the print statement:</font>
#define T(EXPR) EXPR; print(r, <font color=#004488>"After "</font> #EXPR);
<font color=#009900>// For Boolean tests:</font>
#define B(EXPR) EXPR; print(br,<font color=#004488>"After "</font> #EXPR);

<font color=#009900>// Boolean random generator:</font>
<font color=#0000ff>struct</font> BRand {
  BRand() { srand(time(0)); }
  <font color=#0000ff>bool</font> <font color=#0000ff>operator</font>()() {
    <font color=#0000ff>return</font> rand() &gt; RAND_MAX / 2;
  }
};

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> sz = 10;
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> max = 50;
  vector&lt;<font color=#0000ff>int</font>&gt; x(sz), y(sz), r(sz);
  <font color=#009900>// An integer random number generator:</font>
  URandGen urg(max);
  generate_n(x.begin(), sz, urg);
  generate_n(y.begin(), sz, urg);
  <font color=#009900>// Add one to each to guarantee nonzero divide:</font>
  transform(y.begin(), y.end(), y.begin(),
    bind2nd(plus&lt;<font color=#0000ff>int</font>&gt;(), 1));
  <font color=#009900>// Guarantee one pair of elements is ==:</font>
  x[0] = y[0];
  print(x, <font color=#004488>"x"</font>);
  print(y, <font color=#004488>"y"</font>);
  <font color=#009900>// Operate on each element pair of x &amp; y,</font>
  <font color=#009900>// putting the result into r:</font>
  T(testBinary(x, y, r, plus&lt;<font color=#0000ff>int</font>&gt;()));
  T(testBinary(x, y, r, minus&lt;<font color=#0000ff>int</font>&gt;()));
  T(testBinary(x, y, r, multiplies&lt;<font color=#0000ff>int</font>&gt;()));
  T(testBinary(x, y, r, divides&lt;<font color=#0000ff>int</font>&gt;()));
  T(testBinary(x, y, r, modulus&lt;<font color=#0000ff>int</font>&gt;()));
  T(testUnary(x, r, negate&lt;<font color=#0000ff>int</font>&gt;()));
  vector&lt;<font color=#0000ff>bool</font>&gt; br(sz); <font color=#009900>// For Boolean results</font>
  B(testBinary(x, y, br, equal_to&lt;<font color=#0000ff>int</font>&gt;()));
  B(testBinary(x, y, br, not_equal_to&lt;<font color=#0000ff>int</font>&gt;()));
  B(testBinary(x, y, br, greater&lt;<font color=#0000ff>int</font>&gt;()));
  B(testBinary(x, y, br, less&lt;<font color=#0000ff>int</font>&gt;()));
  B(testBinary(x, y, br, greater_equal&lt;<font color=#0000ff>int</font>&gt;()));
  B(testBinary(x, y, br, less_equal&lt;<font color=#0000ff>int</font>&gt;()));
  B(testBinary(x, y, br, 
    not2(greater_equal&lt;<font color=#0000ff>int</font>&gt;())));
  B(testBinary(x,y,br,not2(less_equal&lt;<font color=#0000ff>int</font>&gt;())));
  vector&lt;<font color=#0000ff>bool</font>&gt; b1(sz), b2(sz);
  generate_n(b1.begin(), sz, BRand());
  generate_n(b2.begin(), sz, BRand());
  print(b1, <font color=#004488>"b1"</font>);
  print(b2, <font color=#004488>"b2"</font>);
  B(testBinary(b1, b2, br, logical_and&lt;<font color=#0000ff>int</font>&gt;()));
  B(testBinary(b1, b2, br, logical_or&lt;<font color=#0000ff>int</font>&gt;()));
  B(testUnary(b1, br, logical_not&lt;<font color=#0000ff>int</font>&gt;()));
  B(testUnary(b1, br, not1(logical_not&lt;<font color=#0000ff>int</font>&gt;())));
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To keep this example small, some tools
are created. The <B>print(&#160;)</B> template is designed to print any
<B>vector&lt;T&gt;</B>, along with an optional message. Since
<B>print(&#160;)</B> uses the STL <B>copy(&#160;)</B> algorithm to send objects
to <B>cout</B> via an <B>ostream_iterator</B>, the <B>ostream_iterator</B> must
know the type of object it is printing, and therefore the <B>print(&#160;)</B>
template must know this type also. However, you&#8217;ll see in
<B>main(&#160;)</B> that the compiler can deduce the type of <B>T</B> when you
hand it a <B>vector&lt;T&gt;</B>, so you don&#8217;t have to hand it the
template argument explicitly; you just say <B>print(x)</B> to print the
<B>vector&lt;T&gt; x</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I21">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I22"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The next two template functions automate
the process of testing the various function object templates. There are two
since the function objects are either unary or binary. In
<B>testUnary(&#160;)</B>, you pass a source and destination vector, and a unary
function object to apply to the source vector to produce the destination vector.
In <B>testBinary(&#160;)</B>, there are two source vectors which are fed to a
binary function to produce the destination vector. In both cases, the template
functions simply turn around and call the <B>transform(&#160;)</B> algorithm,
although the tests could certainly be more
complex.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I22">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I23"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For each test, you want to see a string
describing what the test is, followed by the results of the test. To automate
this, the preprocessor comes in handy; the <B>T(&#160;)</B> and <B>B(&#160;)</B>
macros each take the expression you want to execute. They call that expression,
then call <B>print(&#160;)</B>, passing it the result vector (they assume the
expression changes a vector named <B>r</B> and <B>br</B>, respectively), and to
produce the message the expression is &#8220;string-ized&#8221; using the
preprocessor. So that way you see the code of the expression that is executed
followed by the result
vector.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I23">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I24"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The last little tool is a generator
object that creates random <B>bool</B> values. To do this, it gets a random
number from <B>rand(&#160;)</B> and tests to see if it&#8217;s greater than
<B>RAND_MAX/2</B>. If the random numbers are evenly distributed, this should
happen half the time.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I24">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I25"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>main(&#160;)</B>, three
<B>vector&lt;int&gt;</B> are created: <B>x</B> and <B>y</B> for source values,
and <B>r</B> for results. To initialize <B>x</B> and <B>y</B> with random values
no greater than 50, a generator of type <B>URandGen</B> is used; this will be
defined shortly. Since there is one operation where elements of <B>x</B> are
divided by elements of <B>y</B>, we must ensure that there are no zero values of
<B>y</B>. This is accomplished using the <B>transform(&#160;)</B> algorithm,
taking the source values from <B>y</B> and putting the results back into
<B>y</B>. The function object for this is created with the
expression:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I25">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I26"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>bind2nd(plus&lt;<font color=#0000ff>int</font>&gt;(), 1)</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This uses the <B>plus</B> function object
that adds two objects together. It is thus a binary function which requires two
arguments; we only want to pass it one argument (the element from <B>y</B>) and
have the other argument be the value 1. A &#8220;binder&#8221; does the trick
(we will look at these next). The binder in this case says &#8220;make a new
function object which is the <B>plus</B> function object with the second
argument fixed at 1.&#8221;

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I26">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I27"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Another of the tests in the program
compares the elements in the two vectors for equality, so it is interesting to
guarantee that at least one pair of elements is equivalent; in this case element
zero is chosen.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I27">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I28"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once the two vectors are printed,
<B>T(&#160;)</B> is used to test each of the function objects that produces a
numerical value, and then <B>B(&#160;)</B> is used to test each function object
that produces a Boolean result. The result is placed into a
<B>vector&lt;bool&gt;</B>, and when this vector is printed it produces a
&#8216;<B>1</B>&#8217; for a true value and a &#8216;<B>0</B>&#8217; for a false
value.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I28">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I29"></a>
</FONT><BR></P></DIV>
<A NAME="Heading251"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Binders</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s common to want to take a
binary function object and to &#8220;bind&#8221; one of its arguments to a
constant value. After binding, you get a unary function
object.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I29">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I30"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For example, suppose you want to find
integers that are less than a particular value, say 20. Sensibly enough, the STL
algorithms have a function called <B>find_if(&#160;)</B> that will search
through a sequence; however, <B>find_if(&#160;)</B> requires a unary predicate
to tell it if this is what you&#8217;re looking for. This unary predicate can of
course be some function object that you have written by hand, but it can also be
created using the built-in function object templates. In this case, the
<B>less</B> template will work, but that produces a binary predicate, so we need
some way of forming a unary predicate. The binder templates (which work with any
binary function object, not just binary predicates) give you two
choices:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I30">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I31"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><B>bind1st(const BinaryFunction&amp; op, const T&amp;
t);</B><BR><B>bind2nd(const BinaryFunction&amp; op, const T&amp;
t);</B><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Both bind <B>t </B>to one of the
arguments of <B>op</B>, but <B>bind1st(&#160;)</B> binds <B>t</B> to the first
argument, and <B>bind2nd(&#160;)</B> binds <B>t</B> to the second argument. With
<B>less</B>, the function object that provides the solution to our exercise
is:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I31">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I32"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>bind2nd(less&lt;<font color=#0000ff>int</font>&gt;(), 20);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This produces a new function object that
returns true if its argument is less than 20. Here it is, used with
<B>find_if(&#160;)</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I32">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I33"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:Binder1.cpp</font>
<font color=#009900>// Using STL "binders"</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-g++3}</font>
#include <font color=#004488>"Generators.h"</font>
#include <font color=#004488>"copy_if.h"</font>
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> sz = 10;
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> max = 40;
  vector&lt;<font color=#0000ff>int</font>&gt; a(sz), r;
  URandGen urg(max);
  ostream_iterator&lt;<font color=#0000ff>int</font>&gt; out(cout, <font color=#004488>" "</font>);
  generate_n(a.begin(), sz, urg);
  copy(a.begin(), a.end(), out);
  <font color=#0000ff>int</font>* d = find_if(a.begin(), a.end(), 
    bind2nd(less&lt;<font color=#0000ff>int</font>&gt;(), 20));
  cout &lt;&lt; <font color=#004488>"\n *d = "</font> &lt;&lt; *d &lt;&lt; endl;
  <font color=#009900>// copy_if() is not in the Standard C++ library</font>
  <font color=#009900>// but is defined later in the chapter:</font>
  copy_if(a.begin(), a.end(), back_inserter(r),
    bind2nd(less&lt;<font color=#0000ff>int</font>&gt;(), 20));
  copy(r.begin(), r.end(), out);
  cout &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>vector&lt;int&gt;</B> <B>a</B> is
filled with random numbers between 0 and <B>max</B>. <B>find_if(&#160;)</B>
finds the first element in <B>a</B> that satisfies the predicate (that is, which
is less than 20) and returns an iterator to it (here, the type of the iterator
is actually just <B>int*</B> although I could have been more precise and said
<B>vector&lt;int&gt;::iterator</B>
instead).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I33">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I34"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A more interesting algorithm to use is
<B>copy_if(&#160;)</B>, which isn&#8217;t part of the STL but is defined at the
end of this chapter. This algorithm only copies an element from the source to
the destination if that element satisfies a predicate. So the resulting vector
will only contain elements that are less than
20.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I34">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I35"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s a second example, using a
<B>vector&lt;string&gt;</B> and replacing strings that satisfy particular
conditions:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I35">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I36"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:Binder2.cpp</font>
<font color=#009900>// More binders</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  ostream_iterator&lt;string&gt; out(cout, <font color=#004488>" "</font>);
  vector&lt;string&gt; v, r;
  v.push_back(<font color=#004488>"Hi"</font>);
  v.push_back(<font color=#004488>"Hi"</font>);
  v.push_back(<font color=#004488>"Hey"</font>);
  v.push_back(<font color=#004488>"Hee"</font>);
  v.push_back(<font color=#004488>"Hi"</font>);
  copy(v.begin(), v.end(), out);
  cout &lt;&lt; endl;
  <font color=#009900>// Replace each "Hi" with "Ho":</font>
  replace_copy_if(v.begin(), v.end(), 
    back_inserter(r), 
    bind2nd(equal_to&lt;string&gt;(), <font color=#004488>"Hi"</font>), <font color=#004488>"Ho"</font>);
  copy(r.begin(), r.end(), out);
  cout &lt;&lt; endl;
  <font color=#009900>// Replace anything that's not "Hi" with "Ho":</font>
  replace_if(v.begin(), v.end(), 
    not1(bind2nd(equal_to&lt;string&gt;(),<font color=#004488>"Hi"</font>)),<font color=#004488>"Ho"</font>);
  copy(v.begin(), v.end(), out);
  cout &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This uses another pair of STL algorithms.
The first, <B>replace_copy_if(&#160;)</B>, copies each element from a source
range to a destination range, performing replacements on those that satisfy a
particular unary predicate. The second, <B>replace_if(&#160;)</B>, doesn&#8217;t
do any copying but instead performs the replacements directly into the original
range.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I36">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I37"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A binder doesn&#8217;t have to produce a
unary predicate; it can also create a unary function (that is, a function that
returns something other than <B>bool</B>). For example, suppose you&#8217;d like
to multiply every element in a <B>vector</B> by 10. Using a binder with the
<B>transform(&#160;)</B> algorithm does the
trick:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I37">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I38"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:Binder3.cpp</font>
<font color=#009900>// Binders aren't limited to producing predicates</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"Generators.h"</font>
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  ostream_iterator&lt;<font color=#0000ff>int</font>&gt; out(cout, <font color=#004488>" "</font>);
  vector&lt;<font color=#0000ff>int</font>&gt; v(15);
  generate(v.begin(), v.end(), URandGen(20));
  copy(v.begin(), v.end(), out);
  cout &lt;&lt; endl;
  transform(v.begin(), v.end(), v.begin(),
    bind2nd(multiplies&lt;<font color=#0000ff>int</font>&gt;(), 10));
  copy(v.begin(), v.end(), out);
  cout &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since the third argument to
<B>transform(&#160;) </B>is the same as the first, the resulting elements are
copied back into the source vector. The function object created by
<B>bind2nd(&#160;)</B> in this case produces an <B>int</B>
result.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I38">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I39"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The &#8220;bound&#8221; argument to a
binder cannot be a function object, but it does not have to be a compile-time
constant. For example:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I39">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I40"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:Binder4.cpp</font>
<font color=#009900>// The bound argument does not have </font>
<font color=#009900>// to be a compile-time constant</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-g++295}</font>
#include <font color=#004488>"copy_if.h"</font>
#include <font color=#004488>"PrintSequence.h"</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;cstdlib&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> boundedRand() { <font color=#0000ff>return</font> rand() % 100; }

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> sz = 20;
  <font color=#0000ff>int</font> a[20], b[20] = {0};
  generate(a, a + sz, boundedRand);
  <font color=#0000ff>int</font> val = boundedRand();
  <font color=#0000ff>int</font>* end = copy_if(a, a + sz, b, bind2nd(greater&lt;<font color=#0000ff>int</font>&gt;(), val));
  <font color=#009900>// Sort for easier viewing:</font>
  sort(a, a + sz);
  sort(b, end);
  print(a, a + sz, <font color=#004488>"array a"</font>, <font color=#004488>" "</font>);
  print(b, end, <font color=#004488>"values greater than yours"</font>,<font color=#004488>" "</font>);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here, an array is filled with random
numbers between 0 and 100, and the user provides a value on the command line. In
the <B>copy_if(&#160;)</B> call, you can see that the bound argument to
<B>bind2nd(&#160;)</B> is the result of the function call <B>atoi(&#160;)</B>
(from
<B>&lt;cstdlib&gt;</B>).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I40">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I41"></a>
</FONT><BR></P></DIV>
<A NAME="Heading252"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Function pointer adapters</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Any place in an STL algorithm where a
function object is required, it&#8217;s very conceivable that you&#8217;d like
to use a function pointer instead. Actually, you <I>can</I> use an ordinary
function pointer &#8211; that&#8217;s how the STL was designed, so that a
&#8220;function object&#8221; can actually be anything that can be dereferenced
using an argument list. For example, the <B>rand(&#160;)</B> random number
generator can be passed to <B>generate(&#160;)</B> or <B>generate_n(&#160;)</B>
as a function pointer, like
this:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I41">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I42"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:RandGenTest.cpp</font>
<font color=#009900>// A little test of the random number generator</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-msc}</font>
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> sz = 10000;
  <font color=#0000ff>int</font> v[sz];
  srand(time(0)); <font color=#009900>// Seed the random generator</font>
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 300; i++) {
    <font color=#009900>// Using a naked pointer to function:</font>
    generate(v, v + sz, std::rand);
    <font color=#0000ff>int</font> count = count_if(v, v + sz, 
      bind2nd(greater&lt;<font color=#0000ff>int</font>&gt;(), RAND_MAX/2));
    cout &lt;&lt; (((<font color=#0000ff>double</font>)count)/((<font color=#0000ff>double</font>)sz)) * 100
      &lt;&lt; ' ';
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The &#8220;iterators&#8221; in this case
are just the starting and past-the-end pointers for the array <B>v</B>, and the
generator is just a pointer to the standard library <B>rand(&#160;)</B>
function. The program repeatedly generates a group of random numbers, then it
uses the STL algorithm <B>count_if(&#160;)</B> and a predicate that tells
whether a particular element is greater than <B>RAND_MAX/2</B>. The result is
the number of elements that match this criterion; this is divided by the total
number of elements and multiplied by 100 to produce the percentage of elements
greater than the midpoint. If the random number generator is reasonable, this
value should hover at around 50% (of course, there are many other tests to
determine if the random number generator is
reasonable).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I42">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I43"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>ptr_fun(&#160;) </B>adapters take
a pointer to a function and turn it into a function object. They are not
designed for a function that takes no arguments, like the one above (that is, a
generator). Instead, they are for unary functions and binary functions. However,
these could also be simply passed as if they were function objects, so the
<B>ptr_fun(&#160;)</B> adapters might at first appear to be redundant.
Here&#8217;s an example where using <B>ptr_fun(&#160;)</B> and simply passing
the address of the function both produce the same
results:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I43">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I44"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:PtrFun1.cpp</font>
<font color=#009900>// Using ptr_fun() for single-argument functions</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-bor}</font>
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>char</font>* n[] = { <font color=#004488>"01.23"</font>, <font color=#004488>"91.370"</font>, <font color=#004488>"56.661"</font>,
  <font color=#004488>"023.230"</font>, <font color=#004488>"19.959"</font>, <font color=#004488>"1.0"</font>, <font color=#004488>"3.14159"</font> };
<font color=#0000ff>const</font> <font color=#0000ff>int</font> nsz = <font color=#0000ff>sizeof</font> n / <font color=#0000ff>sizeof</font> *n;

<font color=#0000ff>template</font>&lt;<font color=#0000ff>typename</font> InputIter&gt;
<font color=#0000ff>void</font> print(InputIter first, InputIter last) {
  <font color=#0000ff>while</font>(first != last)
    cout &lt;&lt; *first++ &lt;&lt; <font color=#004488>"\t"</font>;
  cout &lt;&lt; endl;
}

<font color=#0000ff>int</font> main() {
  print(n, n + nsz);
  vector&lt;<font color=#0000ff>double</font>&gt; vd;
  transform(n, n + nsz, back_inserter(vd), atof);
  print(vd.begin(), vd.end());
  transform(n,n + nsz,vd.begin(), ptr_fun(atof));
  print(vd.begin(), vd.end());
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The goal of this program is to convert an
array of <B>char*</B> which are ASCII representations of floating-point numbers
into a <B>vector&lt;double&gt;</B>. After defining this array and the
<B>print(&#160;)</B> template (which encapsulates the act of printing a range of
elements), you can see <B>transform(&#160;)</B> used with <B>atof(&#160;)</B> as
a &#8220;naked&#8221; pointer to a function, and then a second time with
<B>atof</B> passed to <B>ptr_fun(&#160;)</B>. The results are the same. So why
bother with <B>ptr_fun(&#160;)</B>? Well, the actual effect of
<B>ptr_fun(&#160;)</B> is to create a function object with an
<B>operator(&#160;)</B>. This function object can then be passed to other
template adapters, such as binders, to create new function objects. As
you&#8217;ll see a bit later, the SGI extensions to the STL contain a number of
other function templates to enable this, but in the Standard C++ STL there are
only the <B>bind1st(&#160;)</B> and <B>bind2nd(&#160;)</B> function templates,
and these expect binary function objects as their first arguments. In the above
example, only the <B>ptr_fun(&#160;)</B> for a unary function is used, and that
doesn&#8217;t work with the binders. So <B>ptr_fun(&#160;)</B> used with a unary
function in Standard C++ really is redundant (note that Gnu g++ uses the SGI
STL).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I44">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I45"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">With a binary function and a binder,
things can be a little more interesting. This program produces the squares of
the input vector
<B>d</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I45">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I46"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:PtrFun2.cpp</font>
<font color=#009900>// Using ptr_fun() for two-argument functions</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-bor}</font>
<font color=#009900>//{-g++3}</font>
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;cmath&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>double</font> d[] = { 01.23, 91.370, 56.661,
  023.230, 19.959, 1.0, 3.14159 };
<font color=#0000ff>const</font> <font color=#0000ff>int</font> dsz = <font color=#0000ff>sizeof</font> d / <font color=#0000ff>sizeof</font> *d;

<font color=#0000ff>int</font> main() {
  vector&lt;<font color=#0000ff>double</font>&gt; vd;
  transform(d, d + dsz, back_inserter(vd), 
    bind2nd(ptr_fun(pow), 2.0));
  copy(vd.begin(), vd.end(),
    ostream_iterator&lt;<font color=#0000ff>double</font>&gt;(cout, <font color=#004488>" "</font>));
  cout &lt;&lt; endl;    
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here, <B>ptr_fun(&#160;)</B> is
indispensable; <B>bind2nd(&#160;)</B> <I>must</I> have a function object as its
first argument and a pointer to function won&#8217;t cut
it.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I46">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I47"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A trickier problem is that of converting
a member function into a function object suitable for using in the STL
algorithms. As a simple example, suppose we have the &#8220;shape&#8221; problem
and would like to apply the <B>draw(&#160;)</B> member function to each pointer
in a container of
<B>Shape</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I47">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I48"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:MemFun1.cpp</font>
<font color=#009900>// Applying pointers to member functions</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-msc}</font>
#include <font color=#004488>"..</font><font color=#004488>/purge.h"</font>
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Shape {
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> draw() = 0;
  <font color=#0000ff>virtual</font> ~Shape() {}
};

<font color=#0000ff>class</font> Circle : <font color=#0000ff>public</font> Shape {
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> draw() {
    cout &lt;&lt; <font color=#004488>"Circle::Draw()"</font> &lt;&lt; endl;
  }
  ~Circle() {
    cout &lt;&lt; <font color=#004488>"Circle::~Circle()"</font> &lt;&lt; endl;
  }
};

<font color=#0000ff>class</font> Square : <font color=#0000ff>public</font> Shape {
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> draw() {
    cout &lt;&lt; <font color=#004488>"Square::Draw()"</font> &lt;&lt; endl;
  }
  ~Square() {
    cout &lt;&lt; <font color=#004488>"Square::~Square()"</font> &lt;&lt; endl;
  }
};

<font color=#0000ff>int</font> main() {
  vector&lt;Shape*&gt; vs;
  vs.push_back(<font color=#0000ff>new</font> Circle);
  vs.push_back(<font color=#0000ff>new</font> Square);
  for_each(vs.begin(), vs.end(), 
    mem_fun(&amp;Shape::draw));
  purge(vs);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>for_each(&#160;)</B> function does
just what it sounds like it does: passes each element in the range determined by
the first two (iterator) arguments to the function object which is its third
argument. In this case we want the function object to be created from one of the
member functions of the class itself, and so the function object&#8217;s
&#8220;argument&#8221; becomes the pointer to the object that the member
function is called for. To produce such a function object, the
<B>mem_fun(&#160;)</B> template takes a pointer to member as its
argument.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I48">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I49"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>mem_fun(&#160;)</B> functions are
for producing function objects that are called using a pointer to the object
that the member function is called for, while <B>mem_fun_ref(&#160;)</B> is used
for calling the member function directly for an object. One set of overloads of
both <B>mem_fun(&#160;)</B> and <B>mem_fun_ref(&#160;)</B> are for member
functions that take zero arguments and one argument, and this is multiplied by
two to handle <B>const</B> vs. non-<B>const</B> member functions. However,
templates and overloading takes care of sorting all of that out; all you need to
remember is when to use <B>mem_fun(&#160;)</B> vs.
<B>mem_fun_ref(&#160;)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I49">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I50"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Suppose you have a container of objects
(not pointers) and you want to call a member function that takes an argument.
The argument you pass should come from a second container of objects. To
accomplish this, the second overloaded form of the <B>transform(&#160;)</B>
algorithm is used:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I50">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I51"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:MemFun2.cpp</font>
<font color=#009900>// Applying pointers to member functions</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-msc}</font>
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Angle {
  <font color=#0000ff>int</font> degrees;
<font color=#0000ff>public</font>:
  Angle(<font color=#0000ff>int</font> deg) : degrees(deg) {}
  <font color=#0000ff>int</font> mul(<font color=#0000ff>int</font> times) {
    <font color=#0000ff>return</font> degrees *= times;
  }
};

<font color=#0000ff>int</font> main() {
  vector&lt;Angle&gt; va;
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 50; i += 10)
    va.push_back(Angle(i));
  <font color=#0000ff>int</font> x[] = { 1, 2, 3, 4, 5 };
  transform(va.begin(), va.end(), x,
    ostream_iterator&lt;<font color=#0000ff>int</font>&gt;(cout, <font color=#004488>" "</font>),
    mem_fun_ref(&amp;Angle::mul));
  cout &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because the container is holding objects,
<B>mem_fun_ref(&#160;)</B> must be used with the pointer-to-member function.
This version of <B>transform(&#160;)</B> takes the start and end point of the
first range (where the objects live), the starting point of second range which
holds the arguments to the member function, the destination iterator which in
this case is standard output, and the function object to call for each object;
this function object is created with <B>mem_fun_ref(&#160;)</B> and the desired
pointer to member. Notice the <B>transform(&#160;)</B> and
<B>for_each(&#160;)</B> template functions are incomplete;
<B>transform(&#160;)</B> requires that the function it calls return a value and
there is no <B>for_each(&#160;)</B> that passes two arguments to the function it
calls. Thus, you cannot call a member function that returns <B>void</B> and
takes an argument using <B>transform(&#160;)</B> or
<B>for_each(&#160;)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I51">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I52"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Any member function works, including
those in the Standard libraries. For example, suppose you&#8217;d like to read a
file and search for blank lines; you can use the <B>string::empty(&#160;)</B>
member function like
this:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I52">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I53"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:FindBlanks.cpp</font>
<font color=#009900>// Demonstrate mem_fun_ref() with string::empty()</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>// Probably a bug in this program:</font>
<font color=#009900>//{-msc}</font>
<font color=#009900>//{-bor} dumps core</font>
<font color=#009900>//{-g++295} dumps core</font>
<font color=#009900>//{-g++3} dumps core</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;algorithm&gt;
#include &lt;list&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;
#include &lt;functional&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>typedef</font> list&lt;string&gt;::iterator LSI;

LSI blank(LSI begin, LSI end) {
   <font color=#0000ff>return</font> find_if(begin, end, 
     mem_fun_ref(&amp;string::empty));
}

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  <font color=#0000ff>char</font>* fname = <font color=#004488>"FindBlanks.cpp"</font>;
  <font color=#0000ff>if</font>(argc &gt; 1) fname = argv[1];
  ifstream in(fname);
  assure(in, fname);
  list&lt;string&gt; ls;
  string s;
  <font color=#0000ff>while</font>(getline(in, s))
    ls.push_back(s);
  LSI lsi = blank(ls.begin(), ls.end());
  <font color=#0000ff>while</font>(lsi != ls.end()) {
    *lsi = <font color=#004488>"A BLANK LINE"</font>;
    lsi = blank(lsi, ls.end());
  }
  string f(argv[1]);
  f += <font color=#004488>".out"</font>;
  ofstream out(f.c_str());
  copy(ls.begin(), ls.end(), 
    ostream_iterator&lt;string&gt;(out, <font color=#004488>"\n"</font>));
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>blank(&#160;)</B> function uses
<B>find_if(&#160;)</B> to locate the first blank line in the given range using
<B>mem_fun_ref(&#160;)</B> with <B>string::empty(&#160;)</B>. After the file is
opened and read into the <B>list</B>, <B>blank(&#160;)</B> is called repeated
times to find every blank line in the file. Notice that subsequent calls to
<B>blank(&#160;)</B> use the current version of the iterator so it moves forward
to the next one. Each time a blank line is found, it is replaced with the
characters &#8220;A BLANK LINE.&#8221; All you have to do to accomplish this is
dereference the iterator, and you select the current
<B>string</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I53">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I54"></a>
</FONT><A NAME="_Toc519042062"></A><BR></P></DIV>
<A NAME="Heading253"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
SGI extensions</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The SGI STL (mentioned at the end of the
previous chapter) also includes additional function object templates, which
allow you to write expressions that create even more complicated function
objects. Consider a more involved program which converts strings of digits into
floating point numbers, like <B>PtrFun2.cpp</B> but more general. First,
here&#8217;s a generator that creates strings of integers that represent
floating-point values (including an embedded decimal
point):
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I54">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I55"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:NumStringGen.h</font>
<font color=#009900>// A random number generator that produces </font>
<font color=#009900>// strings representing floating-point numbers</font>
#ifndef NUMSTRINGGEN_H
#define NUMSTRINGGEN_H
#include &lt;string&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;

<font color=#0000ff>class</font> NumStringGen {
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> sz; <font color=#009900>// Number of digits to make</font>
<font color=#0000ff>public</font>:
  NumStringGen(<font color=#0000ff>int</font> ssz = 5) : sz(ssz) { 
    std::srand(std::time(0)); 
  }
  std::string <font color=#0000ff>operator</font>()() {
    <font color=#0000ff>static</font> <font color=#0000ff>char</font> n[] = <font color=#004488>"0123456789"</font>;
    <font color=#0000ff>const</font> <font color=#0000ff>int</font> nsz = 10;
    std::string r(sz, ' ');
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; sz; i++)
      <font color=#0000ff>if</font>(i == sz/2)
        r[i] = '.'; <font color=#009900>// Insert a decimal point</font>
      <font color=#0000ff>else</font>
        r[i] = n[std::rand() % nsz];
    <font color=#0000ff>return</font> r;
  }
};
#endif <font color=#009900>// NUMSTRINGGEN_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You tell it how big the <B>string</B>s
should be when you create the <B>NumStringGen</B> object. The random number
generator is used to select digits, and a decimal point is placed in the
middle.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I55">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I56"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following program (which works with
the Standard C++ STL without the SGI extensions) uses <B>NumStringGen</B> to
fill a <B>vector&lt;string&gt;</B>. However, to use the Standard C library
function <B>atof(&#160;)</B> to convert the strings to floating-point numbers,
the <B>string</B> objects must first be turned into <B>char</B> pointers, since
there is no automatic type conversion from <B>string</B> to <B>char*</B>. The
<B>transform(&#160;)</B> algorithm can be used with <B>mem_fun_ref(&#160;)</B>
and <B>string::c_str(&#160;)</B> to convert all the <B>string</B>s to
<B>char*</B>, and then these can be transformed using
<B>atof</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I56">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I57"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:MemFun3.cpp</font>
<font color=#009900>// Using mem_fun()</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-msc}</font>
#include <font color=#004488>"NumStringGen.h"</font>
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> sz = 9;
  vector&lt;string&gt; vs(sz);
  <font color=#009900>// Fill it with random number strings:</font>
  generate(vs.begin(), vs.end(), NumStringGen());
  copy(vs.begin(), vs.end(), 
    ostream_iterator&lt;string&gt;(cout, <font color=#004488>"\t"</font>));
  cout &lt;&lt; endl;
  <font color=#0000ff>const</font> <font color=#0000ff>char</font>* vcp[sz];
  transform(vs.begin(), vs.end(), vcp, 
    mem_fun_ref(&amp;string::c_str));
  vector&lt;<font color=#0000ff>double</font>&gt; vd;
  transform(vcp,vcp + sz,back_inserter(vd),
    std::atof);
  copy(vd.begin(), vd.end(), 
    ostream_iterator&lt;<font color=#0000ff>double</font>&gt;(cout, <font color=#004488>"\t"</font>));
  cout &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The SGI extensions to the STL contain a
number of additional function object templates that accomplish more detailed
activities than the Standard C++ function object templates, including
<B>identity </B>(returns its argument unchanged), <B>project1st</B> and
<B>project2nd</B> (to take two arguments and return the first or second one,
respectively), <B>select1st</B> and <B>select2nd</B> (to take a <B>pair</B>
object and return the first or second element, respectively), and the
&#8220;compose&#8221; function
templates.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I57">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I58"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you&#8217;re using the SGI extensions,
you can make the above program denser using one of the two &#8220;compose&#8221;
function templates. The first, <B>compose1(f1,&#160;f2)</B>, takes the two
function objects <B>f1 </B>and <B>f2 </B>as its arguments. It produces a
function object that takes a single argument, passes it to <B>f2</B>, then takes
the result of the call to <B>f2</B> and passes it to <B>f1</B>. The result of
<B>f1</B> is returned. By using <B>compose1(&#160;)</B>, the process of
converting the <B>string</B> objects to <B>char*</B>, then converting the
<B>char*</B> to a floating-point number can be combined into a single operation,
like this:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I58">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I59"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:MemFun4.cpp</font>
<font color=#009900>// Using the SGI STL compose1 function</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-bor} Can add the header by hand</font>
<font color=#009900>//{-msc} Can add the header by hand</font>
#include <font color=#004488>"NumStringGen.h"</font>
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> sz = 9;
  vector&lt;string&gt; vs(sz);
  <font color=#009900>// Fill it with random number strings:</font>
  generate(vs.begin(), vs.end(), NumStringGen());
  copy(vs.begin(), vs.end(), 
    ostream_iterator&lt;string&gt;(cout, <font color=#004488>"\t"</font>));
  cout &lt;&lt; endl;
  vector&lt;<font color=#0000ff>double</font>&gt; vd;
  transform(vs.begin(), vs.end(), back_inserter(vd),
    compose1(ptr_fun(atof), 
      mem_fun_ref(&amp;string::c_str)));
  copy(vd.begin(), vd.end(), 
    ostream_iterator&lt;<font color=#0000ff>double</font>&gt;(cout, <font color=#004488>"\t"</font>));
  cout &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see there&#8217;s only a single
call to <B>transform(&#160;)</B> now, and no intermediate holder for the
<B>char</B> pointers.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I59">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I60"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second &#8220;compose&#8221; function
is <B>compose2(&#160;)</B>, which takes three function objects as its arguments.
The first function object is binary (it takes two arguments), and its arguments
are the results of the second and third function objects, respectively. The
function object that results from <B>compose2(&#160;)</B> expects one argument,
and it feeds that argument to the second and third function objects. Here is an
example:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I60">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I61"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:Compose2.cpp</font>
<font color=#009900>// Using the SGI STL compose2() function</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-bor} Can add the header by hand</font>
<font color=#009900>//{-msc} Can add the header by hand</font>
#include <font color=#004488>"copy_if.h"</font>
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  srand(time(0));
  vector&lt;<font color=#0000ff>int</font>&gt; v(100);
  generate(v.begin(), v.end(), rand);
  transform(v.begin(), v.end(), v.begin(),
    bind2nd(divides&lt;<font color=#0000ff>int</font>&gt;(), RAND_MAX/100));
  vector&lt;<font color=#0000ff>int</font>&gt; r;
  copy_if(v.begin(), v.end(), back_inserter(r),
    compose2(logical_and&lt;<font color=#0000ff>bool</font>&gt;(),
      bind2nd(greater_equal&lt;<font color=#0000ff>int</font>&gt;(), 30),
      bind2nd(less_equal&lt;<font color=#0000ff>int</font>&gt;(), 40)));
  sort(r.begin(), r.end());
  copy(r.begin(), r.end(),
    ostream_iterator&lt;<font color=#0000ff>int</font>&gt;(cout, <font color=#004488>" "</font>));
  cout &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>vector&lt;int&gt; v</B> is first
filled with random numbers. To cut these down to size, the
<B>transform(&#160;)</B> algorithm is used to divide each value by
<B>RAND_MAX/100</B>, which will force the values to be between 0 and 100 (making
them more readable). The <B>copy_if(&#160;)</B> algorithm defined later in this
chapter is then used, along with a composed function object, to copy all the
elements that are greater than or equal to 30 and less than or equal to 40 into
the destination <B>vector&lt;int&gt; r</B>. Just to show how easy it is,
<B>r</B> is sorted, and then
displayed.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I61">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I62"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The arguments of <B>compose2(&#160;)</B>
say, in effect:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I62">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I63"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>(x &gt;= 30) &amp;&amp; (x &lt;= 40)</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You could also take the function object
that comes from a <B>compose1(&#160;)</B> or <B>compose2(&#160;)</B> call and
pass it into another &#8220;compose&#8221; expression ... but this could rapidly
get very difficult to
decipher.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I63">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I64"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Instead of all this composing and
transforming, you can write your own function objects (<I>without </I>using the
SGI extensions) as
follows:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I64">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I65"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:NoCompose.cpp</font>
<font color=#009900>// Writing out the function objects explicitly</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"copy_if.h"</font>
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Rgen {
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> max;
<font color=#0000ff>public</font>:
  Rgen(<font color=#0000ff>int</font> mx = 100) : max(RAND_MAX/mx) {
    srand(time(0));
  }
  <font color=#0000ff>int</font> <font color=#0000ff>operator</font>()() { <font color=#0000ff>return</font> rand() / max; }
};

<font color=#0000ff>class</font> BoundTest {
  <font color=#0000ff>int</font> top, bottom;
<font color=#0000ff>public</font>:
  BoundTest(<font color=#0000ff>int</font> b, <font color=#0000ff>int</font> t) : bottom(b), top(t) {}
  <font color=#0000ff>bool</font> <font color=#0000ff>operator</font>()(<font color=#0000ff>int</font> arg) {
    <font color=#0000ff>return</font> (arg &gt;= bottom) &amp;&amp; (arg &lt;= top);
  }
};

<font color=#0000ff>int</font> main() {
  vector&lt;<font color=#0000ff>int</font>&gt; v(100);
  generate(v.begin(), v.end(), Rgen());
  vector&lt;<font color=#0000ff>int</font>&gt; r;
  copy_if(v.begin(), v.end(), back_inserter(r),
    BoundTest(30, 40));
  sort(r.begin(), r.end());
  copy(r.begin(), r.end(),
    ostream_iterator&lt;<font color=#0000ff>int</font>&gt;(cout, <font color=#004488>" "</font>));
  cout &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are a few more lines of code, but
you can&#8217;t deny that it&#8217;s much clearer and easier to understand, and
therefore to maintain. 
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I65">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I66"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">We can thus observe two drawbacks to the
SGI extensions to the STL. The first is simply that it&#8217;s an extension;
yes, you can download and use them for free so the barriers to entry are low,
but your company may be conservative and decide that if it&#8217;s not in
Standard C++, they don&#8217;t want to use it. The second drawback is
complexity. Once you get familiar and comfortable with the idea of composing
complicated functions from simple ones you can visually parse complicated
expressions and figure out what they mean. However, my guess is that most people
will find anything more than what you can do with the Standard, non-extended STL
function object notation to be overwhelming. At some point on the complexity
curve you have to bite the bullet and write a regular class to produce your
function object, and that point might as well be the point where you can&#8217;t
use the Standard C++ STL. A stand-alone class for a function object is going to
be much more readable and maintainable than a complicated function-composition
expression (although my sense of adventure does lure me into wanting to
experiment more with the SGI
extensions...).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I66">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I67"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As a final note, you can&#8217;t compose
generators; you can only create function objects whose <B>operator(&#160;)</B>
requires one or two
arguments.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I67">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I68"></a>
</FONT><A NAME="_Toc519042063"></A><BR></P></DIV>
<A NAME="Heading254"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
A catalog of STL algorithms</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This section provides a quick reference
for when you&#8217;re searching for the appropriate algorithm. I leave the full
exploration of all the STL algorithms to other references (see the end of this
chapter, and Appendix XX), along with the more intimate details of complexity,
performance, etc. My goal here is for you to become rapidly comfortable and
facile with the algorithms, and I will assume you will look into the more
specialized references if you need more depth of
detail.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I68">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I69"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although you will often see the
algorithms described using their full template declaration syntax, I am not
doing that here because you already know they are templates, and it&#8217;s
quite easy to see what the template arguments are from the function
declarations. The type names for the arguments provide descriptions for the
types of iterators required. I think you&#8217;ll find this form is easier to
read, while you can quickly find the full declaration in the template header
file if for some reason you feel the
need.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I69">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I70"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The names of the iterator classes
describe the iterator type they must conform to. The iterator types were
described in the previous chapter, but here is a
summary:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I70">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I71"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>InputIterator</B>.<B> </B>You (or
rather, the STL algorithm and any algorithms you write that use
<B>InputIterator</B>s)<B> </B>can increment this with <B>operator++</B> and
dereference it with <B>operator*</B> to <I>read</I> the value (and <I>only</I>
read the value), but you can only read each value once. <B>InputIterator</B>s<B>
</B>can be tested with <B>operator==</B> and <B>operator!=</B>. That&#8217;s
all. Because an <B>InputIterator</B> is so limited, it can be used with
<B>istream</B>s (via
<B>istream_iterator</B>).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I71">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I72"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>OutputIterator</B>.<B> </B>This can be
incremented with <B>operator++</B>, and dereferenced with <B>operator*</B> to
<I>write</I> the value (and <I>only</I> write the value), but you can only
dereference/write each value once. <B>OutputIterator</B>s cannot be tested with
<B>operator==</B> and <B>operator!=</B>, however, because you assume that you
can just keep sending elements to the destination and that you don&#8217;t have
to see if the destination&#8217;s end marker has been reached. That is, the
container that an <B>OutputIterator</B> references can take an infinite number
of objects, so no end-checking is necessary. This requirement is important so
that an <B>OutputIterator</B> can be used with <B>ostream</B>s (via
<B>ostream_iterator</B>), but you&#8217;ll also commonly use the
&#8220;insert&#8221; iterators <B>insert_iterator</B>,
<B>front_insert_iterator</B> and <B>back_insert_iterator</B> (generated by the
helper templates <B>inserter(&#160;)</B>, <B>front_inserter(&#160;)</B> and
<B>back_inserter(&#160;)</B>).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I72">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I73"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">With both <B>InputIterator</B> and
<B>OutputIterator</B>, you cannot have multiple iterators pointing to different
parts of the same range. Just think in terms of iterators to support
<B>istream</B>s and <B>ostream</B>s, and <B>InputIterator</B> and
<B>OutputIterator</B> will make perfect sense. Also note that
<B>InputIterator</B> and <B>OutputIterator</B> put the weakest restrictions on
the types of iterators they will accept, which means that you can use any
&#8220;more sophisticated&#8221; type of iterator when you see
<B>InputIterator</B> or <B>OutputIterator</B> used as STL algorithm template
arguments.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I73">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I74"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ForwardIterator</B>.
<B>InputIterator</B> and <B>OutputIterator</B> are the most restricted, which
means they&#8217;ll work with the largest number of actual iterators. However,
there are some operations for which they are too restricted; you can only read
from an <B>InputIterator</B> and write to an <B>OutputIterator</B>, so you
can&#8217;t use them to read and modify a range, for example, and you
can&#8217;t have more than one active iterator on a particular range, or
dereference such an iterator more than once. With a <B>ForwardIterator</B> these
restrictions are relaxed; you can still only move forward using
<B>operator++</B>, but you can both write and read and you can write/read
multiple times in each location. A <B>ForwardIterator</B> is much more like a
regular pointer, whereas <B>InputIterator</B> and <B>OutputIterator</B> are a
bit strange by
comparison.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I74">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I75"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>BidirectionalIterator</B>.<B>
</B>Effectively, this is a <B>ForwardIterator</B> that can also go backward.
That is, a <B>BidirectionalIterator</B> supports all the operations that a
<B>ForwardIterator</B> does, but in addition it has an <B>operator--</B>.

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I75">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I76"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>RandomAccessIterator</B>. An iterator
that is random access supports all the same operations that a regular pointer
does: you can add and subtract integral values to move it forward and backward
by jumps (rather than just one element at a time), you can subscript it with
<B>operator[&#160;]</B>, you can subtract one iterator from another, and
iterators can be compared to see which is greater using <B>operator&lt;</B>,
<B>operator&gt;</B>, etc. If you&#8217;re implementing a sorting routine or
something similar, random access iterators are necessary to be able to create an
efficient algorithm.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I76">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I77"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The names used for the template parameter
types consist of the above iterator types (sometimes with a &#8216;1&#8217; or
&#8216;2&#8217; appended to distinguish different template arguments), and may
also include other arguments, often function objects.

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I77">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I78"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When describing the group of elements
that an operation is performed on, mathematical &#8220;range&#8221; notation
will often be used. In this, the square bracket means &#8220;includes the end
point&#8221; while the parenthesis means &#8220;does not include the end
point.&#8221; When using iterators, a range is determined by the iterator
pointing to the initial element, and the &#8220;past-the-end&#8221; iterator,
pointing past the last element. Since the past-the-end element is never used,
the range determined by a pair of iterators can thus be expressed as <B>[first,
last)</B>, where <B>first</B> is the iterator pointing to the initial element
and <B>last</B> is the past-the-end
iterator.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I78">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I79"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Most books and discussions of the STL
algorithms arrange them according to side effects: non-mutating algorithms
don&#8217;t change the elements in the range, mutating algorithms do change the
elements, etc. These descriptions are based more on the underlying behavior or
implementation of the algorithm &#8211; that is, the designer&#8217;s
perspective. In practice, I don&#8217;t find this a very useful categorization
so I shall instead organize them according to the problem you want to solve: are
you searching for an element or set of elements, performing an operation on each
element, counting elements, replacing elements, etc. This should help you find
the one you want more
easily.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I79">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I80"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that all the algorithms are in the
<B>namespace std</B>. If you do not see a different header such as
<B>&lt;utility&gt;</B> or <B>&lt;numerics&gt;</B> above the function
declarations, that means it appears in
<B>&lt;algorithm&gt;</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I80">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I81"></a>
</FONT><A NAME="_Toc519042064"></A><BR></P></DIV>
<A NAME="Heading255"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Support tools for example creation</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s useful to create some basic
tools with which to test the
algorithms.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I81">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I82"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Displaying a range is something that will
be done constantly, so here is a templatized function that allows you to print
any sequence, regardless of the type that&#8217;s in that
sequence:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I82">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I83"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:PrintSequence.h</font>
<font color=#009900>// Prints the contents of any sequence</font>
#ifndef PRINTSEQUENCE_H
#define PRINTSEQUENCE_H
#include &lt;iostream&gt;

<font color=#0000ff>template</font>&lt;<font color=#0000ff>typename</font> InputIter&gt;
<font color=#0000ff>void</font> print(InputIter first, InputIter last,
  <font color=#0000ff>char</font>* nm = <font color=#004488>""</font>, <font color=#0000ff>char</font>* sep = <font color=#004488>"\n"</font>, 
  std::ostream&amp; os = std::cout) { 
  <font color=#0000ff>if</font>(*nm != '\0') <font color=#009900>// Only if you provide a string</font>
    os &lt;&lt; nm &lt;&lt; <font color=#004488>": "</font> &lt;&lt; sep; <font color=#009900>// is this printed</font>
  <font color=#0000ff>while</font>(first != last)
    os &lt;&lt; *first++ &lt;&lt; sep;
  os &lt;&lt; std::endl;
}

#ifndef _MSC_VER
<font color=#009900>// Use template-templates to allow type deduction</font>
<font color=#009900>// of the typename T:</font>
<font color=#0000ff>template</font>&lt;<font color=#0000ff>typename</font> T, <font color=#0000ff>template</font>&lt;<font color=#0000ff>typename</font>&gt; <font color=#0000ff>class</font> C&gt;
<font color=#0000ff>void</font> print(C&lt;T&gt;&amp; c, <font color=#0000ff>char</font>* nm = <font color=#004488>""</font>, 
  <font color=#0000ff>char</font>* sep = <font color=#004488>"\n"</font>, 
  std::ostream&amp; os = std::cout) {
  <font color=#0000ff>if</font>(*nm != '\0') <font color=#009900>// Only if you provide a string</font>
    os &lt;&lt; nm &lt;&lt; <font color=#004488>": "</font> &lt;&lt; sep; <font color=#009900>// is this printed</font>
  std::copy(c.begin(), c.end(), 
    std::ostream_iterator&lt;T&gt;(os, <font color=#004488>" "</font>));
  cout &lt;&lt; endl;
}
#endif
#endif <font color=#009900>// PRINTSEQUENCE_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are two forms here, one that
requires you to give an explicit range (this allows you to print an array or a
sub-sequence) and one that prints any of the STL containers, which provides
notational convenience when printing the entire contents of that container. The
second form performs template type deduction to determine the type of <B>T</B>
so it can be used in the <B>copy(&#160;)</B> algorithm. That trick
wouldn&#8217;t work with the first form, so the <B>copy(&#160;)</B> algorithm is
avoided and the copying is just done by hand (this could have been done with the
second form as well, but it&#8217;s instructive to see a template-template in
use). Because of this, you never need to specify the type that you&#8217;re
printing when you call either template
function.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I83">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I84"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The default is to print to <B>cout</B>
with newlines as separators, but you can change that. You may also provide a
message to print at the head of the
output.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I84">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I85"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Next, it&#8217;s useful to have some
generators (classes with an <B>operator(&#160;)</B> that returns values of the
appropriate type) which allow a sequence to be rapidly filled with different
values.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I85">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I86"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:Generators.h</font>
<font color=#009900>// Different ways to fill sequences</font>
#ifndef GENERATORS_H
#define GENERATORS_H
#include &lt;set&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;ctime&gt;
<font color=#009900>// MS std namespace work-around</font>
#ifndef _MSC_VER
<font color=#0000ff>using</font> std::srand;
<font color=#0000ff>using</font> std::rand;
<font color=#0000ff>using</font> std::time;
<font color=#0000ff>using</font> std::strlen;
#endif

<font color=#009900>// A generator that can skip over numbers:</font>
<font color=#0000ff>class</font> SkipGen {
  <font color=#0000ff>int</font> i;
  <font color=#0000ff>int</font> skp;
<font color=#0000ff>public</font>:
  SkipGen(<font color=#0000ff>int</font> start = 0, <font color=#0000ff>int</font> skip = 1)
    : i(start), skp(skip) {}
  <font color=#0000ff>int</font> <font color=#0000ff>operator</font>()() {
    <font color=#0000ff>int</font> r = i;
    i += skp;
    <font color=#0000ff>return</font> r;
  }
};

<font color=#009900>// Generate unique random numbers from 0 to mod:</font>
<font color=#0000ff>class</font> URandGen {
  std::set&lt;<font color=#0000ff>int</font>&gt; used;
  <font color=#0000ff>int</font> modulus;
<font color=#0000ff>public</font>:
  URandGen(<font color=#0000ff>int</font> mod) : modulus(mod) { 
    srand(time(0)); 
  }
  <font color=#0000ff>int</font> <font color=#0000ff>operator</font>()() {
    <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
      <font color=#0000ff>int</font> i = (<font color=#0000ff>int</font>)rand() % modulus;
      <font color=#0000ff>if</font>(used.find(i) == used.end()) {
        used.insert(i);
        <font color=#0000ff>return</font> i;
      }
    }
  }
};

<font color=#009900>// Produces random characters:</font>
<font color=#0000ff>class</font> CharGen {
  <font color=#0000ff>static</font> <font color=#0000ff>const</font> <font color=#0000ff>char</font>* source;
  <font color=#0000ff>static</font> <font color=#0000ff>const</font> <font color=#0000ff>int</font> len;
<font color=#0000ff>public</font>:
  CharGen() { srand(time(0)); }
  <font color=#0000ff>char</font> <font color=#0000ff>operator</font>()() { 
    <font color=#0000ff>return</font> source[rand() % len];
  }
};

<font color=#009900>// Statics created here for convenience, but</font>
<font color=#009900>// will cause problems if multiply included:</font>
<font color=#0000ff>const</font> <font color=#0000ff>char</font>* CharGen::source = <font color=#004488>"ABCDEFGHIJK"</font>
  <font color=#004488>"LMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"</font>;
<font color=#0000ff>const</font> <font color=#0000ff>int</font> CharGen::len = strlen(source);
#endif <font color=#009900>// GENERATORS_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To create some interesting values, the
<B>SkipGen</B> generator skips by the value <B>skp</B> each time its
<B>operator(&#160;)</B> is called. You can initialize both the start value and
the skip value in the constructor.

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I86">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I87"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>URandGen</B> (&#8216;U&#8217; for
&#8220;unique&#8221;) is a generator for random <B>int</B>s between 0 and
<B>mod</B>, with the additional constraint that each value can only be produced
once (thus you must be careful not to use up all the values). This is easily
accomplished with a
<B>set</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I87">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I88"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>CharGen </B>generates <B>char</B>s and
can be used to fill up a <B>string</B> (when treating a <B>string</B> as a
sequence container). You&#8217;ll note that the one member function that any
generator implements is <B>operator(&#160;)</B> (with no arguments). This is
what is called by the &#8220;generate&#8221;
functions.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I88">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I89"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The use of the generators and the
<B>print(&#160;)</B> functions is shown in the following
section.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I89">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I90"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Finally, a number of the STL algorithms
that move elements of a sequence around distinguish between &#8220;stable&#8221;
and &#8220;unstable&#8221; reordering of a sequence. This refers to preserving
the original order of the elements for those elements that are equivalent but
not identical. For example, consider a sequence <B>{ c(1), b(1), c(2), a(1),
b(2), a(2) }</B>. These elements are tested for equivalence based on their
letters, but their numbers indicate how they first appeared in the sequence. If
you sort (for example) this sequence using an unstable sort, there&#8217;s no
guarantee of any particular order among equivalent letters, so you could end up
with <B>{ a(2), a(1), b(1), b(2), c(2), c(1) }</B>. However, if you used a
stable sort, it guarantees you will get <B>{ a(1), a(2), b(1), b(2), c(1), c(2)
}</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I90">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I91"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To demonstrate the stability versus
instability of algorithms that reorder a sequence, we need some way to keep
track of how the elements originally appeared. The following is a kind of
<B>string</B> object that keeps track of the order in which that particular
object originally appeared, using a <B>static map</B> that maps <B>NString</B>s
to <B>Counter</B>s. Each <B>NString</B> then contains an <B>occurrence</B> field
that indicates the order in which this <B>NString</B> was
discovered:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I91">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I92"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:NString.h</font>
<font color=#009900>// A "numbered string" that indicates which</font>
<font color=#009900>// occurrence this is of a particular word</font>
#ifndef NSTRING_H
#define NSTRING_H
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;iostream&gt;

<font color=#0000ff>class</font> NString {
  std::string s;
  <font color=#0000ff>int</font> occurrence;
  <font color=#0000ff>struct</font> Counter {
    <font color=#0000ff>int</font> i;
    Counter() : i(0) {}
    Counter&amp; <font color=#0000ff>operator</font>++(<font color=#0000ff>int</font>) { 
      i++;
      <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
    } <font color=#009900>// Post-incr</font>
    <font color=#0000ff>operator</font> <font color=#0000ff>int</font>() { <font color=#0000ff>return</font> i; }
  };
  <font color=#009900>// Keep track of the number of occurrences:</font>
  <font color=#0000ff>typedef</font> std::map&lt;std::string, Counter&gt; csmap;
  <font color=#0000ff>static</font> csmap occurMap;
<font color=#0000ff>public</font>:
  NString() : occurrence(0) {}
  NString(<font color=#0000ff>const</font> std::string&amp; x) 
    : s(x), occurrence(occurMap[s]++) {}
  NString(<font color=#0000ff>const</font> <font color=#0000ff>char</font>* x) 
    : s(x), occurrence(occurMap[s]++) {}
  <font color=#009900>// The synthesized operator= and </font>
  <font color=#009900>// copy-constructor are OK here</font>
  <font color=#0000ff>friend</font> std::ostream&amp; <font color=#0000ff>operator</font>&lt;&lt;(
    std::ostream&amp; os, <font color=#0000ff>const</font> NString&amp; ns) {
    <font color=#0000ff>return</font> os &lt;&lt; ns.s &lt;&lt; <font color=#004488>" ["</font> 
      &lt;&lt; ns.occurrence &lt;&lt; <font color=#004488>"]"</font>;
  }
  <font color=#009900>// Need this for sorting. Notice it only </font>
  <font color=#009900>// compares strings, not occurrences:</font>
  <font color=#0000ff>friend</font> <font color=#0000ff>bool</font> 
  <font color=#0000ff>operator</font>&lt;(<font color=#0000ff>const</font> NString&amp; l, <font color=#0000ff>const</font> NString&amp; r) {
    <font color=#0000ff>return</font> l.s &lt; r.s;
  }
  <font color=#009900>// For sorting with greater&lt;NString&gt;:</font>
  <font color=#0000ff>friend</font> <font color=#0000ff>bool</font> 
  <font color=#0000ff>operator</font>&gt;(<font color=#0000ff>const</font> NString&amp; l, <font color=#0000ff>const</font> NString&amp; r) {
    <font color=#0000ff>return</font> l.s &gt; r.s;
  }
  <font color=#009900>// To get at the string directly:</font>
  <font color=#0000ff>operator</font> <font color=#0000ff>const</font> std::string&amp;() <font color=#0000ff>const</font> {<font color=#0000ff>return</font> s;}
};

<font color=#009900>// Allocate static member object. Done here for</font>
<font color=#009900>// brevity, but should actually be done in a </font>
<font color=#009900>// separate cpp file:</font>
NString::csmap NString::occurMap;
#endif <font color=#009900>// NSTRING_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the constructors (one that takes a
<B>string</B>, one that takes a <B>char*</B>), the simple-looking initialization
<B>occurrence(occurMap[s]++)</B> performs all the work of maintaining and
assigning the occurrence counts (see the demonstration of the <B>map</B> class
in the previous chapter for more
details).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I92">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I93"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To do an ordinary ascending sort, the
only operator that&#8217;s necessary is <B>NString::operator&lt;(&#160;)</B>,
however to sort in reverse order the <B>operator&gt;(&#160;)</B> is also
provided so that the <B>greater</B> template can be
used.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I93">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I94"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As this is just a demonstration class I
am getting away with the convenience of putting the definition of the static
member <B>occurMap</B> in the header file, but this will break down if the
header file is included in more than one place, so you should normally relegate
all <B>static</B> definitions to <B>cpp</B>
files.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I94">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I95"></a>
</FONT><A NAME="_Toc519042065"></A><BR></P></DIV>
<A NAME="Heading256"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Filling &amp; generating</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">These algorithms allow you to
automatically fill a range with a particular value, or to generate a set of
values for a particular range (these were introduced in the previous chapter).
The &#8220;fill&#8221; functions insert a single value multiple times into the
container, while the &#8220;generate&#8221; functions use an object called a
<I>generator</I> (described earlier) to create the values to insert into the
container.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I95">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I96"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>void fill(ForwardIterator first,
ForwardIterator last, const T&amp;
value);</B></FONT><BR><FONT FACE="Georgia"><B>void fill_n(OutputIterator first,
Size n, const T&amp; value);</B></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>fill(&#160;)</B> assigns <B>value</B>
to every element in the range <B>[first, last)</B>. <B>fill_n(&#160;)</B>
assigns <B>value</B> to <B>n</B> elements starting at
<B>first</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I96">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I97"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>void generate(ForwardIterator first,
ForwardIterator last, Generator gen);</B></FONT><BR><FONT FACE="Georgia"><B>void
generate_n(OutputIterator first, Size n, Generator
gen);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I97">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I98"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>generate(&#160;)</B> makes a call to
<B>gen(&#160;)</B> for each element in the range <B>[first, last)</B>,
presumably<B> </B>to produce a different value for each element.
<B>generate_n(&#160;)</B> calls <B>gen(&#160;)</B> <B>n</B> times and assigns
each result to <B>n</B> elements starting at
<B>first</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I98">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I99"></a>
</FONT><BR></P></DIV>
<A NAME="Heading257"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Example</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example fills and generates
into <B>vector</B>s. It also shows the use of
<B>print(&#160;)</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I99">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I100"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:FillGenerateTest.cpp</font>
<font color=#009900>// Demonstrates "fill" and "generate"</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-msc}</font>
#include <font color=#004488>"Generators.h"</font>
#include <font color=#004488>"PrintSequence.h"</font>
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  vector&lt;string&gt; v1(5);
  fill(v1.begin(), v1.end(), <font color=#004488>"howdy"</font>);
  print(v1, <font color=#004488>"v1"</font>, <font color=#004488>" "</font>);
  vector&lt;string&gt; v2;
  fill_n(back_inserter(v2), 7, <font color=#004488>"bye"</font>);
  print(v2.begin(), v2.end(), <font color=#004488>"v2"</font>);
  vector&lt;<font color=#0000ff>int</font>&gt; v3(10);
  generate(v3.begin(), v3.end(), SkipGen(4,5));
  print(v3, <font color=#004488>"v3"</font>, <font color=#004488>" "</font>);
  vector&lt;<font color=#0000ff>int</font>&gt; v4;
  generate_n(back_inserter(v4),15, URandGen(30));
  print(v4, <font color=#004488>"v4"</font>, <font color=#004488>" "</font>);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>vector&lt;string&gt;</B> is created
with a pre-defined size. Since storage has already been created for all the
<B>string</B> objects in the <B>vector</B>, <B>fill(&#160;)</B> can use its
assignment operator to assign a copy of &#8220;howdy&#8221; to each space in the
<B>vector</B>. To print the result, the second form of <B>print(&#160;)</B> is
used which simply needs a container (you don&#8217;t have to give the first and
last iterators). Also, the default newline separator is replaced with a
space.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I100">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I101"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second <B>vector&lt;string&gt; v2</B>
is not given an initial size so <B>back_inserter</B> must be used to force new
elements in instead of trying to assign to existing locations. Just as an
example, the other <B>print(&#160;)</B> is used which requires a
range.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I101">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I102"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>generate(&#160;)</B> and
<B>generate_n(&#160;)</B> functions have the same form as the &#8220;fill&#8221;
functions except that they use a generator instead of a constant value; here,
both generators are
demonstrated.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I102">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I103"></a>
</FONT><A NAME="_Toc519042066"></A><BR></P></DIV>
<A NAME="Heading258"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Counting</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All containers have a method
<B>size(&#160;)</B> that will tell you how many elements they hold. The
following two algorithms count objects only if they satisfy certain
criteria.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I103">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I104"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>IntegralValue count(InputIterator
first, InputIterator last, </B></FONT><BR><FONT FACE="Georgia"><B>    const
EqualityComparable&amp;
value);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I104">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I105"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Produces the number of elements in
<B>[first, last)</B> that are equivalent to <B>value</B> (when tested using
<B>operator==</B>).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I105">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I106"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>IntegralValue count_if(InputIterator
first, InputIterator last, Predicate
pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I106">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I107"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Produces the number of elements<B> </B>in
<B>[first, last)</B> which each cause <B>pred</B> to return
<B>true</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I107">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I108"></a>
</FONT><BR></P></DIV>
<A NAME="Heading259"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Example</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here, a <B>vector&lt;char&gt; v</B> is<B>
</B>filled with random characters (including some duplicates). A
<B>set&lt;char&gt;</B> is initialized from <B>v</B>, so it holds only one of
each letter represented in <B>v</B>. This <B>set</B> is used to count all the
instances of all the different characters, which are then
displayed:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I108">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I109"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:Counting.cpp</font>
<font color=#009900>// The counting algorithms</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-g++295}</font>
<font color=#009900>//{-msc}</font>
#include <font color=#004488>"PrintSequence.h"</font>
#include <font color=#004488>"Generators.h"</font>
#include &lt;vector&gt;
#include &lt;algorithm&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  vector&lt;<font color=#0000ff>char</font>&gt; v;
  generate_n(back_inserter(v), 50, CharGen());
  print(v, <font color=#004488>"v"</font>, <font color=#004488>""</font>);
  <font color=#009900>// Create a set of the characters in v:</font>
  set&lt;<font color=#0000ff>char</font>&gt; cs(v.begin(), v.end());
  set&lt;<font color=#0000ff>char</font>&gt;::iterator it = cs.begin();
  <font color=#0000ff>while</font>(it != cs.end()) {
    <font color=#0000ff>int</font> n = count(v.begin(), v.end(), *it);
    cout &lt;&lt; *it &lt;&lt; <font color=#004488>": "</font> &lt;&lt; n &lt;&lt; <font color=#004488>", "</font>;
    it++;
  }
  <font color=#0000ff>int</font> lc = count_if(v.begin(), v.end(), 
    bind2nd(greater&lt;<font color=#0000ff>char</font>&gt;(), 'a'));
  cout &lt;&lt; <font color=#004488>"\nLowercase letters: "</font> &lt;&lt; lc &lt;&lt; endl;
  sort(v.begin(), v.end());
  print(v, <font color=#004488>"sorted"</font>, <font color=#004488>""</font>);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>count_if(&#160;)</B> algorithm is
demonstrated by counting all the lowercase letters; the predicate is created
using the <B>bind2nd(&#160;)</B> and <B>greater</B> function object
templates.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I109">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I110"></a>
</FONT><A NAME="_Toc519042067"></A><BR></P></DIV>
<A NAME="Heading260"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Manipulating sequences</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">These algorithms allow you to move
sequences around.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I110">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I111"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>OutputIterator copy(InputIterator,
first InputIterator last, OutputIterator
destination);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I111">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I112"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Using assignment, copies from <B>[first,
last)</B> to <B>destination</B>, incrementing <B>destination</B> after each
assignment. Works with almost any type of source range and almost any kind of
destination. Because assignment is used, you cannot directly insert elements
into an empty container or at the end of a container, but instead you must wrap
the <B>destination</B> iterator in an <B>insert_iterator</B> (typically by using
<B>back_inserter(&#160;)</B>, or <B>inserter(&#160;)</B> in the case of an
associative container).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I112">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I113"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The copy algorithm is used in many
examples in this book.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I113">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I114"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>BidirectionalIterator2
copy_backward(BidirectionalIterator1 first,
</B></FONT><BR><FONT FACE="Georgia"><B>    BidirectionalIterator1 last,
BidirectionalIterator2
destinationEnd);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I114">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I115"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Like <B>copy(&#160;)</B>, but performs
the actual copying of the elements in reverse order. That is, the resulting
sequence is the same, it&#8217;s just that the copy happens in a different way.
The source range <B>[first, last)</B> is copied to the destination, but the
first destination element is <B>destinationEnd - 1</B>. This iterator is then
decremented after each assignment. The space in the destination range must
already exist (to allow assignment), and the destination range cannot be within
the source range.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I115">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I116"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>void reverse(BidirectionalIterator
first, BidirectionalIterator
last);</B></FONT><BR><FONT FACE="Georgia"><B>OutputIterator
reverse_copy(BidirectionalIterator first, BidirectionalIterator
last,</B></FONT><BR><FONT FACE="Georgia"><B>    OutputIterator
destination);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I116">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I117"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Both forms of this function reverse the
range <B>[first, last)</B>. <B>reverse(&#160;)</B> reverses the range in place,
while <B>reverse_copy(&#160;)</B> leaves the original range alone and copies the
reversed elements into <B>destination</B>, returning the past-the-end iterator
of the resulting range. 
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I117">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I118"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ForwardIterator2
swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,
</B></FONT><BR><FONT FACE="Georgia"><B>    ForwardIterator2
first2);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I118">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I119"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Exchanges the contents of two ranges of
equal size, by moving from the beginning to the end of each range and swapping
each set of elements.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I119">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I120"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><B>void rotate(ForwardIterator first, ForwardIterator middle,
ForwardIterator last);</B><BR><B>OutputIterator rotate_copy(ForwardIterator
first, ForwardIterator middle,</B><BR><B>    ForwardIterator last,
OutputIterator destination);</B><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Swaps the two ranges <B>[first,
middle)</B> and <B>[middle, last)</B>. With <B>rotate(&#160;)</B>, the swap is
performed in place, and with <B>rotate_copy(&#160;)</B> the original range is
untouched and the rotated version is copied into <B>destination</B>, returning
the past-the-end iterator of the resulting range. Note that while
<B>swap_ranges(&#160;)</B> requires that the two ranges be exactly the same
size, the &#8220;rotate&#8221; functions do
not.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I120">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I121"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>bool
next_permutation(BidirectionalIterator first, BidirectionalIterator
last);</B></FONT><BR><FONT FACE="Georgia"><B>bool
next_permutation(BidirectionalIterator first, BidirectionalIterator
last,</B></FONT><BR><FONT FACE="Georgia"><B>    StrictWeakOrdering
binary_pred);</B></FONT><BR><FONT FACE="Georgia"><B>bool
prev_permutation(BidirectionalIterator first, BidirectionalIterator
last);</B></FONT><BR><FONT FACE="Georgia"><B>bool
prev_permutation(BidirectionalIterator first, BidirectionalIterator
last,</B></FONT><BR><FONT FACE="Georgia"><B>    StrictWeakOrdering
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I121">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I122"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <I>permutation</I> is one unique
ordering of a set of elements. If you have <B>n</B> unique elements, then there
are <B>n!</B> (<B>n</B> factorial) distinct possible combinations of those
elements. All these combinations can be conceptually sorted into a sequence
using a lexicographical ordering, and thus produce a concept of a
&#8220;next&#8221; and &#8220;previous&#8221; permutation. Therefore, whatever
the current ordering of elements in the range, there is a distinct
&#8220;next&#8221; and &#8220;previous&#8221; permutation in the sequence of
permutations.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I122">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I123"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>next_permutation(&#160;)</B> and
<B>prev_permutation(&#160;)</B> functions re-arrange the elements into their
next or previous permutation, and if successful return <B>true</B>. If there are
no more &#8220;next&#8221; permutations, it means that the elements are in
sorted order so <B>next_permutation(&#160;)</B> returns <B>false</B>. If there
are no more &#8220;previous&#8221; permutations, it means that the elements are
in descending sorted order so <B>previous_permutation(&#160;)</B> returns
<B>false</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I123">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I124"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The versions of the functions which have
a <B>StrictWeakOrdering</B> argument perform the comparisons using
<B>binary_pred</B> instead of
<B>operator&lt;</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I124">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I125"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>void
random_shuffle(RandomAccessIterator first, RandomAccessIterator
last);</B></FONT><BR><FONT FACE="Georgia"><B>void
random_shuffle(RandomAccessIterator first, RandomAccessIterator
last</B></FONT><BR><FONT FACE="Georgia"><B>    RandomNumberGenerator&amp;
rand);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I125">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I126"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This function randomly rearranges the
elements in the range. It yields uniformly distributed results. The first form
uses an internal random number generator and the second uses a user-supplied
random-number generator.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I126">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I127"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>BidirectionalIterator
partition(BidirectionalIterator first, BidirectionalIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    Predicate
pred);</B></FONT><BR><FONT FACE="Georgia"><B>BidirectionalIterator
stable_partition(BidirectionalIterator first,
</B></FONT><BR><FONT FACE="Georgia"><B>  BidirectionalIterator last, Predicate
pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I127">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I128"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The &#8220;partition&#8221; functions use
<B>pred</B> to organize the elements in the range <B>[first, last)</B> so they
are before or after the partition (a point in the range). The partition point is
given by the returned iterator. If <B>pred(*i)</B> is <B>true</B> (where
<B>i</B> is the iterator pointing to a particular element), then that element
will be placed before the partition point, otherwise it will be placed after the
partition point.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I128">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I129"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">With <B>partition(&#160;)</B>, the order
of the elements is after the function call is not specified, but with
<B>stable_parition(&#160;)</B> the relative order of the elements before and
after the partition point will be the same as before the partitioning
process.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I129">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I130"></a>
</FONT><BR></P></DIV>
<A NAME="Heading261"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Example</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This gives a basic demonstration of
sequence manipulation:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I130">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I131"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:Manipulations.cpp</font>
<font color=#009900>// Shows basic manipulations</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-g++295}</font>
<font color=#009900>//{-msc}</font>
#include <font color=#004488>"PrintSequence.h"</font>
#include <font color=#004488>"NString.h"</font>
#include <font color=#004488>"Generators.h"</font>
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  vector&lt;<font color=#0000ff>int</font>&gt; v1(10);
  <font color=#009900>// Simple counting:</font>
  generate(v1.begin(), v1.end(), SkipGen());
  print(v1, <font color=#004488>"v1"</font>, <font color=#004488>" "</font>);
  vector&lt;<font color=#0000ff>int</font>&gt; v2(v1.size());
  copy_backward(v1.begin(), v1.end(), v2.end());
  print(v2, <font color=#004488>"copy_backward"</font>, <font color=#004488>" "</font>);
  reverse_copy(v1.begin(), v1.end(), v2.begin());
  print(v2, <font color=#004488>"reverse_copy"</font>, <font color=#004488>" "</font>);
  reverse(v1.begin(), v1.end());
  print(v1, <font color=#004488>"reverse"</font>, <font color=#004488>" "</font>);
  <font color=#0000ff>int</font> half = v1.size() / 2;
  <font color=#009900>// Ranges must be exactly the same size:</font>
  swap_ranges(v1.begin(), v1.begin() + half,
    v1.begin() + half);
  print(v1, <font color=#004488>"swap_ranges"</font>, <font color=#004488>" "</font>);
  <font color=#009900>// Start with fresh sequence:</font>
  generate(v1.begin(), v1.end(), SkipGen());
  print(v1, <font color=#004488>"v1"</font>, <font color=#004488>" "</font>);
  <font color=#0000ff>int</font> third = v1.size() / 3;
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++) {
    rotate(v1.begin(), v1.begin() + third, 
      v1.end());
    print(v1, <font color=#004488>"rotate"</font>, <font color=#004488>" "</font>);
  }
  cout &lt;&lt; <font color=#004488>"Second rotate example:"</font> &lt;&lt; endl;
  <font color=#0000ff>char</font> c[] = <font color=#004488>"aabbccddeeffgghhiijj"</font>;
  <font color=#0000ff>const</font> <font color=#0000ff>char</font> csz = strlen(c);
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++) {
    rotate(c, c + 2, c + csz);
    print(c, c + csz, <font color=#004488>""</font>, <font color=#004488>""</font>);
  }
  cout &lt;&lt; <font color=#004488>"All n! permutations of abcd:"</font> &lt;&lt; endl;
  <font color=#0000ff>int</font> nf = 4 * 3 * 2 * 1;
  <font color=#0000ff>char</font> p[] = <font color=#004488>"abcd"</font>;
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; nf; i++) {
    next_permutation(p, p + 4);
    print(p, p + 4, <font color=#004488>""</font>, <font color=#004488>""</font>);
  }
  cout &lt;&lt; <font color=#004488>"Using prev_permutation:"</font> &lt;&lt; endl;
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; nf; i++) {
    prev_permutation(p, p + 4);
    print(p, p + 4, <font color=#004488>""</font>, <font color=#004488>""</font>);
  }
  cout &lt;&lt; <font color=#004488>"random_shuffling a word:"</font> &lt;&lt; endl;
  string s(<font color=#004488>"hello"</font>);
  cout &lt;&lt; s &lt;&lt; endl;
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 5; i++) {
    random_shuffle(s.begin(), s.end());
    cout &lt;&lt; s &lt;&lt; endl;
  }
  NString sa[] = { <font color=#004488>"a"</font>, <font color=#004488>"b"</font>, <font color=#004488>"c"</font>, <font color=#004488>"d"</font>, <font color=#004488>"a"</font>, <font color=#004488>"b"</font>,
    <font color=#004488>"c"</font>, <font color=#004488>"d"</font>, <font color=#004488>"a"</font>, <font color=#004488>"b"</font>, <font color=#004488>"c"</font>, <font color=#004488>"d"</font>, <font color=#004488>"a"</font>, <font color=#004488>"b"</font>, <font color=#004488>"c"</font>};
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> sasz = <font color=#0000ff>sizeof</font> sa / <font color=#0000ff>sizeof</font> *sa;
  vector&lt;NString&gt; ns(sa, sa + sasz);
  print(ns, <font color=#004488>"ns"</font>, <font color=#004488>" "</font>);
  vector&lt;NString&gt;::iterator it = 
    partition(ns.begin(), ns.end(), 
      bind2nd(greater&lt;NString&gt;(), <font color=#004488>"b"</font>));
  cout &lt;&lt; <font color=#004488>"Partition point: "</font> &lt;&lt; *it &lt;&lt; endl;
  print(ns, <font color=#004488>""</font>, <font color=#004488>" "</font>);
  <font color=#009900>// Reload vector:</font>
  copy (sa, sa + sasz, ns.begin());
  it = stable_partition(ns.begin(), ns.end(),
    bind2nd(greater&lt;NString&gt;(), <font color=#004488>"b"</font>));
  cout &lt;&lt; <font color=#004488>"Stable partition"</font> &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"Partition point: "</font> &lt;&lt; *it &lt;&lt; endl;
  print(ns, <font color=#004488>""</font>, <font color=#004488>" "</font>);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The best way to see the results of the
above program is to run it (you&#8217;ll probably want to redirect the output to
a file).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I131">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I132"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>vector&lt;int&gt; v1</B> is
initially loaded with a simple ascending sequence and printed. You&#8217;ll see
that the effect of <B>copy_backward(&#160;)</B> (which copies into <B>v2</B>,
which is the same size as <B>v1</B>) is the same as an ordinary copy. Again,
<B>copy_backward(&#160;)</B> does the same thing as <B>copy(&#160;)</B>, it just
performs the operations in backward
order.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I132">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I133"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>reverse_copy(&#160;)</B>, however,
actually does created a reversed copy, while <B>reverse(&#160;)</B> performs the
reversal in place. Next, <B>swap_ranges(&#160;)</B> swaps the upper half of the
reversed sequence with the lower half. Of course, the ranges could be smaller
subsets of the entire vector, as long as they are of equivalent
size.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I133">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I134"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">After re-creating the ascending sequence,
<B>rotate(&#160;)</B> is demonstrated by rotating one third of <B>v1</B>
multiple times. A second <B>rotate(&#160;)</B> example uses characters and just
rotates two characters at a time. This also demonstrates the flexibility of both
the STL algorithms and the <B>print(&#160;)</B> template, since they can both be
used with arrays of <B>char</B> as easily as with anything
else.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I134">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I135"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To demonstrate
<B>next_permutation(&#160;)</B> and <B>prev_permutation(&#160;)</B>, a set of
four characters &#8220;abcd&#8221; is permuted through all <B>n!</B> (<B>n</B>
factorial) possible combinations. You&#8217;ll see from the output that the
permutations move through a strictly-defined order (that is, permuting is a
deterministic process).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I135">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I136"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A quick-and-dirty demonstration of
<B>random_shuffle(&#160;)</B> is to apply it to a <B>string</B> and see what
words result. Because a <B>string</B> object has <B>begin(&#160;)</B> and
<B>end(&#160;)</B> member functions that return the appropriate iterators, it
too may be easily used with many of the STL algorithms. Of course, an array of
<B>char</B> could also have been
used.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I136">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I137"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Finally, the <B>partition(&#160;)</B> and
<B>stable_partition(&#160;)</B> are demonstrated, using an array of
<B>NString</B>. You&#8217;ll note that the aggregate initialization expression
uses <B>char</B> arrays, but <B>NString</B> has a <B>char*</B> constructor which
is automatically used.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I137">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I138"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When partitioning a sequence, you need a
predicate which will determine whether the object belongs above or below the
partition point. This takes a single argument and returns <B>true</B> (the
object is above the partition point) or <B>false</B> (it isn&#8217;t). I could
have written a separate function or function object to do this, but for
something simple, like &#8220;the object is greater than &#8216;b&#8217;&#8221;,
why not use the built-in function object templates? The expression
is:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I138">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I139"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>bind2nd(greater&lt;NString&gt;(), <font color=#004488>"b"</font>)</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">And to understand it, you need to pick it
apart from the middle outward.
First,
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I139">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I140"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>greater&lt;NString&gt;()</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">produces a binary function object which
compares its first and second
arguments:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I140">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I141"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>return</font> first &gt; second;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">and returns a <B>bool</B>. But we
don&#8217;t want a binary predicate, and we want to compare against the constant
value &#8220;<B>b</B>.&#8221; So <B>bind2nd(&#160;)</B> says: create a new
function object which only takes one argument, by taking this
<B>greater&lt;NString&gt;(&#160;)</B> function and forcing the second argument
to always be &#8220;<B>b</B>.&#8221; The first argument (the only argument) will
be the one from the vector
<B>ns</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I141">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I142"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll see from the output that
with the unstable partition, the objects are correctly above and below the
partition point, but in no particular order, whereas with the stable partition
their original order is
maintained.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I142">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I143"></a>
</FONT><A NAME="_Toc519042068"></A><BR></P></DIV>
<A NAME="Heading262"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Searching &amp; replacing</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All of these algorithms are used for
searching for one or more objects within a range defined by the first two
iterator arguments.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I143">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I144"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><B>InputIterator find(InputIterator first, InputIterator
last,</B><BR><B>    const EqualityComparable&amp; value);</B><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Searches for <B>value </B>within a range
of elements. Returns an iterator in the range <B>[first, last)</B> that points
to the first occurrence of <B>value</B>. If <B>value</B> isn&#8217;t in the
range, then <B>find(&#160;)</B> returns <B>last</B>. This is a <I>linear
search</I>, that is, it starts at the beginning and looks at each sequential
element without making any assumptions about the way the elements are ordered.
In contrast, a <B>binary_search(&#160;)</B> (defined later) works on a sorted
sequence and can thus be much
faster.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I144">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I145"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><B>InputIterator find_if(InputIterator first, InputIterator
last, Predicate pred);</B><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Just like <B>find(&#160;)</B>,
<B>find_if(&#160;)</B> performs a linear search through the range. However,
instead of searching for <B>value</B>, <B>find_if(&#160;)</B> looks for an
element such that the <B>Predicate pred</B> returns <B>true</B> when applied to
that element. Returns <B>last</B> if no such element can be
found.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I145">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I146"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ForwardIterator
adjacent_find(ForwardIterator first, ForwardIterator
last);</B></FONT><BR><FONT FACE="Georgia"><B>ForwardIterator
adjacent_find(ForwardIterator first, ForwardIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    BinaryPredicate
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I146">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I147"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Like <B>find(&#160;)</B>, performs a
linear search through the range, but instead of looking for only one element it
searches for two elements that are right next to each other. The first form of
the function looks for two elements that are equivalent (via <B>operator==</B>).
The second form looks for two adjacent elements that, when passed together to
<B>binary_pred</B>, produce a <B>true</B> result. If two adjacent elements
cannot be found, <B>last</B> is
returned.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I147">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I148"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ForwardIterator1
find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,
</B></FONT><BR><FONT FACE="Georgia"><B>    ForwardIterator2 first2,
ForwardIterator2 last2);</B></FONT><BR><FONT FACE="Georgia"><B>ForwardIterator1
find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,
</B></FONT><BR><FONT FACE="Georgia"><B>    ForwardIterator2 first2,
ForwardIterator2 last2, BinaryPredicate binary_pred);
</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I148">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I149"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Like <B>find(&#160;)</B>, performs a
linear search through the range. The first form finds the first element in the
first range that is equivalent to any of the elements in the second range. The
second form finds the first element in the first range that produces <B>true</B>
when passed to <B>binary_pred</B> along with any of the elements in the second
range. When a <B>BinaryPredicate</B> is used with two ranges in the algorithms,
the element from the first range becomes the first argument to
<B>binary_pred</B>, and the element from the second range becomes the second
argument.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I149">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I150"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ForwardIterator1
search(ForwardIterator1 first1, ForwardIterator1 last1,
</B></FONT><BR><FONT FACE="Georgia"><B>    ForwardIterator2 first2,
ForwardIterator2 last2);</B></FONT><BR><FONT FACE="Georgia"><B>ForwardIterator1
search(ForwardIterator1 first1, ForwardIterator1 last1,
</B></FONT><BR><FONT FACE="Georgia"><B>    ForwardIterator2 first2,
ForwardIterator2 last2 BinaryPredicate
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I150">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I151"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Attempts to find the entire range
<B>[first2, last2)</B> within the range <B>[first1, last1)</B>. That is, it
checks to see if the second range occurs (in the exact order of the second
range) within the first range, and if so returns an iterator pointing to the
place in the first range where the second range begins. Returns <B>last1</B> if
no subset can be found. The first form performs its test using
<B>operator==</B>, while the second checks to see if each pair of objects being
compared causes <B>binary_pred</B> to return
<B>true</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I151">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I152"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ForwardIterator1
find_end(ForwardIterator1 first1, ForwardIterator1
last1,</B></FONT><BR><FONT FACE="Georgia"><B>    ForwardIterator2 first2,
ForwardIterator2 last2);</B></FONT><BR><FONT FACE="Georgia"><B>ForwardIterator1
find_end(ForwardIterator1 first1, ForwardIterator1
last1,</B></FONT><BR><FONT FACE="Georgia"><B>    ForwardIterator2 first2,
ForwardIterator2 last2, BinaryPredicate
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I152">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I153"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The forms and arguments are just like
<B>search(&#160;)</B> in that it looks for the second range within the first
range, but while <B>search(&#160;)</B> looks for the first occurrence of the
second range, <B>find_end(&#160;)</B> looks for the <I>last</I> occurrence of
the second range within the
first.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I153">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I154"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ForwardIterator
search_n(ForwardIterator first, ForwardIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    Size count, const T&amp;
value);</B></FONT><BR><FONT FACE="Georgia"><B>ForwardIterator
search_n(ForwardIterator first, ForwardIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    Size count, const T&amp; value,
BinaryPredicate
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I154">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I155"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Looks for a group of <B>count</B>
consecutive values in <B>[first, last)</B> that are all equal to <B>value</B>
(in the first form) or that all cause a return value of <B>true</B> when passed
into <B>binary_pred</B> along with <B>value</B> (in the second form). Returns
<B>last</B> if such a group cannot be
found.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I155">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I156"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ForwardIterator
min_element(ForwardIterator first, ForwardIterator
last);</B></FONT><BR><FONT FACE="Georgia"><B>ForwardIterator
min_element(ForwardIterator first, ForwardIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B> BinaryPredicate
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I156">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I157"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Returns an iterator pointing to the first
occurrence of the smallest value in the range (there may be multiple occurrences
of the smallest value). Returns <B>last</B> if the range is empty. The first
version performs comparisons with <B>operator&lt;</B> and the value <B>r </B>
returned is such that </FONT><BR><FONT FACE="Georgia">*<B>e &lt; *r</B>
</FONT><BR><FONT FACE="Georgia">is false for every element <B>e</B> in the
range. The second version compares using <B>binary_pred</B> and the value
<B>r</B> returned is such that <B>binary_pred (*e, *r)</B> is false for every
element <B>e</B> in the
range.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I157">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I158"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ForwardIterator
max_element(ForwardIterator first, ForwardIterator
last);</B></FONT><BR><FONT FACE="Georgia"><B>ForwardIterator
max_element(ForwardIterator first, ForwardIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B> BinaryPredicate
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I158">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I159"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Returns an iterator pointing to the first
occurrence of the largest value in the range (there may be multiple occurrences
of the largest value). Returns <B>last</B> if the range is empty. The first
version performs comparisons with <B>operator&lt;</B> and the value <B>r </B>
returned is such that </FONT><BR><FONT FACE="Georgia">*<B>r &lt; *e</B>
</FONT><BR><FONT FACE="Georgia">is false for every element <B>e</B> in the
range. The second version compares using <B>binary_pred</B> and the value
<B>r</B> returned is such that <B>binary_pred (*r, *e)</B> is false for every
element <B>e</B> in the
range.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I159">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I160"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>void replace(ForwardIterator first,
ForwardIterator last, </B></FONT><BR><FONT FACE="Georgia"><B>    const T&amp;
old_value, const T&amp; new_value);</B></FONT><BR><FONT FACE="Georgia"><B>void
replace_if(ForwardIterator first, ForwardIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    Predicate pred, const T&amp;
new_value);</B></FONT><BR><FONT FACE="Georgia"><B>OutputIterator
replace_copy(InputIterator first, InputIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    OutputIterator result, const T&amp;
old_value, const T&amp;
new_value);</B></FONT><BR><FONT FACE="Georgia"><B>OutputIterator
replace_copy_if(InputIterator first, InputIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    OutputIterator result, Predicate
pred, const T&amp;
new_value);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I160">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I161"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each of the &#8220;replace&#8221; forms
moves through the range <B>[first, last)</B>, finding values that match a
criterion and replacing them with <B>new_value</B>. Both <B>replace(&#160;)</B>
and <B>replace_copy(&#160;)</B> simply look for <B>old_value</B> to replace,
while <B>replace_if(&#160;)</B> and <B>replace_copy_if(&#160;)</B> look for
values that satisfy the predicate <B>pred</B>. The &#8220;copy&#8221; versions
of the functions do not modify the original range but instead make a copy with
the replacements into <B>result</B> (incrementing <B>result</B> after each
assignment).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I161">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I162"></a>
</FONT><BR></P></DIV>
<A NAME="Heading263"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Example</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To provide easy viewing of the results,
this example will manipulate <B>vector</B>s of <B>int</B>. Again, not every
possible version of each algorithm will be shown (some that should be obvious
have been omitted).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I162">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I163"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:SearchReplace.cpp</font>
<font color=#009900>// The STL search and replace algorithms</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-g++295}</font>
<font color=#009900>//{-msc}</font>
#include <font color=#004488>"PrintSequence.h"</font>
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>struct</font> PlusOne {
  <font color=#0000ff>bool</font> <font color=#0000ff>operator</font>()(<font color=#0000ff>int</font> i, <font color=#0000ff>int</font> j) {
    <font color=#0000ff>return</font> j == i + 1;
  }
};

<font color=#0000ff>class</font> MulMoreThan {
  <font color=#0000ff>int</font> value;
<font color=#0000ff>public</font>:
  MulMoreThan(<font color=#0000ff>int</font> val) : value(val) {}
  <font color=#0000ff>bool</font> <font color=#0000ff>operator</font>()(<font color=#0000ff>int</font> v, <font color=#0000ff>int</font> m) {
    <font color=#0000ff>return</font> v * m &gt; value;
  }
};

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> a[] = { 1, 2, 3, 4, 5, 6, 6, 7, 7, 7,
    8, 8, 8, 8, 11, 11, 11, 11, 11 };
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> asz = <font color=#0000ff>sizeof</font> a / <font color=#0000ff>sizeof</font> *a;
  vector&lt;<font color=#0000ff>int</font>&gt; v(a, a + asz);
  print(v, <font color=#004488>"v"</font>, <font color=#004488>" "</font>);
  vector&lt;<font color=#0000ff>int</font>&gt;::iterator it =
    find(v.begin(), v.end(), 4);
  cout &lt;&lt; <font color=#004488>"find: "</font> &lt;&lt; *it &lt;&lt; endl;
  it = find_if(v.begin(), v.end(), 
    bind2nd(greater&lt;<font color=#0000ff>int</font>&gt;(), 8));
  cout &lt;&lt; <font color=#004488>"find_if: "</font> &lt;&lt; *it &lt;&lt; endl;
  it = adjacent_find(v.begin(), v.end());
  <font color=#0000ff>while</font>(it != v.end()) {
    cout &lt;&lt; <font color=#004488>"adjacent_find: "</font> &lt;&lt; *it 
      &lt;&lt; <font color=#004488>", "</font> &lt;&lt; *(it + 1) &lt;&lt; endl;
    it = adjacent_find(it + 2, v.end());
  }
  it = adjacent_find(v.begin(), v.end(), 
    PlusOne());
  <font color=#0000ff>while</font>(it != v.end()) {
    cout &lt;&lt; <font color=#004488>"adjacent_find PlusOne: "</font> &lt;&lt; *it
      &lt;&lt; <font color=#004488>", "</font> &lt;&lt; *(it + 1) &lt;&lt; endl;
    it = adjacent_find(it + 1, v.end(), 
      PlusOne());
  }
  <font color=#0000ff>int</font> b[] = { 8, 11 };
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> bsz = <font color=#0000ff>sizeof</font> b / <font color=#0000ff>sizeof</font> *b;
  print(b, b + bsz, <font color=#004488>"b"</font>, <font color=#004488>" "</font>);
  it = find_first_of(v.begin(), v.end(),
    b, b + bsz);
  print(it, it + bsz, <font color=#004488>"find_first_of"</font>, <font color=#004488>" "</font>);
  it = find_first_of(v.begin(), v.end(), 
    b, b + bsz, PlusOne());
  print(it,it + bsz,<font color=#004488>"find_first_of PlusOne"</font>,<font color=#004488>" "</font>);
  it = search(v.begin(), v.end(), b, b + bsz);
  print(it, it + bsz, <font color=#004488>"search"</font>, <font color=#004488>" "</font>);
  <font color=#0000ff>int</font> c[] = { 5, 6, 7 };
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> csz = <font color=#0000ff>sizeof</font> c / <font color=#0000ff>sizeof</font> *c;
  print(c, c + csz, <font color=#004488>"c"</font>, <font color=#004488>" "</font>);
  it = search(v.begin(), v.end(), 
    c, c + csz, PlusOne());
  print(it, it + csz,<font color=#004488>"search PlusOne"</font>, <font color=#004488>" "</font>);
  <font color=#0000ff>int</font> d[] = { 11, 11, 11 };
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> dsz = <font color=#0000ff>sizeof</font> d / <font color=#0000ff>sizeof</font> *d;
  print(d, d + dsz, <font color=#004488>"d"</font>, <font color=#004488>" "</font>);
  it = find_end(v.begin(), v.end(), d, d + dsz);
  print(it, v.end(),<font color=#004488>"find_end"</font>, <font color=#004488>" "</font>);
  <font color=#0000ff>int</font> e[] = { 9, 9 };
  print(e, e + 2, <font color=#004488>"e"</font>, <font color=#004488>" "</font>);
  it = find_end(v.begin(), v.end(), 
    e, e + 2, PlusOne());
  print(it, v.end(),<font color=#004488>"find_end PlusOne"</font>,<font color=#004488>" "</font>);
  it = search_n(v.begin(), v.end(), 3, 7);
  print(it, it + 3, <font color=#004488>"search_n 3, 7"</font>, <font color=#004488>" "</font>);
  it = search_n(v.begin(), v.end(), 
    6, 15, MulMoreThan(100));
  print(it, it + 6, 
    <font color=#004488>"search_n 6, 15, MulMoreThan(100)"</font>, <font color=#004488>" "</font>);
  cout &lt;&lt; <font color=#004488>"min_element: "</font> &lt;&lt;
    *min_element(v.begin(), v.end()) &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"max_element: "</font> &lt;&lt;
    *max_element(v.begin(), v.end()) &lt;&lt; endl;
  vector&lt;<font color=#0000ff>int</font>&gt; v2;
  replace_copy(v.begin(), v.end(), 
    back_inserter(v2), 8, 47);
  print(v2, <font color=#004488>"replace_copy 8 -&gt; 47"</font>, <font color=#004488>" "</font>);
  replace_if(v.begin(), v.end(), 
    bind2nd(greater_equal&lt;<font color=#0000ff>int</font>&gt;(), 7), -1);
  print(v, <font color=#004488>"replace_if &gt;= 7 -&gt; -1"</font>, <font color=#004488>" "</font>);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The example begins with two predicates:
<B>PlusOne</B> which is a binary predicate that returns <B>true</B> if the
second argument is equivalent to one plus the first argument, and
<B>MulMoreThan</B> which returns <B>true</B> if the first argument times the
second argument is greater than a value stored in the object. These binary
predicates are used as tests in the
example.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I163">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I164"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>main(&#160;)</B>, an array <B>a</B>
is created and fed to the constructor for <B>vector&lt;int&gt; v</B>. This
vector will be used as the target for the search and replace activities, and
you&#8217;ll note that there are duplicate elements &#8211; these will be
discovered by some of the search/replace
routines.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I164">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I165"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first test demonstrates
<B>find(&#160;)</B>, discovering the value 4 in <B>v</B>. The return value is
the iterator pointing to the first instance of 4, or the end of the input range
(<B>v.end(&#160;)</B>) if the search value is not
found.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I165">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I166"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>find_if(&#160;)</B> uses a predicate
to determine if it has discovered the correct element. In the above example,
this predicate is created on the fly using <B>greater&lt;int&gt;</B> (that is,
&#8220;see if the first <B>int </B>argument is greater than the second&#8221;)
and <B>bind2nd(&#160;)</B> to fix the second argument to 8. Thus, it returns
true if the value in <B>v</B> is greater than
8.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I166">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I167"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since there are a number of cases in
<B>v</B> where two identical objects appear next to each other, the test of
<B>adjacent_find(&#160;)</B> is designed to find them all. It starts looking
from the beginning and then drops into a <B>while</B> loop, making sure that the
iterator <B>it</B> has not reached the end of the input sequence (which would
mean that no more matches can be found). For each match it finds, the loop
prints out the matches and then performs the next <B>adjacent_find(&#160;)</B>,
this time using <B>it + 2</B> as the first argument (this way, it moves past the
two elements that it already
found).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I167">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I168"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You might look at the <B>while</B> loop
and think that you can do it a bit more cleverly, to
wit:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I168">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I169"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>  <font color=#0000ff>while</font>(it != v.end()) {
    cout &lt;&lt; <font color=#004488>"adjacent_find: "</font> &lt;&lt; *it++
      &lt;&lt; <font color=#004488>", "</font> &lt;&lt; *it++ &lt;&lt; endl;
    it = adjacent_find(it, v.end());
  }</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, this is exactly what I tried
at first. However, I did not get the output I expected, on any compiler. This is
because there is no guarantee about when the increments occur in the above
expression. A bit of a disturbing discovery, I know, but the situation is best
avoided now that you&#8217;re aware of
it.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I169">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I170"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The next test uses
<B>adjacent_find(&#160;)</B> with the <B>PlusOne</B> predicate, which discovers
all the places where the next number in the sequence <B>v</B> changes from the
previous by one. The same <B>while</B> approach is used to find all the
cases.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I170">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I171"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>find_first_of(&#160;)</B> requires a
second range of objects for which to hunt; this is provided in the array
<B>b</B>. Notice that, because the first range and the second range in
<B>find_first_of(&#160;)</B> are controlled by separate template arguments,
those ranges can refer to two different types of containers, as seen here. The
second form of <B>find_first_of(&#160;)</B> is also tested, using
<B>PlusOne</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I171">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I172"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>search(&#160;)</B> finds exactly the
second range inside the first one, with the elements in the same order. The
second form of <B>search(&#160;)</B> uses a predicate, which is typically just
something that defines equivalence, but it also opens some interesting
possibilities &#8211; here, the <B>PlusOne</B> predicate causes the range <B>{
4, 5, 6 }</B> to be
found.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I172">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I173"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>find_end(&#160;)</B> test
discovers the <I>last</I> occurrence of the entire sequence <B>{ 11, 11, 11
}</B>. To show that it has in fact found the last occurrence, the rest of
<B>v</B> starting from <B>it</B> is
printed.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I173">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I174"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first <B>search_n(&#160;)</B> test
looks for 3 copies of the value 7, which it finds and prints. When using the
second version of <B>search_n(&#160;)</B>, the predicate is ordinarily meant to
be used to determine equivalence between two elements, but I&#8217;ve taken some
liberties and used a function object that multiplies the value in the sequence
by (in this case) 15 and checks to see if it&#8217;s greater than 100. That is,
the <B>search_n(&#160;)</B> test above says &#8220;find me 6 consecutive values
which, when multiplied by 15, each produce a number greater than 100.&#8221; Not
exactly what you normally expect to do, but it might give you some ideas the
next time you have an odd searching
problem.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I174">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I175"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>min_element(&#160;)</B> and
<B>max_element(&#160;)</B> are straightforward; the only thing that&#8217;s a
bit odd is that it looks like the function is being dereferenced with a
&#8216;<B>*</B>&#8217;. Actually, the returned iterator is being dereferenced to
produce the value for
printing.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I175">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I176"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To test replacements,
<B>replace_copy(&#160;)</B> is used first (so it doesn&#8217;t modify the
original vector) to replace all values of 8 with the value 47. Notice the use of
<B>back_inserter(&#160;)</B> with the empty vector <B>v2</B>. To demonstrate
<B>replace_if(&#160;)</B>, a function object is created using the standard
template <B>greater_equal</B> along with <B>bind2nd</B> to replace all the
values that are greater than or equal to 7 with the value
-1.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I176">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I177"></a>
</FONT><A NAME="_Toc519042069"></A><BR></P></DIV>
<A NAME="Heading264"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Comparing ranges</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">These algorithms provide ways to compare
two ranges. At first glance, the operations they perform seem very close to the
<B>search(&#160;)</B> function above. However, <B>search(&#160;)</B> tells you
where the second sequence appears within the first, while <B>equal(&#160;)</B>
and <B>lexicographical_compare(&#160;) </B>simply tell you whether or not two
sequences are exactly identical (using different comparison algorithms). On the
other hand, <B>mismatch(&#160;)</B> does tell you where the two sequences go out
of sync, but those sequences must be exactly the same
length.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I177">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I178"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>bool equal(InputIterator first1,
InputIterator last1, InputIterator
first2);</B></FONT><BR><FONT FACE="Georgia"><B>bool equal(InputIterator first1,
InputIterator last1, InputIterator first2</B></FONT><BR><FONT FACE="Georgia"><B>
BinaryPredicate
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I178">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I179"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In both of these functions, the first
range is the typical one, <B>[first1, last1)</B>. The second range starts at
<B>first2</B>, but there is no &#8220;last2&#8221; because its length is
determined by the length of the first range. The <B>equal(&#160;)</B> function
returns true if both ranges are exactly the same (the same elements in the same
order); in the first case, the <B>operator==</B> is used to perform the
comparison and in the second case <B>binary_pred</B> is used to decide if two
elements are the same.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I179">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I180"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>bool
lexicographical_compare(InputIterator1 first1, InputIterator1
last1</B></FONT><BR><FONT FACE="Georgia"><B>    InputIterator2 first2,
InputIterator2 last2);</B></FONT><BR><FONT FACE="Georgia"><B>bool
lexicographical_compare(InputIterator1 first1, InputIterator1
last1</B></FONT><BR><FONT FACE="Georgia"><B>    InputIterator2 first2,
InputIterator2 last2, BinaryPredicate
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I180">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I181"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">These two functions determine if the
first range is &#8220;lexicographically less&#8221; than the second (they return
<B>true</B> if range 1 is less than range 2, and false otherwise.
Lexicographical equality, or &#8220;dictionary&#8221; comparison, means that the
comparison is done the same way we establish the order of strings in a
dictionary, one element at a time. The first elements determine the result if
these elements are different, but if they&#8217;re equal the algorithm moves on
to the next elements and looks at those, and so on. until it finds a mismatch.
At that point it looks at the elements, and if the element from range 1 is less
than the element from range two, then <B>lexicographical_compare(&#160;)</B>
returns <B>true</B>, otherwise it returns <B>false</B>. If it gets all the way
through one range or the other (the ranges may be different lengths for this
algorithm) without finding an inequality, then range 1 is <I>not </I>less than
range 2 so the function returns
<B>false</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I181">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I182"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If the two ranges are different lengths,
a missing element in one range acts as one that &#8220;precedes&#8221; an
element that exists in the other range. So {&#8216;a&#8217;, &#8216;b&#8217;}
lexicographically precedes {&#8216;a&#8217;, &#8216;b&#8217;, &#8216;a&#8217;
}.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I182">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I183"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the first version of the function,
<B>operator&lt;</B> is used to perform the comparisons, and in the second
version <B>binary_pred</B> is
used.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I183">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I184"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>pair&lt;InputIterator1,
InputIterator2&gt; mismatch(InputIterator1 first1,
</B></FONT><BR><FONT FACE="Georgia"><B>    InputIterator1 last1, InputIterator2
first2);</B></FONT><BR><FONT FACE="Georgia"><B>pair&lt;InputIterator1,
InputIterator2&gt; mismatch(InputIterator1 first1,
</B></FONT><BR><FONT FACE="Georgia"><B>    InputIterator1 last1, InputIterator2
first2, BinaryPredicate
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I184">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I185"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As in <B>equal(&#160;)</B>, the length of
both ranges is exactly the same, so only the first iterator in the second range
is necessary, and the length of the first range is used as the length of the
second range. Whereas <B>equal(&#160;)</B> just tells you whether or not the two
ranges are the same, <B>mismatch(&#160;)</B> tells you where they begin to
differ. To accomplish this, you must be told (1) the element in the first range
where the mismatch occurred and (2) the element in the second range where the
mismatch occurred. These two iterators are packaged together into a <B>pair</B>
object and returned. If no mismatch occurs, the return value is <B>last1</B>
combined with the past-the-end iterator of the second
range.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I185">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I186"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As in <B>equal(&#160;)</B>, the first
function tests for equality using <B>operator==</B> while the second one uses
<B>binary_pred</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I186">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I187"></a>
</FONT><BR></P></DIV>
<A NAME="Heading265"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Example</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because the standard C++ <B>string</B>
class is built like a container (it has <B>begin(&#160;)</B> and
<B>end(&#160;)</B> member functions which produce objects of type
<B>string::iterator</B>), it can be used to conveniently create ranges of
characters to test with the STL comparison algorithms. However, you should note
that <B>string </B>has a fairly complete set of native operations, so you should
look at the <B>string</B> class before using the STL algorithms to perform
operations.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I187">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I188"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:Comparison.cpp</font>
<font color=#009900>// The STL range comparison algorithms</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-g++295}</font>
#include <font color=#004488>"PrintSequence.h"</font>
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;string&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#009900>// strings provide a convenient way to create</font>
  <font color=#009900>// ranges of characters, but you should </font>
  <font color=#009900>// normally look for native string operations:</font>
  string s1(<font color=#004488>"This is a test"</font>);
  string s2(<font color=#004488>"This is a Test"</font>);
  cout &lt;&lt; <font color=#004488>"s1: "</font> &lt;&lt; s1 &lt;&lt; endl 
    &lt;&lt; <font color=#004488>"s2: "</font> &lt;&lt; s2 &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"compare s1 &amp; s1: "</font> 
    &lt;&lt; equal(s1.begin(), s1.end(), s1.begin())
    &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"compare s1 &amp; s2: "</font> 
    &lt;&lt; equal(s1.begin(), s1.end(), s2.begin())
    &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"lexicographical_compare s1 &amp; s1: "</font> &lt;&lt;
    lexicographical_compare(s1.begin(), s1.end(),
      s1.begin(), s1.end()) &lt;&lt;  endl;
  cout &lt;&lt; <font color=#004488>"lexicographical_compare s1 &amp; s2: "</font> &lt;&lt;
    lexicographical_compare(s1.begin(), s1.end(),
      s2.begin(), s2.end()) &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"lexicographical_compare s2 &amp; s1: "</font> &lt;&lt;
    lexicographical_compare(s2.begin(), s2.end(),
      s1.begin(), s1.end()) &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"lexicographical_compare shortened "</font> 
    <font color=#004488>"s1 &amp; full-length s2: "</font> &lt;&lt; endl;
  string s3(s1);
  <font color=#0000ff>while</font>(s3.length() != 0) {
    <font color=#0000ff>bool</font> result = lexicographical_compare(
      s3.begin(), s3.end(), s2.begin(),s2.end());
    cout &lt;&lt; s3 &lt;&lt; endl &lt;&lt; s2 &lt;&lt; <font color=#004488>", result = "</font> 
      &lt;&lt; result &lt;&lt; endl;
    <font color=#0000ff>if</font>(result == <font color=#0000ff>true</font>) <font color=#0000ff>break</font>;
    s3 = s3.substr(0, s3.length() - 1);
  }
  pair&lt;string::iterator, string::iterator&gt; p =
    mismatch(s1.begin(), s1.end(), s2.begin());
  print(p.first, s1.end(), <font color=#004488>"p.first"</font>, <font color=#004488>""</font>);
  print(p.second, s2.end(), <font color=#004488>"p.second"</font>,<font color=#004488>""</font>);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that the only difference between
<B>s1</B> and <B>s2</B> is the capital &#8216;T&#8217; in <B>s2</B>&#8217;s
&#8220;Test.&#8221; Comparing <B>s1</B> and <B>s1</B> for equality yields
<B>true</B>, as expected, while <B>s1</B> and <B>s2</B> are not equal because of
the capital
&#8216;T&#8217;.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I188">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I189"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To understand the output of the
<B>lexicographical_compare(&#160;)</B> tests, you must remember two things:
first, the comparison is performed character-by-character, and second that
capital letters &#8220;precede&#8221; lowercase letters. In the first test,
<B>s1</B> is compared to <B>s1</B>. These are exactly equivalent, thus one is
<I>not</I> lexicographically less than the other (which is what the comparison
is looking for) and thus the result is <B>false</B>. The second test is asking
&#8220;does <B>s1</B> precede <B>s2</B>?&#8221; When the comparison gets to the
&#8216;t&#8217; in &#8220;test&#8221;, it discovers that the lowercase
&#8216;t&#8217; in <B>s1</B> is &#8220;greater&#8221; than the uppercase
&#8216;T&#8217; in <B>s2</B>, so the answer is again <B>false</B>. However, if
we test to see whether <B>s2</B> precedes <B>s1</B>, the answer is
<B>true</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I189">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I190"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To further examine lexicographical
comparison, the next test in the above example compares <B>s1</B> with <B>s2</B>
again (which returned <B>false</B> before). But this time it repeats the
comparison, trimming one character off the end of <B>s1</B> (which is first
copied into <B>s3</B>) each time through the loop until the test evaluates to
<B>true</B>. What you&#8217;ll see is that, as soon as the uppercase
&#8216;T&#8217; is trimmed off of <B>s3</B> (the copy of <B>s1</B>), then the
characters, which are exactly equal up to that point, no longer count and the
fact that <B>s3</B> is shorter than <B>s2</B> is what makes it lexicographically
precede <B>s2</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I190">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I191"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The final test uses<B>
mismatch(&#160;)</B>. In order to capture the return value, you must first
create the appropriate <B>pair p</B>, constructing the template using the
iterator type from the first range and the iterator type from the second range
(in this case, both <B>string::iterator</B>s). To print the results, the
iterator for the mismatch in the first range is <B>p.first</B>, and for the
second range is <B>p.second</B>. In both cases, the range is printed from the
mismatch iterator to the end of the range so you can see exactly where the
iterator
points.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I191">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I192"></a>
</FONT><A NAME="_Toc519042070"></A><BR></P></DIV>
<A NAME="Heading266"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Removing elements</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because of the genericity of the STL, the
concept of removal is a bit constrained. Since elements can only be
&#8220;removed&#8221; via iterators, and iterators can point to arrays, vectors,
lists, etc., it is not safe or reasonable to actually try to destroy the
elements that are being removed, and to change the size of the input range
<B>[first, last)</B> (an array, for example, cannot have its size changed). So
instead, what the STL &#8220;remove&#8221; functions do is rearrange the
sequence so that the &#8220;removed&#8221; elements are at the end of the
sequence, and the &#8220;un-removed&#8221; elements are at the beginning of the
sequence (in the same order that they were before, minus the removed elements
&#8211; that is, this is a <I>stable</I> operation). Then the function will
return an iterator to the &#8220;new last&#8221; element of the sequence, which
is the end of the sequence without the removed elements and the beginning of the
sequence of the removed elements. In other words, if <B>new_last</B> is the
iterator that is returned from the &#8220;remove&#8221; function, then
<B>[first, new_last)</B> is the sequence without any of the removed elements,
and <B>[new_last, last)</B> is the sequence of removed
elements.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I192">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I193"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you are simply using your sequence,
including the removed elements, with more STL algorithms, you can just use
<B>new_last</B> as the new past-the-end iterator. However, if you&#8217;re using
a resizable container <B>c </B>(not an array) and you actually want to eliminate
the removed elements from the container you can use <B>erase(&#160;)</B> to do
so, for example:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I193">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I194"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>c.erase(remove(c.begin(), c.end(), value), c.end());</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The return value of <B>remove(&#160;)</B>
is the <B>new_last</B> iterator, so <B>erase(&#160;)</B> will delete all the
removed elements from
<B>c</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I194">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I195"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The iterators in <B>[new_last, last)</B>
are dereferenceable but the element values are undefined and should not be
used.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I195">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I196"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ForwardIterator remove(ForwardIterator
first, ForwardIterator last, const T&amp;
value);</B></FONT><BR><FONT FACE="Georgia"><B>ForwardIterator
remove_if(ForwardIterator first, ForwardIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    Predicate
pred);</B></FONT><BR><FONT FACE="Georgia"><B>OutputIterator
remove_copy(InputIterator first, InputIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    OutputIterator result, const T&amp;
value);</B></FONT><BR><FONT FACE="Georgia"><B>OutputIterator
remove_copy_if(InputIterator first, InputIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    OutputIterator result, Predicate
pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I196">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I197"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each of the &#8220;remove&#8221; forms
moves through the range <B>[first, last)</B>, finding values that match a
removal criterion and copying the un-removed elements over the removed elements
(thus effectively removing them). The original order of the un-removed elements
is maintained. The return value is an iterator pointing past the end of the
range that contains none of the removed elements. The values that this iterator
points to are
unspecified.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I197">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I198"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The &#8220;if&#8221; versions pass each
element to <B>pred(&#160;)</B> to determine whether it should be removed or not
(if <B>pred(&#160;)</B> returns <B>true</B>, the element is removed). The
&#8220;copy&#8221; versions do not modify the original sequence, but instead
copy the un-removed values into a range beginning at <B>result</B>, and return
an iterator indicating the past-the-end value of this new
range.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I198">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I199"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ForwardIterator unique(ForwardIterator
first, ForwardIterator
last);</B></FONT><BR><FONT FACE="Georgia"><B>ForwardIterator
unique(ForwardIterator first, ForwardIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    BinaryPredicate
binary_pred);</B></FONT><BR><FONT FACE="Georgia"><B>OutputIterator
unique_copy(InputIterator first, InputIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    OutputIterator
result);</B></FONT><BR><FONT FACE="Georgia"><B>OutputIterator
unique_copy(InputIterator first, InputIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    OutputIterator result, 
BinaryPredicate
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I199">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I200"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each of the &#8220;unique&#8221;
functions moves through the range <B>[first, last)</B>, finding adjacent values
that are equivalent (that is, duplicates) and &#8220;removing&#8221; the
duplicate elements by copying over them. The original order of the un-removed
elements is maintained. The return value is an iterator pointing past the end of
the range that has the adjacent duplicates
removed.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I200">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I201"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because only duplicates that are adjacent
are removed, it&#8217;s likely that you&#8217;ll want to call
<B>sort(&#160;)</B> before calling a &#8220;unique&#8221; algorithm, since that
will guarantee that <I>all</I> the duplicates are
removed.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I201">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I202"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The versions containing
<B>binary_pred</B> call, for each iterator value <B>i</B> in the input
range:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I202">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I203"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>binary_pred(*i, *(i-1));</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">and if the result is true then
<B>*(i-1)</B> is considered a
duplicate.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I203">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I204"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The &#8220;copy&#8221; versions do not
modify the original sequence, but instead copy the un-removed values into a
range beginning at <B>result</B>, and return an iterator indicating the
past-the-end value of this new
range.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I204">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I205"></a>
</FONT><BR></P></DIV>
<A NAME="Heading267"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Example</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example gives a visual demonstration
of the way the &#8220;remove&#8221; and &#8220;unique&#8221; functions
work.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I205">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I206"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:Removing.cpp</font>
<font color=#009900>// The removing algorithms</font>
<font color=#009900>// May be a bug here?</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-bor}</font>
<font color=#009900>//{-msc}</font>
<font color=#009900>//{-g++295}</font>
#include <font color=#004488>"PrintSequence.h"</font>
#include <font color=#004488>"Generators.h"</font>
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cctype&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>struct</font> IsUpper {
  <font color=#0000ff>bool</font> <font color=#0000ff>operator</font>()(<font color=#0000ff>char</font> c) {
    <font color=#0000ff>return</font> isupper(c);
  }
};

<font color=#0000ff>int</font> main() {
  vector&lt;<font color=#0000ff>char</font>&gt; v(50);
  generate(v.begin(), v.end(), CharGen());
  print(v, <font color=#004488>"v"</font>, <font color=#004488>""</font>);
  <font color=#009900>// Create a set of the characters in v:</font>
  set&lt;<font color=#0000ff>char</font>&gt; cs(v.begin(), v.end());
  set&lt;<font color=#0000ff>char</font>&gt;::iterator it = cs.begin();
  vector&lt;<font color=#0000ff>char</font>&gt;::iterator cit;
  <font color=#009900>// Step through and remove everything:</font>
  <font color=#0000ff>while</font>(it != cs.end()) {
    cit = remove(v.begin(), v.end(), *it);
    cout &lt;&lt; *it &lt;&lt; <font color=#004488>"["</font> &lt;&lt; *cit &lt;&lt; <font color=#004488>"] "</font>;
    print(v, <font color=#004488>""</font>, <font color=#004488>""</font>);
    it++;
  }
  generate(v.begin(), v.end(), CharGen());
  print(v, <font color=#004488>"v"</font>, <font color=#004488>""</font>);
  cit = remove_if(v.begin(), v.end(), IsUpper());
  print(v.begin(), cit, <font color=#004488>"after remove_if"</font>, <font color=#004488>""</font>);
  <font color=#009900>// Copying versions are not shown for remove</font>
  <font color=#009900>// and remove_if.</font>
  sort(v.begin(), cit);
  print(v.begin(), cit, <font color=#004488>"sorted"</font>, <font color=#004488>""</font>);
  vector&lt;<font color=#0000ff>char</font>&gt; v2;
  unique_copy(v.begin(), cit, back_inserter(v2));
  print(v2, <font color=#004488>"unique_copy"</font>, <font color=#004488>""</font>);
  <font color=#009900>// Same behavior:</font>
  cit = unique(v.begin(), cit, equal_to&lt;<font color=#0000ff>char</font>&gt;());
  print(v.begin(), cit, <font color=#004488>"unique"</font>, <font color=#004488>""</font>);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>vector&lt;char&gt; v</B> is filled
with randomly-generated characters and then copied into a <B>set</B>. Each
element of the <B>set</B> is used in a <B>remove</B> statement, but the entire
<B>vector v</B> is printed out each time so you can see what happens to the rest
of the range, after the resulting endpoint (which is stored in
<B>cit</B>).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I206">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I207"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To demonstrate <B>remove_if(&#160;)</B>,
the address of the Standard C library function <B>isupper(&#160;) </B>(in
<B>&lt;cctype&gt; </B>is called inside of the function object class
<B>IsUpper</B>, an object of which is<B> </B>passed as the predicate for
<B>remove_if(&#160;)</B>.<B> </B>This only returns <B>true</B> if a character is
uppercase, so only lowercase characters will remain. Here, the end of the range
is used in the call to <B>print(&#160;)</B> so only the remaining elements will
appear. The copying versions of <B>remove(&#160;)</B> and
<B>remove_if(&#160;)</B> are not shown because they are a simple variation on
the non-copying versions which you should be able to use without an
example.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I207">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I208"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The range of lowercase letters is sorted
in preparation for testing the &#8220;unique&#8221; functions (the
&#8220;unique&#8221; functions are not undefined if the range isn&#8217;t
sorted, but it&#8217;s probably not what you want). First,
<B>unique_copy(&#160;)</B> puts the unique elements into a new <B>vector</B>
using the default element comparison, and then the form of <B>unique(&#160;)</B>
that takes a predicate is used; the predicate used is the built-in function
object <B>equal_to(&#160;)</B>, which produces the same results as the default
element
comparison.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I208">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I209"></a>
</FONT><A NAME="_Toc519042071"></A><BR></P></DIV>
<A NAME="Heading268"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Sorting and operations on sorted ranges</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There is a significant category of STL
algorithms which require that the range they operate on be in sorted
order.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I209">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I210"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There is actually only one
&#8220;sort&#8221; algorithm used in the STL. This algorithm is presumably the
fastest one, but the implementer has fairly broad latitude. However, it comes
packaged in various flavors depending on whether the sort should be stable,
partial or just the regular sort. Oddly enough, only the partial sort has a
copying version; otherwise you&#8217;ll need to make your own copy before
sorting if that&#8217;s what you want. If you are working with a very large
number of items you may be better off transferring them to an array (or at least
a <B>vector</B>, which uses an array internally) rather than using them in some
of the STL containers.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I210">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I211"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once your sequence is sorted, there are
many operations you can perform on that sequence, from simply locating an
element or group of elements to merging with another sorted sequence or
manipulating sequences as mathematical
sets.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I211">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I212"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each algorithm involved with sorting or
operations on sorted sequences has two versions of each function, the first that
uses the object&#8217;s own <B>operator&lt;</B> to perform the comparison, and
the second that uses an additional <B>StrictWeakOrdering</B> object&#8217;s
<B>operator(&#160;)(a, b)</B> to compare two objects for <B>a</B> <B>&lt;</B>
<B>b</B>. Other than this there are no differences, so the distinction will not
be pointed out in the description of each
algorithm.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I212">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I213"></a>
</FONT><BR></P></DIV>
<A NAME="Heading269"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Sorting</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One STL container (<B>list</B>) has its
own built-in <B>sort(&#160;)</B> function which is almost certainly going to be
faster than the generic sort presented here (especially since the <B>list
</B>sort just swaps pointers rather than copying entire objects around). This
means that you&#8217;ll only want to use the sort functions here if (a)
you&#8217;re working with an array or a sequence container that doesn&#8217;t
have a <B>sort(&#160;)</B> function or (b) you want to use one of the other
sorting flavors, like a partial or stable sort, which aren&#8217;t supported by
<B>list</B>&#8217;s
<B>sort(&#160;)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I213">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I214"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>void sort(RandomAccessIterator first,
RandomAccessIterator last);</B></FONT><BR><FONT FACE="Georgia"><B>void
sort(RandomAccessIterator first, RandomAccessIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    StrictWeakOrdering
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I214">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I215"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Sorts <B>[first, last)</B> into ascending
order. The second form allows a comparator object to determine the
order.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I215">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I216"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>void stable_sort(RandomAccessIterator
first, RandomAccessIterator last);</B></FONT><BR><FONT FACE="Georgia"><B>void
stable_sort(RandomAccessIterator first, RandomAccessIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    StrictWeakOrdering
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I216">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I217"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Sorts <B>[first, last)</B> into ascending
order, preserving the original ordering of equivalent elements (this is
important if elements can be equivalent but not identical). The second form
allows a comparator object to determine the
order.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I217">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I218"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>void partial_sort(RandomAccessIterator
first, </B></FONT><BR><FONT FACE="Georgia"><B>    RandomAccessIterator middle,
RandomAccessIterator last);</B></FONT><BR><FONT FACE="Georgia"><B>void
partial_sort(RandomAccessIterator first, </B></FONT><BR><FONT FACE="Georgia"><B>
RandomAccessIterator middle, RandomAccessIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    StrictWeakOrdering
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I218">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I219"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Sorts the number of elements from
<B>[first, last)</B> that can be placed in the range <B>[first, middle)</B>. The
rest of the elements end up in <B>[middle, last)</B>, and have no guaranteed
order. The second form allows a comparator object to determine the
order.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I219">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I220"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>RandomAccessIterator
partial_sort_copy(InputIterator first, InputIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    RandomAccessIterator result_first,
RandomAccessIterator
result_last);</B></FONT><BR><FONT FACE="Georgia"><B>RandomAccessIterator
partial_sort_copy(InputIterator first, </B></FONT><BR><FONT FACE="Georgia"><B>  
InputIterator last, RandomAccessIterator result_first,
</B></FONT><BR><FONT FACE="Georgia"><B>    RandomAccessIterator result_last,
StrictWeakOrdering
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I220">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I221"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Sorts the number of elements from
<B>[first, last)</B> that can be placed in the range <B>[result_first,
result_last)</B>, and copies those elements into <B>[result_first,
result_last)</B>. If the range <B>[first, last)</B> is smaller than
<B>[result_first, result_last)</B>, then the smaller number of elements is used.
The second form allows a comparator object to determine the
order.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I221">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I222"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>void nth_element(RandomAccessIterator
first, </B></FONT><BR><FONT FACE="Georgia"><B>    RandomAccessIterator nth,
RandomAccessIterator last);</B></FONT><BR><FONT FACE="Georgia"><B>void
nth_element(RandomAccessIterator first, </B></FONT><BR><FONT FACE="Georgia"><B> 
RandomAccessIterator nth, RandomAccessIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    StrictWeakOrdering
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I222">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I223"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Just like <B>partial_sort(&#160;)</B>,
<B>nth_element(&#160;)</B> partially orders a range of elements. However,
it&#8217;s much &#8220;less ordered&#8221; than <B>partial_sort(&#160;)</B>. The
only thing that <B>nth_element(&#160;)</B> guarantees is that whatever
<I>location </I>you choose will become a dividing point. All the elements in the
range <B>[first, nth) </B>will be less than (they could also be equivalent to)
whatever element ends up at location <B>nth </B>and all the elements in the
range <B>(nth, last]</B> will be greater than whatever element ends up location
<B>nth</B>. However, neither range is in any particular order, unlike
<B>partial_sort(&#160;)</B> which has the first range in sorted
order.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I223">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I224"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If all you need is this very weak
ordering (if, for example, you&#8217;re determining medians, percentiles and
that sort of thing) this algorithm is faster than
<B>partial_sort(&#160;)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I224">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I225"></a>
</FONT><BR></P></DIV>
<A NAME="Heading270"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Example</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>StreamTokenizer</B> class from the
previous chapter is used to break a file into words, and each word is turned
into an <B>NString</B> and added to a <B>deque&lt;NString&gt;</B>. Once the
input file is completely read, a <B>vector&lt;NString&gt; </B>is created from
the contents of the <B>deque</B>. The <B>vector</B> is then used to demonstrate
the sorting algorithms:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I225">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I226"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:SortTest.cpp</font>
<font color=#009900>// Test different kinds of sorting</font>
<font color=#009900>//{L} ../C07/StreamTokenizer ../TestSuite/Test</font>
<font color=#009900>//{-g++295}</font>
<font color=#009900>//{-msc}</font>
#include <font color=#004488>"..</font><font color=#004488>/C07</font><font color=#004488>/StreamTokenizer.h"</font>
#include <font color=#004488>"NString.h"</font>
#include <font color=#004488>"PrintSequence.h"</font>
#include <font color=#004488>"Generators.h"</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;algorithm&gt;
#include &lt;fstream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cctype&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#009900>// For sorting NStrings and ignore string case:</font>
<font color=#0000ff>struct</font> NoCase {
  <font color=#0000ff>bool</font> <font color=#0000ff>operator</font>()(
    <font color=#0000ff>const</font> NString&amp; x, <font color=#0000ff>const</font> NString&amp; y) {
<font color=#009900>/* Somthing's wrong with this approach but I
   can't seem to see it. It would be much faster:
    const string&amp; lv = x;
    const string&amp; rv = y;
    int len = min(lv.size(), rv.size());
    for(int i = 0; i &lt; len; i++)
      if(tolower(lv[i]) &lt; tolower(rv[i]))
        return true;
    return false;
  }
*/</font>
    <font color=#009900>// Brute force: copy, force to lowercase:</font>
    string lv(x);
    string rv(y);
    lcase(lv);
    lcase(rv);
    <font color=#0000ff>return</font> lv &lt; rv;
  }
  <font color=#0000ff>void</font> lcase(string&amp; s) {
    <font color=#0000ff>int</font> n = s.size();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; n; i++)
      s[i] = tolower(s[i]);
  }
};

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  <font color=#0000ff>char</font>* fname = <font color=#004488>"SortTest.cpp"</font>;
  <font color=#0000ff>if</font>(argc &gt; 1) fname = argv[1];
  ifstream in(fname);
  assure(in, fname);
  StreamTokenizer words(in);
  deque&lt;NString&gt; nstr;
  string word;
  <font color=#0000ff>while</font>((word = words.next()).size() != 0)
    nstr.push_back(NString(word));
  print(nstr);
  <font color=#009900>// Create a vector from the contents of nstr:</font>
  vector&lt;NString&gt; v(nstr.begin(), nstr.end());
  sort(v.begin(), v.end());
  print(v, <font color=#004488>"sort"</font>);
  <font color=#009900>// Use an additional comparator object:</font>
  sort(v.begin(), v.end(), NoCase());
  print(v, <font color=#004488>"sort NoCase"</font>);
  copy(nstr.begin(), nstr.end(), v.begin());
  stable_sort(v.begin(), v.end());
  print(v, <font color=#004488>"stable_sort"</font>);
  <font color=#009900>// Use an additional comparator object:</font>
  stable_sort(v.begin(), v.end(), 
    greater&lt;NString&gt;());
  print(v, <font color=#004488>"stable_sort greater"</font>);
  copy(nstr.begin(), nstr.end(), v.begin());
  <font color=#009900>// Partial sorts. The additional comparator </font>
  <font color=#009900>// versions are obvious and not shown here.</font>
  partial_sort(v.begin(), 
    v.begin() + v.size()/2, v.end());
  print(v, <font color=#004488>"partial_sort"</font>);
  <font color=#009900>// Create a vector with a preallocated size:</font>
  vector&lt;NString&gt; v2(v.size()/2);
  partial_sort_copy(v.begin(), v.end(), 
    v2.begin(), v2.end());
  print(v2, <font color=#004488>"partial_sort_copy"</font>);
  <font color=#009900>// Finally, the weakest form of ordering:</font>
  vector&lt;<font color=#0000ff>int</font>&gt; v3(20);
  generate(v3.begin(), v3.end(), URandGen(50));
  print(v3, <font color=#004488>"v3 before nth_element"</font>);
  <font color=#0000ff>int</font> n = 10;
  vector&lt;<font color=#0000ff>int</font>&gt;::iterator vit = v3.begin() + n;
  nth_element(v3.begin(), vit, v3.end());
  cout &lt;&lt; <font color=#004488>"After ordering with nth = "</font> &lt;&lt; n
    &lt;&lt; <font color=#004488>", nth element is "</font> &lt;&lt; v3[n] &lt;&lt; endl;
  print(v3, <font color=#004488>"v3 after nth_element"</font>);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first class is a binary predicate
used to compare two <B>NString</B> objects while ignoring the case of the
<B>string</B>s. You can pass the object into the various sort routines to
produce an alphabetic sort (rather than the default lexicographic sort, which
has all the capital letters in one group, followed by all the lowercase
letters).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I226">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I227"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As an example, try the source code for
the above file as input. Because the occurrence numbers are printed along with
the strings you can distinguish between an ordinary sort and a stable sort, and
you can also see what happens during a partial sort (the remaining unsorted
elements are in no particular order). There is no &#8220;partial stable
sort.&#8221;
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I227">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I228"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll notice that the use of the
second &#8220;comparator&#8221; forms of the functions are not exhaustively
tested in the above example, but the use of a comparator is the same as in the
first part of the
example.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I228">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I229"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The test of <B>nth_element</B> does not
use the <B>NString</B> objects because it&#8217;s simpler to see what&#8217;s
going on if <B>int</B>s are used. Notice that, whatever the nth element turns
out to be (which will vary from one run to another because of <B>URandGen</B>),
the elements before that are less, and after that are greater, but the elements
have no particular order other than that. Because of <B>URandGen</B>, there are
no duplicates but if you use a generator that allows duplicates you can see that
the elements before the nth element will be less than or equal to the nth
element.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I229">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I230"></a>
</FONT><BR></P></DIV>
<A NAME="Heading271"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Locating elements in sorted ranges</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once a range is sorted, there are a group
of operations that can be used to find elements within those ranges. In the
following functions, there are always two forms, one that assumes the intrinsic
<B>operator&lt;</B> has been used to perform the sort, and the second that must
be used if some other comparison function object has been used to perform the
sort. You must use the same comparison for locating elements as you do to
perform the sort, otherwise the results are undefined. In addition, if you try
to use these functions on unsorted ranges the results will be
undefined.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I230">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I231"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>bool binary_search(ForwardIterator
first, ForwardIterator last, const T&amp;
value);</B></FONT><BR><FONT FACE="Georgia"><B>bool binary_search(ForwardIterator
first, ForwardIterator last, const T&amp; value,
</B></FONT><BR><FONT FACE="Georgia"><B>    StrictWeakOrdering
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I231">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I232"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Tells you whether <B>value</B> appears in
the sorted range <B>[first,
last)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I232">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I233"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ForwardIterator
lower_bound(ForwardIterator first, ForwardIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    const T&amp;
value);</B></FONT><BR><FONT FACE="Georgia"><B>ForwardIterator
lower_bound(ForwardIterator first, ForwardIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    const T&amp; value,
StrictWeakOrdering
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I233">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I234"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Returns an iterator indicating the first
occurrence of <B>value</B> in the sorted range <B>[first, last)</B>. Returns
<B>last</B> if <B>value</B> is not
found.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I234">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I235"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ForwardIterator
upper_bound(ForwardIterator first, ForwardIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    const T&amp;
value);</B></FONT><BR><FONT FACE="Georgia"><B>ForwardIterator
upper_bound(ForwardIterator first, ForwardIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    const T&amp; value,
StrictWeakOrdering
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I235">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I236"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Returns an iterator indicating one past
the last occurrence of <B>value</B> in the sorted range <B>[first, last)</B>.
Returns <B>last</B> if <B>value</B> is not
found.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I236">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I237"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>pair&lt;ForwardIterator,
ForwardIterator&gt; </B></FONT><BR><FONT FACE="Georgia"><B>   
equal_range(ForwardIterator first, ForwardIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    const T&amp;
value);</B></FONT><BR><FONT FACE="Georgia"><B>pair&lt;ForwardIterator,
ForwardIterator&gt; </B></FONT><BR><FONT FACE="Georgia"><B>   
equal_range(ForwardIterator first, ForwardIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    const T&amp; value,
StrictWeakOrdering
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I237">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I238"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Essentially combines
<B>lower_bound(&#160;)</B> and <B>upper_bound(&#160;)</B> to return a
<B>pair</B> indicating the first and one-past-the-last occurrences of
<B>value</B> in the sorted range <B>[first, last)</B>. Both iterators indicate
<B>last</B> if <B>value</B> is not
found.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I238">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I239"></a>
</FONT><BR></P></DIV>
<A NAME="Heading272"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Example</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here, we can use the approach from the
previous example:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I239">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I240"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:SortedSearchTest.cpp</font>
<font color=#009900>//{L} ../C07/StreamTokenizer ../TestSuite/Test</font>
<font color=#009900>// Test searching in sorted ranges</font>
<font color=#009900>//{-g++295}</font>
<font color=#009900>//{-msc}</font>
#include <font color=#004488>"..</font><font color=#004488>/C07</font><font color=#004488>/StreamTokenizer.h"</font>
#include <font color=#004488>"PrintSequence.h"</font>
#include <font color=#004488>"NString.h"</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;algorithm&gt;
#include &lt;fstream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  ifstream in(<font color=#004488>"SortedSearchTest.cpp"</font>);
  assure(in, <font color=#004488>"SortedSearchTest.cpp"</font>);
  StreamTokenizer words(in);
  deque&lt;NString&gt; dstr;
  string word;
  <font color=#0000ff>while</font>((word = words.next()).size() != 0)
    dstr.push_back(NString(word));
  vector&lt;NString&gt; v(dstr.begin(), dstr.end());
  sort(v.begin(), v.end());
  print(v, <font color=#004488>"sorted"</font>);
  <font color=#0000ff>typedef</font> vector&lt;NString&gt;::iterator sit;
  sit it, it2;
  string f(<font color=#004488>"include"</font>);
  cout &lt;&lt; <font color=#004488>"binary search: "</font> 
    &lt;&lt; binary_search(v.begin(), v.end(), f) 
    &lt;&lt; endl;
  it = lower_bound(v.begin(), v.end(), f);
  it2 = upper_bound(v.begin(), v.end(), f);
  print(it, it2, <font color=#004488>"found range"</font>);
  pair&lt;sit, sit&gt; ip = 
    equal_range(v.begin(), v.end(), f);
  print(ip.first, ip.second, 
    <font color=#004488>"equal_range"</font>);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The input is forced to be the source code
for this file because the word &#8220;include&#8221; will be used for a find
string (since &#8220;include&#8221; appears many times). The file is tokenized
into words that are placed into a <B>deque</B> (a better container when you
don&#8217;t know how much storage to allocate), and left unsorted in the
<B>deque</B>. The <B>deque</B> is copied into a <B>vector</B> via the
appropriate constructor, and the <B>vector</B> is sorted and
printed.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I240">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I241"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>binary_search(&#160;)</B> function
only tells you if the object is there or not; <B>lower_bound(&#160;)</B> and
<B>upper_bound(&#160;)</B> produce iterators to the beginning and ending
positions where the matching objects appear. The same effect can be produced
more succinctly using <B>equal_range(&#160;)</B> (as shown in the previous
chapter, with <B>multimap</B> and
<B>multiset</B>).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I241">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I242"></a>
</FONT><BR></P></DIV>
<A NAME="Heading273"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Merging sorted ranges</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As before, the first form of each
function assumes the intrinsic <B>operator&lt;</B> has been used to perform the
sort. The second form must be used if some other comparison function object has
been used to perform the sort. You must use the same comparison for locating
elements as you do to perform the sort, otherwise the results are undefined. In
addition, if you try to use these functions on unsorted ranges the results will
be undefined.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I242">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I243"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>OutputIterator merge(InputIterator1
first1, InputIterator1 last1, </B></FONT><BR><FONT FACE="Georgia"><B>   
InputIterator2 first2, InputIterator2 last2, OutputIterator
result);</B></FONT><BR><FONT FACE="Georgia"><B>OutputIterator
merge(InputIterator1 first1, InputIterator1 last1,
</B></FONT><BR><FONT FACE="Georgia"><B>    InputIterator2 first2, InputIterator2
last2, OutputIterator result, </B></FONT><BR><FONT FACE="Georgia"><B>   
StrictWeakOrdering
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I243">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I244"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Copies elements from <B>[first1,
last1)</B> and <B>[first2, last2)</B> into <B>result</B>, such that the
resulting range is sorted in ascending order. This is a stable
operation.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I244">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I245"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>void
inplace_merge(BidirectionalIterator first,
</B></FONT><BR><FONT FACE="Georgia"><B>    BidirectionalIterator middle,
BidirectionalIterator last);</B></FONT><BR><FONT FACE="Georgia"><B>void
inplace_merge(BidirectionalIterator first,
</B></FONT><BR><FONT FACE="Georgia"><B>    BidirectionalIterator middle,
BidirectionalIterator last, </B></FONT><BR><FONT FACE="Georgia"><B>   
StrictWeakOrdering
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I245">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I246"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This assumes that <B>[first, middle)</B>
and <B>[middle, last)</B> are each sorted ranges. The two ranges are merged so
that the resulting range <B>[first, last)</B> contains the combined ranges in
sorted order.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I246">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I247"></a>
</FONT><BR></P></DIV>
<A NAME="Heading274"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Example</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s easier to see what goes on
with merging if <B>int</B>s are used; the following example also emphasizes how
the algorithms (and my own <B>print</B> template) work with arrays as well as
containers.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I247">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I248"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:MergeTest.cpp</font>
<font color=#009900>// Test merging in sorted ranges</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;algorithm&gt;
#include <font color=#004488>"PrintSequence.h"</font>
#include <font color=#004488>"Generators.h"</font>
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> sz = 15;
  <font color=#0000ff>int</font> a[sz*2] = {0};
  <font color=#009900>// Both ranges go in the same array:</font>
  generate(a, a + sz, SkipGen(0, 2));
  generate(a + sz, a + sz*2, SkipGen(1, 3));
  print(a, a + sz, <font color=#004488>"range1"</font>, <font color=#004488>" "</font>);  
  print(a + sz, a + sz*2, <font color=#004488>"range2"</font>, <font color=#004488>" "</font>);
  <font color=#0000ff>int</font> b[sz*2] = {0}; <font color=#009900>// Initialize all to zero</font>
  merge(a, a + sz, a + sz, a + sz*2, b);
  print(b, b + sz*2, <font color=#004488>"merge"</font>, <font color=#004488>" "</font>);
  <font color=#009900>// set_union is a merge that removes duplicates</font>
  set_union(a, a + sz, a + sz, a + sz*2, b);
  print(b, b + sz*2, <font color=#004488>"set_union"</font>, <font color=#004488>" "</font>);
  inplace_merge(a, a + sz, a + sz*2);
  print(a, a + sz*2, <font color=#004488>"inplace_merge"</font>, <font color=#004488>" "</font>);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>main(&#160;)</B>, instead of
creating two separate arrays both ranges will be created end-to-end in the same
array <B>a</B> (this will come in handy for the <B>inplace_merge</B>). The first
call to <B>merge(&#160;)</B> places the result in a different array, <B>b</B>.
For comparison, <B>set_union(&#160;)</B> is also called, which has the same
signature and similar behavior, except that it removes the duplicates. Finally,
<B>inplace_merge(&#160;)</B> is used to combine both parts of
<B>a</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I248">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I249"></a>
</FONT><BR></P></DIV>
<A NAME="Heading275"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Set operations on sorted ranges</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once ranges have been sorted, you can
perform mathematical set operations on
them.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I249">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I250"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>bool includes(InputIterator1 first1,
InputIterator1 last1, </B></FONT><BR><FONT FACE="Georgia"><B>    InputIterator2
first2, InputIterator2 last2);</B></FONT><BR><FONT FACE="Georgia"><B>bool
includes (InputIterator1 first1, InputIterator1 last1,
</B></FONT><BR><FONT FACE="Georgia"><B>    InputIterator2 first2, InputIterator2
last2, </B></FONT><BR><FONT FACE="Georgia"><B>    StrictWeakOrdering
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I250">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I251"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Returns <B>true</B> if <B>[first2,
last2)</B> is a subset of <B>[first1, last1)</B>. Neither range is required to
hold only unique elements, but if <B>[first2, last2)</B> holds <B>n</B> elements
of a particular value, then <B>[first1, last1)</B> must also hold <B>n</B>
elements if the result is to be
<B>true</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I251">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I252"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>OutputIterator
set_union(InputIterator1 first1, InputIterator1 last1,
</B></FONT><BR><FONT FACE="Georgia"><B>    InputIterator2 first2, InputIterator2
last2, OutputIterator
result);</B></FONT><BR><FONT FACE="Georgia"><B>OutputIterator
set_union(InputIterator1 first1, InputIterator1 last1,
</B></FONT><BR><FONT FACE="Georgia"><B>    InputIterator2 first2, InputIterator2
last2, OutputIterator result, </B></FONT><BR><FONT FACE="Georgia"><B>   
StrictWeakOrdering
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I252">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I253"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Creates the mathematical union of two
sorted ranges in the <B>result</B> range, returning the end of the output range.
Neither input range is required to hold only unique elements, but if a
particular value appears multiple times in both input sets, then the resulting
set will contain the larger number of identical
values.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I253">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I254"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>OutputIterator set_intersection
(InputIterator1 first1, InputIterator1 last1,
</B></FONT><BR><FONT FACE="Georgia"><B>    InputIterator2 first2, InputIterator2
last2, OutputIterator
result);</B></FONT><BR><FONT FACE="Georgia"><B>OutputIterator set_intersection
(InputIterator1 first1, InputIterator1 last1,
</B></FONT><BR><FONT FACE="Georgia"><B>    InputIterator2 first2, InputIterator2
last2, OutputIterator result, </B></FONT><BR><FONT FACE="Georgia"><B>   
StrictWeakOrdering
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I254">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I255"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Produces, in <B>result</B>, the
intersection of the two input sets, returning the end of the output range. That
is, the set of values that appear in both input sets. Neither input range is
required to hold only unique elements, but if a particular value appears
multiple times in both input sets, then the resulting set will contain the
smaller number of identical
values.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I255">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I256"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>OutputIterator set_difference
(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,
InputIterator2 last2, OutputIterator
result);</B></FONT><BR><FONT FACE="Georgia"><B>OutputIterator set_difference
(InputIterator1 first1, InputIterator1 last1,
</B></FONT><BR><FONT FACE="Georgia"><B>    InputIterator2 first2, InputIterator2
last2, OutputIterator result, </B></FONT><BR><FONT FACE="Georgia"><B>   
StrictWeakOrdering
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I256">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I257"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Produces, in <B>result</B>, the
mathematical set difference, returning the end of the output range. All the
elements that are in <B>[first1, last1)</B> but not in <B>[first2, last2)</B>
are placed in the result set. Neither input range is required to hold only
unique elements, but if a particular value appears multiple times in both input
sets (<B>n</B> times in set 1 and <B>m</B> times in set 2), then the resulting
set will contain <B>max(n-m, 0)</B> copies of that
value.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I257">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I258"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>OutputIterator
set_symmetric_difference(InputIterator1 first1,
</B></FONT><BR><FONT FACE="Georgia"><B>    InputIterator1 last1, InputIterator2
first2, InputIterator2 last2, </B></FONT><BR><FONT FACE="Georgia"><B>   
OutputIterator result);</B></FONT><BR><FONT FACE="Georgia"><B>OutputIterator
set_symmetric_difference(InputIterator1 first1,
</B></FONT><BR><FONT FACE="Georgia"><B>    InputIterator1 last1, InputIterator2
first2, InputIterator2 last2, </B></FONT><BR><FONT FACE="Georgia"><B>   
OutputIterator result, StrictWeakOrdering
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I258">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I259"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Constructs, in <B>result</B>, the set
containing:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I259">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I260"></a>
</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">All the elements in set 1
that are not in set
2</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">All the elements
in set 2 that are not in set
1.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Neither input range is
required to hold only unique elements, but if a particular value appears
multiple times in both input sets (<B>n</B> times in set 1 and <B>m</B> times in
set 2), then the resulting set will contain <B>abs(n-m)</B> copies of that
value, where <B>abs(&#160;)</B> is the absolute value. The return value is the
end of the output range.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I260">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I261"></a>
</FONT><BR></P></DIV>
<A NAME="Heading276"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Example</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s easiest to see the set
operations demonstrated using simple vectors of characters, so you view the sets
more easily. These characters are randomly generated and then sorted, but the
duplicates are not removed so you can see what the set operations do when
duplicates are involved.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I261">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I262"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:SetOperations.cpp</font>
<font color=#009900>// Set operations on sorted ranges</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-msc}</font>
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include <font color=#004488>"PrintSequence.h"</font>
#include <font color=#004488>"Generators.h"</font>
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  vector&lt;<font color=#0000ff>char</font>&gt; v(50), v2(50);
  CharGen g;
  generate(v.begin(), v.end(), g);
  generate(v2.begin(), v2.end(), g);
  sort(v.begin(), v.end());
  sort(v2.begin(), v2.end());
  print(v, <font color=#004488>"v"</font>, <font color=#004488>""</font>);
  print(v2, <font color=#004488>"v2"</font>, <font color=#004488>""</font>);
  <font color=#0000ff>bool</font> b = includes(v.begin(), v.end(), 
    v.begin() + v.size()/2, v.end());
  cout &lt;&lt; <font color=#004488>"includes: "</font> &lt;&lt;
    (b ? <font color=#004488>"true"</font> : <font color=#004488>"false"</font>) &lt;&lt; endl;
  vector&lt;<font color=#0000ff>char</font>&gt; v3, v4, v5, v6;
  set_union(v.begin(), v.end(), 
    v2.begin(), v2.end(), back_inserter(v3));
  print(v3, <font color=#004488>"set_union"</font>, <font color=#004488>""</font>);
  set_intersection(v.begin(), v.end(), 
    v2.begin(), v2.end(), back_inserter(v4));
  print(v4, <font color=#004488>"set_intersection"</font>, <font color=#004488>""</font>);
  set_difference(v.begin(), v.end(), 
    v2.begin(), v2.end(), back_inserter(v5));
  print(v5, <font color=#004488>"set_difference"</font>, <font color=#004488>""</font>);
  set_symmetric_difference(v.begin(), v.end(), 
    v2.begin(), v2.end(), back_inserter(v6));
  print(v6, <font color=#004488>"set_symmetric_difference"</font>,<font color=#004488>""</font>);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">After <B>v</B> and <B>v2</B> are
generated, sorted and printed, the <B>includes(&#160;)</B> algorithm is tested
by seeing if the entire range of <B>v</B> contains the last half of <B>v</B>,
which of course it does so the result should always be true. The vectors
<B>v3</B>, <B>v4</B>, <B>v5</B> and <B>v6</B> are created to hold the output of
<B>set_union(&#160;)</B>, <B>set_intersection(&#160;)</B>,
<B>set_difference(&#160;)</B> and <B>set_symmetric_difference(&#160;)</B>, and
the results of each are displayed so you can ponder them and convince yourself
that the algorithms do indeed work as
promised.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I262">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I263"></a>
</FONT><A NAME="_Toc519042072"></A><BR></P></DIV>
<A NAME="Heading277"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Heap operations</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The heap operations in the STL are
primarily concerned with the creation of the STL <B>priority_queue</B>, which
provides efficient access to the &#8220;largest&#8221; element, whatever
&#8220;largest&#8221; happens to mean for your program. These were discussed in
some detail in the previous chapter, and you can find an example
there.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I263">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I264"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As with the &#8220;sort&#8221;
operations, there are two versions of each function, the first that uses the
object&#8217;s own <B>operator&lt;</B> to perform the comparison, the second
that uses an additional <B>StrictWeakOrdering</B> object&#8217;s
<B>operator(&#160;)(a, b)</B> to compare two objects for <B>a</B> <B>&lt;</B>
<B>b</B>. 
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I264">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I265"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>void make_heap(RandomAccessIterator
first, RandomAccessIterator last);</B></FONT><BR><FONT FACE="Georgia"><B>void
make_heap(RandomAccessIterator first, RandomAccessIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    StrictWeakOrdering
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I265">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I266"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Turns an arbitrary range into a heap. A
heap is just a range that is organized in a particular
way.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I266">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I267"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>void push_heap(RandomAccessIterator
first, RandomAccessIterator last);</B></FONT><BR><FONT FACE="Georgia"><B>void
push_heap(RandomAccessIterator first, RandomAccessIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    StrictWeakOrdering
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I267">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I268"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Adds the element *(<B>last-1)</B> to the
heap determined by the range <B>[first, last-1)</B>. Yes, it seems like an odd
way to do things but remember that the <B>priority_queue</B> container presents
the nice interface to a heap, as shown in the previous
chapter.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I268">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I269"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>void pop_heap(RandomAccessIterator
first, RandomAccessIterator last);</B></FONT><BR><FONT FACE="Georgia"><B>void
pop_heap(RandomAccessIterator first, RandomAccessIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    StrictWeakOrdering
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I269">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I270"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Places the largest element (which is
actually in <B>*first</B>, before the operation, because of the way heaps are
defined) into the position <B>*(last-1)</B> <I>and</I> reorganizes the remaining
range so that it&#8217;s still in heap order. If you simply grabbed
<B>*first</B>, the next element would not be the next-largest element so you
must use <B>pop_heap(&#160;)</B> if you want to maintain the heap in its proper
priority-queue order.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I270">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I271"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>void sort_heap(RandomAccessIterator
first, RandomAccessIterator last);</B></FONT><BR><FONT FACE="Georgia"><B>void
sort_heap(RandomAccessIterator first, RandomAccessIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    StrictWeakOrdering
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I271">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I272"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This could be thought of as the
complement of <B>make_heap(&#160;)</B>, since it takes a range that is in heap
order and turns it into ordinary sorted order, so it is no longer a heap. That
means that if you call <B>sort_heap(&#160;)</B> you can no longer use
<B>push_heap(&#160;)</B> or <B>pop_heap(&#160;)</B> on that range (rather, you
can use those functions but they won&#8217;t do anything sensible). This is not
a stable
sort.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I272">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I273"></a>
</FONT><A NAME="_Toc519042073"></A><BR></P></DIV>
<A NAME="Heading278"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Applying an operation to each element in a range</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">These algorithms move through the entire
range and perform an operation on each element. They differ in what they do with
the results of that operation: <B>for_each(&#160;)</B> discards the return value
of the operation (but returns the function object that has been applied to each
element), while <B>transform(&#160;)</B> places the results of each operation
into a destination sequence (which can be the original
sequence).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I273">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I274"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>UnaryFunction for_each(InputIterator
first, InputIterator last, UnaryFunction f);
</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I274">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I275"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Applies the function object <B>f</B> to
each element in <B>[first, last)</B>, discarding the return value from each
individual application of <B>f</B>. If <B>f </B>is just a function pointer then
you are typically not interested in the return value, but if <B>f </B>is an
object that maintains some internal state it can capture the combined return
value of being applied to the range. The final return value of
<B>for_each(&#160;)</B> is
<B>f</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I275">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I276"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">OutputIterator transform(InputIterator
first, InputIterator last, </FONT><BR><FONT FACE="Georgia">    OutputIterator
result, UnaryFunction f);</FONT><BR><FONT FACE="Georgia">OutputIterator
transform(InputIterator1 first, InputIterator1 last,
</FONT><BR><FONT FACE="Georgia">    InputIterator2 first2, OutputIterator
result, BinaryFunction f);</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Like <B>for_each(&#160;)</B>,
<B>transform(&#160;)</B> applies a function object <B>f</B> to each element in
the range <B>[first, last)</B>. However, instead of discarding the result of
each function call, <B>transform(&#160;)</B> copies the result (using
<B>operator=</B>) into <B>*result</B>, incrementing <B>result</B> after each
copy (the sequence pointed to by <B>result</B> must have enough storage,
otherwise you should use an inserter to force insertions instead of
assignments).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I276">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I277"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first form of
<B>transform(&#160;)</B> simply calls <B>f(&#160;)</B> and passes it each object
from the input range as an argument. The second form passes an object from the
first input range and one from the second input range as the two arguments to
the binary function <B>f </B>(note the length of the second input range is
determined by the length of the first). The return value in both cases is the
past-the-end iterator for the resulting output
range.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I277">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I278"></a>
</FONT><BR></P></DIV>
<A NAME="Heading279"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Examples</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since much of what you do with objects in
a container is to apply an operation to all of those objects, these are fairly
important algorithms and merit several
illustrations.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I278">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I279"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">First, consider <B>for_each(&#160;)</B>.
This sweeps through the range, pulling out each element and passing it as an
argument as it calls whatever function object it&#8217;s been given. Thus
<B>for_each(&#160;)</B> performs operations that you might normally write out by
hand. In <B>Stlshape.cpp</B>, for
example:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I279">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I280"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>for</font>(Iter j = shapes.begin();
      j != shapes.end(); j++)
    <font color=#0000ff>delete</font> *j;</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you look in your
compiler&#8217;s header file at the template defining <B>for_each(&#160;)</B>,
you&#8217;ll see something like
this:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I280">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I281"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>template</font> &lt;<font color=#0000ff>class</font> InputIterator, <font color=#0000ff>class</font> Function&gt;
Function for_each(InputIterator first, 
                  InputIterator last, 
                  Function f) {
    <font color=#0000ff>while</font> (first != last) f(*first++);
    <font color=#0000ff>return</font> f;
}</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Function</B> <B>f </B>looks at
first like it must be a pointer to a function which takes, as an argument, an
object of whatever <B>InputIterator</B> selects. However, the above template
actually only says that you must be able to call <B>f</B> using parentheses and
an argument. This is true for a function pointer, but it&#8217;s also true for a
function object &#8211; any class that defines the appropriate
<B>operator(&#160;)</B>.<B> </B>The following example shows several different
ways this template can be expanded. First, we need a class that keeps track of
its objects so we can know that it&#8217;s being properly
destroyed:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I281">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I282"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:Counted.h</font>
<font color=#009900>// An object that keeps track of itself</font>
#ifndef COUNTED_H
#define COUNTED_H
#include &lt;vector&gt;
#include &lt;iostream&gt;

<font color=#0000ff>class</font> Counted {
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> count;
  <font color=#0000ff>char</font>* ident;
<font color=#0000ff>public</font>:
  Counted(<font color=#0000ff>char</font>* id) : ident(id) { count++; }
  ~Counted() { 
    std::cout &lt;&lt; ident &lt;&lt; <font color=#004488>" count = "</font> 
      &lt;&lt; --count &lt;&lt; std::endl;
  }
};

<font color=#0000ff>int</font> Counted::count = 0;

<font color=#0000ff>class</font> CountedVector : 
  <font color=#0000ff>public</font> std::vector&lt;Counted*&gt; {
<font color=#0000ff>public</font>:
  CountedVector(<font color=#0000ff>char</font>* id) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 5; i++)
      push_back(<font color=#0000ff>new</font> Counted(id));
  }
};
#endif <font color=#009900>// COUNTED_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>class Counted</B> keeps a static
count of how many <B>Counted</B> objects have been created, and tells you as
they are destroyed. In addition, each <B>Counted</B> keeps a <B>char*</B>
identifier to make tracking the output
easier.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I282">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I283"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>CountedVector</B> is inherited
from <B>vector&lt;Counted*&gt;</B>, and in the constructor it creates some
<B>Counted</B> objects, handing each one your desired <B>char*</B>. The
<B>CountedVector</B> makes testing quite simple, as you&#8217;ll
see.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I283">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I284"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:ForEach.cpp</font>
<font color=#009900>// Use of STL for_each() algorithm</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-g++295}</font>
<font color=#009900>//{-g++3}</font>
<font color=#009900>//{-msc}</font>
#include <font color=#004488>"Counted.h"</font>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#009900>// Simple function:</font>
<font color=#0000ff>void</font> destroy(Counted* fp) { <font color=#0000ff>delete</font> fp; }

<font color=#009900>// Function object:</font>
<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> T&gt;
<font color=#0000ff>class</font> DeleteT {
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> <font color=#0000ff>operator</font>()(T* x) { <font color=#0000ff>delete</font> x; }
};

<font color=#009900>// Template function:</font>
<font color=#0000ff>template</font> &lt;<font color=#0000ff>class</font> T&gt;
<font color=#0000ff>void</font> wipe(T* x) { <font color=#0000ff>delete</font> x; }

<font color=#0000ff>int</font> main() {
  CountedVector A(<font color=#004488>"one"</font>);
  for_each(A.begin(), A.end(), destroy);
  CountedVector B(<font color=#004488>"two"</font>);
  for_each(B.begin(),B.end(),DeleteT&lt;Counted&gt;());
  CountedVector C(<font color=#004488>"three"</font>);
  for_each(C.begin(), C.end(), wipe&lt;Counted&gt;);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>main(&#160;)</B>, the first
approach is the simple pointer-to-function, which works but has the drawback
that you must write a new <B>Destroy</B> function for each different type. The
obvious solution is to make a template, which is shown in the second approach
with a templatized function object. On the other hand, approach three also makes
sense: template functions work as well.

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I284">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I285"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since this is obviously something you
might want to do a lot, why not create an algorithm to <B>delete</B> all the
pointers in a container? This was accomplished with the <B>purge(&#160;)</B>
template created in the previous chapter. However, that used explicitly-written
code; here, we could use <B>transform(&#160;)</B>. The value of
<B>transform(&#160;)</B> over <B>for_each(&#160;)</B> is that
<B>transform(&#160;)</B> assigns the result of calling the function object into
a resulting range, which can actually be the input range. That case means a
literal transformation for the input range, since each element would be a
modification of its previous value. In the above example this would be
especially useful since it&#8217;s more appropriate to assign each pointer to
the safe value of zero after calling <B>delete</B> for that pointer.
<B>Transform(&#160;)</B> can easily do
this:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I285">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I286"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:Transform.cpp</font>
<font color=#009900>// Use of STL transform() algorithm</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-msc}</font>
#include <font color=#004488>"Counted.h"</font>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> T&gt;
T* deleteP(T* x) { <font color=#0000ff>delete</font> x; <font color=#0000ff>return</font> 0; }

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> T&gt; <font color=#0000ff>struct</font> Deleter {
  T* <font color=#0000ff>operator</font>()(T* x) { <font color=#0000ff>delete</font> x; <font color=#0000ff>return</font> 0; }
};

<font color=#0000ff>int</font> main() {
  CountedVector cv(<font color=#004488>"one"</font>);
  transform(cv.begin(), cv.end(), cv.begin(), 
    deleteP&lt;Counted&gt;);
  CountedVector cv2(<font color=#004488>"two"</font>);
  transform(cv2.begin(), cv2.end(), cv2.begin(),
    Deleter&lt;Counted&gt;());
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This shows both approaches: using a
template function or a templatized function object. After the call to
<B>transform(&#160;)</B>, the vector contains zero pointers, which is safer
since any duplicate <B>delete</B>s will have no
effect.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I286">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I287"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One thing you cannot do is <B>delete</B>
every pointer in a collection without wrapping the call to <B>delete </B>inside
a function or an object. That is, you don&#8217;t want to say something like
this:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I287">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I288"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>for_each(a.begin(), a.end(), ptr_fun(<font color=#0000ff>operator</font> <font color=#0000ff>delete</font>));</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can say it, but what you&#8217;ll get
is a sequence of calls to the function that releases the storage. You will not
get the effect of calling <B>delete</B> for each pointer in <B>a</B>, however;
the destructor will not be called. This is typically not what you want, so you
will need wrap your calls to
<B>delete</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I288">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I289"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the previous example of
<B>for_each(&#160;)</B>, the return value of the algorithm was ignored. This
return value is the function that is passed in to <B>for_each(&#160;)</B>. If
the function is just a pointer to a function, then the return value is not very
useful, but if it is a function object, then that function object may have
internal member data that it uses to accumulate information about all the
objects that it sees during
<B>for_each(&#160;)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I289">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I290"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For example, consider a simple model of
inventory. Each <B>Inventory</B> object has the type of product it represents
(here, single characters will be used for product names), the quantity of that
product and the price of each
item:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I290">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I291"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:Inventory.h</font>
#ifndef INVENTORY_H
#define INVENTORY_H
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;

<font color=#0000ff>class</font> Inventory {
  <font color=#0000ff>char</font> item;
  <font color=#0000ff>int</font> quantity;
  <font color=#0000ff>int</font> value;
<font color=#0000ff>public</font>:
  Inventory(<font color=#0000ff>char</font> it, <font color=#0000ff>int</font> quant, <font color=#0000ff>int</font> val) 
    : item(it), quantity(quant), value(val) {}
  <font color=#009900>// Synthesized operator= &amp; copy-constructor OK</font>
  <font color=#0000ff>char</font> getItem() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> item; }
  <font color=#0000ff>int</font> getQuantity() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> quantity; }
  <font color=#0000ff>void</font> setQuantity(<font color=#0000ff>int</font> q) { quantity = q; }
  <font color=#0000ff>int</font> getValue() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> value; }
  <font color=#0000ff>void</font> setValue(<font color=#0000ff>int</font> val) { value = val; }
  <font color=#0000ff>friend</font> std::ostream&amp; <font color=#0000ff>operator</font>&lt;&lt;(
    std::ostream&amp; os, <font color=#0000ff>const</font> Inventory&amp; inv) {
    <font color=#0000ff>return</font> os &lt;&lt; inv.item &lt;&lt; <font color=#004488>": "</font> 
      &lt;&lt; <font color=#004488>"quantity "</font> &lt;&lt; inv.quantity 
      &lt;&lt; <font color=#004488>", value "</font> &lt;&lt; inv.value;
  }
};

<font color=#009900>// A generator:</font>
<font color=#0000ff>struct</font> InvenGen {
  InvenGen() { std::srand(std::time(0)); }
  Inventory <font color=#0000ff>operator</font>()() {
    <font color=#0000ff>static</font> <font color=#0000ff>char</font> c = 'a';
    <font color=#0000ff>int</font> q = std::rand() % 100;
    <font color=#0000ff>int</font> v = std::rand() % 500;
    <font color=#0000ff>return</font> Inventory(c++, q, v);
  }
};
#endif <font color=#009900>// INVENTORY_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are member functions to get the
item name, and to get and set quantity and value. An <B>operator&lt;&lt;</B>
prints the <B>Inventory</B> object to an <B>ostream</B>. There&#8217;s also a
generator that creates objects that have sequentially-labeled items and random
quantities and values. Note the use of the return value optimization in
<B>operator(&#160;)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I291">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I292"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To find out the total number of items and
total value, you can create a function object to use with
<B>for_each(&#160;)</B> that has data members to hold the
totals:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I292">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I293"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:CalcInventory.cpp</font>
<font color=#009900>// More use of for_each()</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-g++295}</font>
<font color=#009900>//{-msc}</font>
#include <font color=#004488>"Inventory.h"</font>
#include <font color=#004488>"PrintSequence.h"</font>
#include &lt;vector&gt;
#include &lt;algorithm&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#009900>// To calculate inventory totals:</font>
<font color=#0000ff>class</font> InvAccum {
  <font color=#0000ff>int</font> quantity;
  <font color=#0000ff>int</font> value;
<font color=#0000ff>public</font>:
  InvAccum() : quantity(0), value(0) {}
  <font color=#0000ff>void</font> <font color=#0000ff>operator</font>()(<font color=#0000ff>const</font> Inventory&amp; inv) {
    quantity += inv.getQuantity();
    value += inv.getQuantity() * inv.getValue();
  }
  <font color=#0000ff>friend</font> ostream&amp; 
  <font color=#0000ff>operator</font>&lt;&lt;(ostream&amp; os, <font color=#0000ff>const</font> InvAccum&amp; ia) {
    <font color=#0000ff>return</font> os &lt;&lt; <font color=#004488>"total quantity: "</font> 
      &lt;&lt; ia.quantity
      &lt;&lt; <font color=#004488>", total value: "</font> &lt;&lt; ia.value;
  }
};

<font color=#0000ff>int</font> main() {
  vector&lt;Inventory&gt; vi;
  generate_n(back_inserter(vi), 15, InvenGen());
  print(vi, <font color=#004488>"vi"</font>);
  InvAccum ia = for_each(vi.begin(),vi.end(),
    InvAccum());
  cout &lt;&lt; ia &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>InvAccum</B>&#8217;s
<B>operator(&#160;)</B> takes a single argument, as required by
<B>for_each(&#160;)</B>. As <B>for_each(&#160;)</B> moves through its range, it
takes each object in that range and passes it to
<B>InvAccum::operator(&#160;)</B>, which performs calculations and saves the
result. At the end of this process, <B>for_each(&#160;)</B> returns the
<B>InvAccum</B> object which you can then examine; in this case it is simply
printed.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I293">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I294"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can do most things to the
<B>Inventory</B> objects using <B>for_each(&#160;)</B>. For example, if you
wanted to increase all the prices by 10%, <B>for_each(&#160;)</B> could do this
handily. But you&#8217;ll notice that the <B>Inventory</B> objects have no way
to change the <B>item</B> value. The programmers who designed <B>Inventory</B>
thought this was a good idea, after all, why would you want to change the name
of an item? But marketing has decided that they want a &#8220;new,
improved&#8221; look by changing all the item names to uppercase; they&#8217;ve
done studies and determined that the new names will boost sales (well, marketing
has to have <I>something</I> to do ...). So <B>for_each(&#160;)</B> will not
work here, but <B>transform(&#160;)</B>
will:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I294">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I295"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:TransformNames.cpp</font>
<font color=#009900>// More use of transform()</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-g++295}</font>
<font color=#009900>//{-msc}</font>
#include <font color=#004488>"Inventory.h"</font>
#include <font color=#004488>"PrintSequence.h"</font>
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cctype&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>struct</font> NewImproved {
  Inventory <font color=#0000ff>operator</font>()(<font color=#0000ff>const</font> Inventory&amp; inv) {
    <font color=#0000ff>return</font> Inventory(toupper(inv.getItem()), 
      inv.getQuantity(), inv.getValue());
  }
};

<font color=#0000ff>int</font> main() {
  vector&lt;Inventory&gt; vi;
  generate_n(back_inserter(vi), 15, InvenGen());
  print(vi, <font color=#004488>"vi"</font>);
  transform(vi.begin(), vi.end(), vi.begin(),
    NewImproved());
  print(vi, <font color=#004488>"vi"</font>);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Notice that the resulting range is the
same as the input range, that is, the transformation is performed
in-place.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I295">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I296"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now suppose that the sales department
needs to generate special price lists with different discounts for each item.
The original list must stay the same, and there need to be any number of
generated special lists. Sales will give you a separate list of discounts for
each new list. To solve this problem we can use the second version of
<B>transform(&#160;)</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I296">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I297"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:SpecialList.cpp</font>
<font color=#009900>// Using the second version of transform()</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-g++295}</font>
<font color=#009900>//{-msc}</font>
#include <font color=#004488>"Inventory.h"</font>
#include <font color=#004488>"PrintSequence.h"</font>
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>struct</font> Discounter {
  Inventory <font color=#0000ff>operator</font>()(<font color=#0000ff>const</font> Inventory&amp; inv,
    <font color=#0000ff>float</font> discount) {
    <font color=#0000ff>return</font> Inventory(inv.getItem(), 
      inv.getQuantity(), 
      inv.getValue() * (1 - discount));
  }
};

<font color=#0000ff>struct</font> DiscGen {
  DiscGen() { srand(time(0)); }
  <font color=#0000ff>float</font> <font color=#0000ff>operator</font>()() {
    <font color=#0000ff>float</font> r = <font color=#0000ff>float</font>(rand() % 10);
    <font color=#0000ff>return</font> r / 100.0;
  }
};

<font color=#0000ff>int</font> main() {
  vector&lt;Inventory&gt; vi;
  generate_n(back_inserter(vi), 15, InvenGen());
  print(vi, <font color=#004488>"vi"</font>);
  vector&lt;<font color=#0000ff>float</font>&gt; disc;
  generate_n(back_inserter(disc), 15, DiscGen());
  print(disc, <font color=#004488>"Discounts:"</font>);
  vector&lt;Inventory&gt; discounted;
  transform(vi.begin(),vi.end(), disc.begin(), 
    back_inserter(discounted), Discounter());
  print(discounted, <font color=#004488>"discounted"</font>);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Discounter</B> is a function object
that, given an <B>Inventory</B> object and a discount percentage, produces a new
<B>Inventory</B> with the discounted price. <B>DiscGen</B> just generates random
discount values between 1 and 10 percent to use for testing. In
<B>main(&#160;)</B>, two <B>vector</B>s are created, one for <B>Inventory</B>
and one for discounts. These are passed to <B>transform(&#160;)</B> along with a
<B>Discounter</B> object, and <B>transform(&#160;) </B>fills a new
<B>vector&lt;Inventory&gt;</B> called
<B>discounted</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I297">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I298"></a>
</FONT><A NAME="_Toc519042074"></A><BR></P></DIV>
<A NAME="Heading280"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Numeric algorithms</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">These algorithms are all tucked into the
header <B>&lt;numeric&gt;</B>, since they are primarily useful for performing
numerical calculations.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I298">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I299"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>&lt;numeric&gt;</B></FONT><BR><FONT FACE="Georgia"><B>T
accumulate(InputIterator first, InputIterator last, T
result);</B></FONT><BR><FONT FACE="Georgia"><B>T accumulate(InputIterator first,
InputIterator last, T result, </B></FONT><BR><FONT FACE="Georgia"><B>   
BinaryFunction f);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I299">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I300"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first form is a generalized
summation; for each element pointed to by an iterator <B>i</B> in <B>[first,
last)</B>, it performs the operation <B>result = result + *i</B>, where
<B>result</B> is of type <B>T</B>. However, the second form is more general; it
applies the function <B>f(result, *i)</B> on each element <B>*i</B> in the range
from beginning to end. The value <B>result</B> is initialized in both cases by
<B>resultI</B>, and if the range is empty then <B>resultI</B> is
returned.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I300">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I301"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note the similarity between the second
form of <B>transform(&#160;)</B> and the second form of
<B>accumulate(&#160;)</B>.

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I301">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I302"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>&lt;numeric&gt;</B></FONT><BR><FONT FACE="Georgia"><B>T
inner_product(InputIterator1 first1, InputIterator1 last1,
</B></FONT><BR><FONT FACE="Georgia"><B>    InputIterator2 first2, T
init);</B></FONT><BR><FONT FACE="Georgia"><B>T inner_product(InputIterator1
first1, InputIterator1 last1, </B></FONT><BR><FONT FACE="Georgia"><B>   
InputIterator2 first2, T init</B></FONT><BR><FONT FACE="Georgia"><B>   
BinaryFunction1 op1, BinaryFunction2
op2);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I302">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I303"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Calculates a generalized inner product of
the two ranges <B>[first1, last1)</B> and <B>[first2, first2 + (last1 -
first1))</B>. The return value is produced by multiplying the element from the
first sequence by the &#8220;parallel&#8221; element in the second sequence, and
then adding it to the sum. So if you have two sequences {1, 1, 2, 2} and {1, 2,
3, 4} the inner product
becomes:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I303">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I304"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>(1*1) + (1*2) + (2*3) + (2*4)</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Which is 17. The <B>init</B> argument is
the initial value for the inner product; this is probably zero but may be
anything and is especially important for an empty first sequence, because then
it becomes the default return value. The second sequence must have at least as
many elements as the
first.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I304">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I305"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">While the first form is very specifically
mathematical, the second form is simply a multiple application of functions and
could conceivably be used in many other situations. The <B>op1</B> function is
used in place of addition, and <B>op2</B> is used instead of multiplication.
Thus, if you applied the second version of <B>inner_product(&#160;)</B> to the
above sequence, the result would be the following
operations:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I305">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I306"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>init = op1(init, op2(1,1));
init = op1(init, op2(1,2));
init = op1(init, op2(2,3));
init = op1(init, op2(2,4));</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Thus it&#8217;s similar to
<B>transform(&#160;)</B> but two operations are performed instead of
one.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I306">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I307"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><B>&lt;numeric&gt;</B><BR><B>OutputIterator
partial_sum(InputIterator first, InputIterator last, </B><BR><B>   
OutputIterator result);</B><BR><B>OutputIterator partial_sum(InputIterator
first, InputIterator last, </B><BR><B>    OutputIterator result,  BinaryFunction
op);</B><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Calculates a generalized partial sum.
This means that a new sequence is created, beginning at <B>result</B>, where
each element is the sum of all the elements up to the currently selected element
in <B>[first, last)</B>. For example, if the original sequence is <B>{1, 1, 2,
2, 3}</B> then the generated sequence is <B>{1, 1 + 1, 1 + 1 + 2, 1 + 1 + 1 + 2
+ 2, 1 + 1 + 1 + 2 + 2 + 3}</B>, that is, <B>{1, 2, 4, 6,
9}</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I307">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I308"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the second version, the binary
function <B>op</B> is used instead of the <B>+</B> operator to take all the
&#8220;summation&#8221; up to that point and combine it with the new value. For
example, if you use <B>multiplies&lt;int&gt;(&#160;)</B> as the object for the
above sequence, the output is <B>{1, 1, 2, 4, 12}</B>. Note that the first
output value is always the same as the first input
value.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I308">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I309"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The return value is the end of the output
range <B>[result, result + (last - first)
)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I309">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I310"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>&lt;numeric&gt;</B></FONT><BR><FONT FACE="Georgia"><B>OutputIterator
adjacent_difference(InputIterator first, InputIterator last,
</B></FONT><BR><FONT FACE="Georgia"><B>    OutputIterator
result);</B></FONT><BR><FONT FACE="Georgia"><B>OutputIterator
adjacent_difference(InputIterator first, InputIterator
last,</B></FONT><BR><FONT FACE="Georgia"><B>    OutputIterator result,
BinaryFunction op);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I310">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I311"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Calculates the differences of adjacent
elements throughout the range <B>[first, last)</B>. This means that in the new
sequence, the value is the value of the difference of the current element and
the previous element in the original sequence (the first value is the same). For
example, if the original sequence is <B>{1, 1, 2, 2, 3}</B>, the resulting
sequence is <B>{1, 1 &#8211; 1, 2 &#8211; 1, 2 &#8211; 2, 3 &#8211; 2}</B>, that
is: <B>{1, 0, 1, 0,
1}</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I311">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I312"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second form uses the binary function
<B>op</B> instead of the <B>&#8211;</B> operator to perform the
&#8220;differencing.&#8221; For example, if you use
<B>multiplies&lt;int&gt;(&#160;)</B> as the function object for the above
sequence, the output is <B>{1, 1, 2, 4,
6}</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I312">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I313"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The return value is the end of the output
range <B>[result, result + (last - first)
)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I313">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I314"></a>
</FONT><BR></P></DIV>
<A NAME="Heading281"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Example</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This program tests all the algorithms in
<B>&lt;numeric&gt;</B> in both forms, on integer arrays. You&#8217;ll notice
that in the test of the form where you supply the function or functions, the
function objects used are the ones that produce the same result as form one so
the results produced will be exactly the same. This should also demonstrate a
bit more clearly the operations that are going on, and how to substitute your
own operations.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I314">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I315"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:NumericTest.cpp</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-g++295}</font>
#include <font color=#004488>"PrintSequence.h"</font>
#include &lt;numeric&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;functional&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> a[] = { 1, 1, 2, 2, 3, 5, 7, 9, 11, 13 };
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> asz = <font color=#0000ff>sizeof</font> a / <font color=#0000ff>sizeof</font> a[0];
  print(a, a + asz, <font color=#004488>"a"</font>, <font color=#004488>" "</font>);
  <font color=#0000ff>int</font> r = accumulate(a, a + asz, 0);
  cout &lt;&lt; <font color=#004488>"accumulate 1: "</font> &lt;&lt; r &lt;&lt; endl;
  <font color=#009900>// Should produce the same result:</font>
  r = accumulate(a, a + asz, 0, plus&lt;<font color=#0000ff>int</font>&gt;());
  cout &lt;&lt; <font color=#004488>"accumulate 2: "</font> &lt;&lt; r &lt;&lt; endl;
  <font color=#0000ff>int</font> b[] = { 1, 2, 3, 4, 1, 2, 3, 4, 1, 2 };
  print(b, b + <font color=#0000ff>sizeof</font> b / <font color=#0000ff>sizeof</font> b[0], <font color=#004488>"b"</font>, <font color=#004488>" "</font>);
  r = inner_product(a, a + asz, b, 0);
  cout &lt;&lt; <font color=#004488>"inner_product 1: "</font> &lt;&lt; r &lt;&lt; endl;
  <font color=#009900>// Should produce the same result:</font>
  r = inner_product(a, a + asz, b, 0, 
    plus&lt;<font color=#0000ff>int</font>&gt;(), multiplies&lt;<font color=#0000ff>int</font>&gt;());
  cout &lt;&lt; <font color=#004488>"inner_product 2: "</font> &lt;&lt; r &lt;&lt; endl;
  <font color=#0000ff>int</font>* it = partial_sum(a, a + asz, b);
  print(b, it, <font color=#004488>"partial_sum 1"</font>, <font color=#004488>" "</font>);
  <font color=#009900>// Should produce the same result:</font>
  it = partial_sum(a, a + asz, b, plus&lt;<font color=#0000ff>int</font>&gt;());
  print(b, it, <font color=#004488>"partial_sum 2"</font>, <font color=#004488>" "</font>);
  it = adjacent_difference(a, a + asz, b);
  print(b, it, <font color=#004488>"adjacent_difference 1"</font>,<font color=#004488>" "</font>);
  <font color=#009900>// Should produce the same result:</font>
  it = adjacent_difference(a, a + asz, b, 
    minus&lt;<font color=#0000ff>int</font>&gt;());
  print(b, it, <font color=#004488>"adjacent_difference 2"</font>,<font color=#004488>" "</font>);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that the return value of
<B>inner_product(&#160;)</B> and <B>partial_sum(&#160;)</B> is the past-the-end
iterator for the resulting sequence, so it is used as the second iterator in the
<B>print(&#160;)</B>
function.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I315">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I316"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since the second form of each function
allows you to provide your own function object, only the first form of the
functions is purely &#8220;numeric.&#8221; You could conceivably do some things
that are not intuitively numeric with something like
<B>inner_product(&#160;)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I316">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I317"></a>
</FONT><A NAME="_Toc519042075"></A><BR></P></DIV>
<A NAME="Heading282"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
General utilities</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Finally, here are some basic tools that
are used with the other algorithms; you may or may not use them directly
yourself.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I317">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I318"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>&lt;utility&gt;</B></FONT><BR><FONT FACE="Georgia"><B>struct
pair;</B></FONT><BR><FONT FACE="Georgia"><B>make_pair(&#160;);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I318">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I319"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This was described and used in the
previous chapter and in this one. A <B>pair</B> is simply a way to package two
objects (which may be of different types) together into a single object. This is
typically used when you need to return more than one object from a function, but
it can also be used to create a container that holds <B>pair </B>objects, or to
pass more than one object as a single argument. You access the elements by
saying <B>p.first</B> and <B>p.second</B>, where <B>p</B> is the <B>pair</B>
object. The function <B>equal_range(&#160;)</B>, described in the last chapter
and in this one, returns its result as a <B>pair</B> of iterators. You can
<B>insert(&#160;)</B> a <B>pair</B> directly into a <B>map</B> or
<B>multimap</B>; a <B>pair</B> is the <B>value_type</B> for those
containers.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I319">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I320"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you want to create a <B>pair</B>, you
typically use the template function <B>make_pair(&#160;)</B> rather than
explicitly constructing a <B>pair</B>
object.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I320">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I321"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>&lt;iterator&gt;</B></FONT><BR><FONT FACE="Georgia"><B>distance(InputIterator
first, InputIterator
last);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I321">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I322"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Tells you the number of elements between
<B>first</B> and <B>last</B>. More precisely, it returns an integral value that
tells you the number of times <B>first</B> must be incremented before it is
equal to <B>last</B>. No dereferencing of the iterators occurs during this
process.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I322">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I323"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>&lt;iterator&gt;</B></FONT><BR><FONT FACE="Georgia"><B>void
advance(InputIterator&amp; i, Distance
n);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I323">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I324"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Moves the iterator <B>i</B> forward by
the value of <B>n</B> (the iterator can also be moved backward for negative
values of <B>n</B> if the iterator is also a bidirectional iterator). This
algorithm is aware of bidirectional iterators, and will use the most efficient
approach.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I324">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I325"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>&lt;iterator&gt;</B></FONT><BR><FONT FACE="Georgia"><B>back_insert_iterator&lt;Container&gt;
back_inserter(Container&amp;
x);</B></FONT><BR><FONT FACE="Georgia"><B>front_insert_iterator&lt;Container&gt;
front_inserter(Container&amp;
x);</B></FONT><BR><FONT FACE="Georgia"><B>insert_iterator&lt;Container&gt;
inserter(Container&amp; x, Iterator
i);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I325">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I326"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">These functions are used to create
iterators for the given containers that will insert elements into the container,
rather than overwrite the existing elements in the container using <B>operator=
</B>(which is the default behavior). Each type of iterator uses a different
operation for insertion: <B>back_insert_iterator</B> uses
<B>push_back(&#160;)</B>, <B>front_insert_iterator</B> uses
<B>push_front(&#160;)</B> and <B>insert_iterator</B> uses <B>insert(&#160;)</B>
(and thus it can be used with the associative containers, while the other two
can be used with sequence containers). These were shown in some detail in the
previous chapter, and also used in this
chapter.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I326">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I327"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>const LessThanComparable&amp;
min(const LessThanComparable&amp; a, </B></FONT><BR><FONT FACE="Georgia"><B>   
const LessThanComparable&amp; b);</B></FONT><BR><FONT FACE="Georgia"><B>const
T&amp; min(const T&amp; a, const T&amp; b, BinaryPredicate
binary_pred);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I327">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I328"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Returns the lesser of its two arguments,
or the first argument if the two are equivalent. The first version performs
comparisons using <B>operator&lt;</B> and the second passes both arguments to
<B>binary_pred</B> to perform the
comparison.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I328">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I329"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">const LessThanComparable&amp; max(const
LessThanComparable&amp; a, </FONT><BR><FONT FACE="Georgia">    const
LessThanComparable&amp; b);</FONT><BR><FONT FACE="Georgia">const T&amp;
max(const T&amp; a, const T&amp; b, BinaryPredicate
binary_pred);</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Exactly like <B>min(&#160;)</B>, but
returns the greater of its two
arguments.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I329">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I330"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>void swap(Assignable&amp; a,
Assignable&amp; b);</B></FONT><BR><FONT FACE="Georgia"><B>void
iter_swap(ForwardIterator1 a, ForwardIterator2
b);</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I330">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I331"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Exchanges the values of <B>a</B> and
<B>b</B> using assignment. Note that all container classes use specialized
versions of <B>swap(&#160;)</B> that are typically more efficient than this
general version.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I331">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I332"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>iter_swap(&#160;)</B> is a
backwards-compatible remnant in the standard; you can just use
<B>swap(&#160;)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I332">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I333"></a>
</FONT><A NAME="_Toc519042076"></A><BR></P></DIV>
<A NAME="Heading283"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Creating your own STL-style algorithms</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once you become comfortable with the STL
algorithm style, you can begin to create your own STL-style algorithms. Because
these will conform to the format of all the other algorithms in the STL,
they&#8217;re easy to use for programmers who are familiar with the STL, and
thus become a way to &#8220;extend the STL
vocabulary.&#8221;
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I333">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I334"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The easiest way to approach the problem
is to go to the <B>&lt;algorithm&gt;</B> header file and find something similar
to what you need, and modify that (virtually all STL implementations provide the
code for the templates directly in the header files). For example, an algorithm
that stands out by its absence is <B>copy_if(&#160;) </B>(the closest
approximation is <B>partition(&#160;)</B>), which was used in <B>Binder1.cpp</B>
at the beginning of this chapter, and in several other examples in this chapter.
This will only copy an element if it satisfies a predicate. Here&#8217;s an
implementation:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I334">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I335"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C08:copy_if.h</font>
<font color=#009900>// Roll your own STL-style algorithm</font>
#ifndef COPY_IF_H
#define COPY_IF_H

<font color=#0000ff>template</font>&lt;<font color=#0000ff>typename</font> ForwardIter,
  <font color=#0000ff>typename</font> OutputIter, <font color=#0000ff>typename</font> UnaryPred&gt;
OutputIter copy_if(ForwardIter begin, ForwardIter end,
  OutputIter dest, UnaryPred f) {
  <font color=#0000ff>while</font>(begin != end) {
    <font color=#0000ff>if</font>(f(*begin))
      *dest++ = *begin;
    begin++;
  }
  <font color=#0000ff>return</font> dest;
}
#endif <font color=#009900>// COPY_IF_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The return value is the past-the-end
iterator for the destination sequence (the copied
sequence).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I335">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I336"></a>
</FONT><BR></P></DIV>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now that you&#8217;re comfortable with
the ideas of the various iterator types, the actual implementation is quite
straightforward. You can imagine creating an entire additional library of your
own useful algorithms that follow the format of the
STL.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I336">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I337"></a>
</FONT><A NAME="_Toc519042077"></A><BR></P></DIV>
<A NAME="Heading284"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Summary</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The goal of this chapter, and the
previous one, was to give you a programmer&#8217;s-depth understanding of the
containers and algorithms in the Standard Template Library. That is, to make you
aware of and comfortable enough with the STL that you begin to use it on a
regular basis (or at least, to think of using it so you can come back here and
hunt for the appropriate solution). It is powerful not only because it&#8217;s a
reasonably complete library of tools, but also because it provides a vocabulary
for thinking about problem solutions, and because it is a framework for creating
additional tools.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I337">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I338"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although this chapter and the last did
show some examples of creating your own tools, I did not go into the full depth
of the theory of the STL that is necessary to completely understand all the STL
nooks and crannies to allow you to create tools more sophisticated than those
shown here. I did not do this partially because of space limitations, but mostly
because it is beyond the charter of this book; my goal here is to give you
practical understanding that will affect your day-to-day programming
skills.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I338">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I339"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are a number of books dedicated
solely to the STL (these are listed in the appendices), but the two that I
learned the most from, in terms of the theory necessary for tool creation, were
first, <I>Generic Programming and the STL</I> by Matthew H. Austern,
Addison-Wesley 1999 (this also covers all the SGI extensions, which Austern was
instrumental in creating), and second (older and somewhat out of date, but still
quite valuable), <I>C++ Programmer&#8217;s Guide to the Standard Template
Library</I> by Mark Nelson, IDG press
1995.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I339">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I340"></a>
</FONT><A NAME="_Toc519042078"></A><BR></P></DIV>
<A NAME="Heading285"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Exercises</H2></FONT>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create a generator that
returns the current value of <B>clock(&#160;)</B> (in <B>&lt;ctime&gt;</B>).
Create a <B>list&lt;clock_t&gt;</B> and fill it with your generator using
<B>generate_n(&#160;)</B>. Remove any duplicates in the list and print it to
<B>cout</B> using
<B>copy(&#160;)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I340">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I341"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>Stlshape.cpp</B> from chapter XXX so that it uses <B>transform(&#160;)</B> to
delete all its
objects.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I341">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I342"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Using
<B>transform(&#160;)</B> and <B>toupper(&#160;)</B> (in <B>&lt;cctype&gt;</B>)
write a single function call that will convert a string to all uppercase
letters.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I342">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I343"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
a <B>Sum</B> function object template that will accumulate all the values in a
range when used with
<B>for_each(&#160;)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I343">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I344"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Write
an anagram generator that takes a word as a command-line argument and produces
all possible permutations of the
letters.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I344">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I345"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Write
a &#8220;sentence anagram generator&#8221; that takes a sentence as a
command-line argument and produces all possible permutations of the words in the
sentence (it leaves the words alone, just moves them
around).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I345">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I346"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
a class hierarchy with a base class <B>B</B> and a derived class <B>D</B>. Put a
<B>virtual</B> member function <B>void f(&#160;)</B> in <B>B</B> such that it
will print a message indicating that <B>B</B>&#8217;s <B>f(&#160;)</B> has been
called, and redefine this function for <B>D</B> to print a different message.
Create a <B>deque&lt;B*&gt;</B> and fill it with <B>B</B> and <B>D</B> objects.
Use <B>for_each(&#160;)</B> to call <B>f(&#160;)</B> for each of the objects in
your
deque.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I346">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I347"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>FunctionObjects.cpp</B> so that it uses <B>float</B> instead of
<B>int</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I347">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I348"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>FunctionObjects.cpp</B> so that it templatizes the main body of tests so you
can choose which type you&#8217;re going to test (you&#8217;ll have to pull most
of <B>main(&#160;)</B> out into a separate template
function).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I348">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I349"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Using
<B>transform(&#160;)</B>, <B>toupper(&#160;)</B>  and <B>tolower(&#160;)</B> (in
<B>&lt;ccytpe&gt;</B>), create two functions such that the first takes a string
object and returns that string with all the letters in uppercase, and the second
returns a string with all the letters in
lowercase.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I349">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I350"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
a container of containers of <B>Noisy </B>objects, and sort them. Now write a
template for your sorting test (to use with the three basic sequence
containers), and compare the performance of the different container
types.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I350">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I351"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Write
a program that takes as a command line argument the name of a text file. Open
this file and read it a word at a time (hint: use <B>&gt;&gt;</B>). Store each
word into a <B>deque&lt;string&gt;</B>. Force all the words to lowercase, sort
them, remove all the duplicates and print the
results.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I351">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I352"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Write
a program that finds all the words that are in common between two input files,
using <B>set_intersection(&#160;)</B>. Change it to show the words that are not
in common, using
<B>set_symmetric_difference(&#160;)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I352">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I353"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
a program that, given an integer on the command line, creates a &#8220;factorial
table&#8221; of all the factorials up to and including the number on the command
line. To do this, write a generator to fill a <B>vector&lt;int&gt;</B>, then use
<B>partial_sum(&#160;)</B> with a standard function
object.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I353">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I354"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>CalcInventory.cpp</B> so that it will find all the objects that have a
quantity that&#8217;s less than a certain amount. Provide this amount as a
command-line argument, and use <B>copy_if(&#160;)</B> and <B>bind2nd(&#160;)</B>
to create the collection of values less than the target
value.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I354">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I355"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
template function objects that perform bitwise operations for &amp;, |, ^ and ~.
Test these with a
bitset.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I355">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I356"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Fill
a vector&lt;double&gt; with numbers representing angles in radians. Using
function object composition, take the sine of all the elements in your vector
(see
&lt;cmath&gt;).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I356">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I357"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
a map which is a cosine table where the keys are the angles in degrees and the
values are the cosines. Use transform(&#160;) with cos(&#160;) (in
&lt;cmath&gt;) to fill the
table.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I357">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I358"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Write
a program to compare the speed of sorting a list using list::sort(&#160;) vs.
using std::sort(&#160;) (the STL algorithm version of sort(&#160;)). Hint: see
the timing examples in the previous
chapter.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I358">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I359"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
and test a logical_xor function object template to implement a logical
exclusive-or.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I359">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I360"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
an STL-style algorithm transform_if(&#160;) following the first form of
transform(&#160;) which only performs transformations on objects that satisfy a
unary
predicate.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I360">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I361"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
an STL-style algorithm which is an overloaded version of for_each(&#160;) that
follows the second form of transform(&#160;) and takes two input ranges so it
can pass the objects of the second input range a to a binary function which it
applies to each object of the first
range.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I361">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I362"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
a Matrix class which is made from a vector&lt;vector&lt;int&gt; &gt;. Provide it
with a friend ostream&amp; operator&lt;&lt;(ostream&amp;, const Matrix&amp;) to
display the matrix. Create the following using the STL algorithms where possible
(you may need to look up the mathematical meanings of the matrix operations if
you don&#8217;t remember them): operator+(const Matrix&amp;, const Matrix&amp;)
for Matrix addition, operator*(const Matrix&amp;, const vector&lt;int&gt;&amp;)
for multiplying a matrix by a vector, and operator*(const Matrix&amp;, const
Matrix&amp;) for matrix multiplication. Demonstrate
each.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I362">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER8_I363"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Templatize
the Matrix class and associated operations from the previous example so they
will work with any appropriate
type.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER8_I363">Comment</a>&nbsp;]

</FONT></OL><DIV ALIGN="CENTER">
    <FONT FACE="Verdana, Tahoma, Arial, Helvetica, Sans" size = "-1">
     [ <a href="Chap07.htm">Previous Chapter</a> ] 
    
    [ <a href="SimpCont.htm">Short TOC</a> ] 
    [ <a href="Contents.htm">Table of Contents</a> ] 
  
        [ <a href="DocIdx.htm">Index</a> ]
        
     [ <a href="Part3.htm">Next Chapter</a> ] 
    </FONT>
    <BR>
 Last Update:08/19/2001</P></DIV>

</BODY>

</HTML>

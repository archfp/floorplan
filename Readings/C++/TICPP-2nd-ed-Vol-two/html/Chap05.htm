<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:C:\TEMP\TicV2\html\TicV2.rtf
Application Directory:C:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:08/19/2001
Translation Time:14:24:55
Translation Platform:Win32
Number of Output files:19
This File:C:\TEMP\TicV2\html\Chap05.htm
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html">
<TITLE>5: Iostreams</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF"><DIV ALIGN="CENTER">
  <a href="http://www.MindView.net">
  <img src="mindview.gif" alt="MindView Inc." BORDER = "0"></a>
  <CENTER>
    <FONT FACE="Verdana, Tahoma, Arial, Helvetica, Sans" size = "-1">
    [ <a href="README.txt">Viewing Hints</a> ]
    [ <a href="RevisionHistory.htm">Revision History</a> ]
    [ <a href="http://www.mindview.net/Books/TICPP/ThinkingInCPP2e.html">Book Home Page</a> ]
    [ <a href="http://www.mindview.net/Etc/MailingList.html">Free Newsletter</a> ] <br>
    [ <a href="http://www.mindview.net/Seminars">Seminars</a> ]
    [ <a href="http://www.mindview.net/CDs">Seminars on CD ROM</a> ]
    [ <a href="http://www.mindview.net/Services">Consulting</a> ]
    </FONT>
  <H2><FONT FACE="Verdana, Tahoma, Arial, Helvetica, Sans">
  Thinking in C++, 2nd edition, Volume 2<br>
  <small>Revision 4.0</small></FONT></H2>
  <H3><FONT FACE="Verdana, Tahoma, Arial, Helvetica, Sans">
  by Bruce Eckel &amp; Chuck Allison<br>&copy;2001 MindView, Inc.</FONT></H3>
  
    <FONT FACE="Verdana, Tahoma, Arial, Helvetica, Sans" size = "-1">
     [ <a href="Chap04.htm">Previous Chapter</a> ] 
    
    [ <a href="SimpCont.htm">Short TOC</a> ] 
    [ <a href="Contents.htm">Table of Contents</a> ] 
  
        [ <a href="DocIdx.htm">Index</a> ]
        
     [ <a href="Chap06.htm">Next Chapter</a> ] 
    </FONT>
    
  </CENTER>
  </P></DIV><A NAME="_Toc305628662"></A><A NAME="_Toc312373873"></A><A NAME="_Toc519041941"></A><A NAME="Heading105"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H1 ALIGN="LEFT">
5: Iostreams</H1></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana" SIZE=4><a NAME="TIC2V2_CHAPTER5_I1"></a>
There&#8217;s
much more you can do with the general I/O problem than just take standard I/O
and turn it into a class. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Wouldn&#8217;t it be nice if you could
make all the usual &#8220;receptacles&#8221; &#8211; standard I/O, files and
even blocks of memory &#8211; look the same, so you need to remember only one
interface? That&#8217;s the idea behind iostreams. They&#8217;re much easier,
safer, and often more efficient than the assorted functions from the Standard C
stdio library.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I1">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I2"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Iostream is usually the first class
library that new C++ programmers learn to use. This chapter explores the
<I>use</I> of iostreams, so they can replace the C I/O functions through the
rest of the book. In future chapters, you&#8217;ll see how to set up your own
classes so they&#8217;re compatible with
iostreams.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I2">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I3"></a>
</FONT><A NAME="_Toc305628663"></A><A NAME="_Toc312373874"></A><A NAME="_Toc519041942"></A><BR></P></DIV>
<A NAME="Heading106"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Why iostreams?</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You may wonder what&#8217;s wrong with
the good old C library. And why not &#8220;wrap&#8221; the C library in a class
<A NAME="Index170"></A><A NAME="Index171"></A>and be done with it? Indeed, there
are situations when this is the perfect thing to do, when you want to make a C
library a bit safer and easier to use. For example, suppose you want to make
sure a stdio <A NAME="Index172"></A>file is always safely opened and properly
closed, without relying on the user to remember to call the <B>close(&#160;)</B>
function:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I3">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I4"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:FileClass.h</font>
<font color=#009900>// Stdio files wrapped</font>
#ifndef FILECLAS_H
#define FILECLAS_H
#include &lt;cstdio&gt;

<font color=#0000ff>class</font> FileClass {
  std::FILE* f;
<font color=#0000ff>public</font>:
  FileClass(<font color=#0000ff>const</font> <font color=#0000ff>char</font>* fname, <font color=#0000ff>const</font> <font color=#0000ff>char</font>* mode=<font color=#004488>"r"</font>);
  ~FileClass();
  std::FILE* fp();
};
#endif <font color=#009900>// FILECLAS_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In C when you perform file I/O, you work
with a naked pointer to a FILE <A NAME="Index173"></A><B>struct</B>, but this
class wraps around the pointer and guarantees it is properly initialized and
cleaned up using the constructor and destructor. The second constructor argument
is the file mode, which defaults to &#8220;r&#8221; for
&#8220;read.&#8221;
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I4">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I5"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To fetch the value of the pointer to use
in the file I/O functions, you use the <B>fp(&#160;)</B> access function. Here
are the member function
definitions:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I5">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I6"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:FileClass.cpp {O}</font>
<font color=#009900>// Implementation</font>
<font color=#009900>//{-msc}</font>
#include <font color=#004488>"FileClass.h"</font>
#include &lt;cstdlib&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

FileClass::FileClass(<font color=#0000ff>const</font> <font color=#0000ff>char</font>* fname, <font color=#0000ff>const</font> <font color=#0000ff>char</font>* mode){
  f = fopen(fname, mode);
  <font color=#0000ff>if</font>(f == NULL) {
    printf(<font color=#004488>"%s: file not found\n"</font>, fname);
    exit(1);
  }
}

FileClass::~FileClass() { fclose(f); }

FILE* FileClass::fp() { <font color=#0000ff>return</font> f; } <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The constructor calls
<B>fopen(&#160;)</B>,as you would normally do, but it also checks to ensure the
result isn&#8217;t zero, which indicates a failure upon opening the file. If
there&#8217;s a failure, the name of the file is printed and <B>exit(&#160;)</B>
is called.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I6">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I7"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The destructor closes the file, and the
access function <B>fp(&#160;)</B>returns <B>f</B>. Here&#8217;s a simple example
using <B>class
FileClass</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I7">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I8"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:FileClassTest.cpp</font>
<font color=#009900>//{L} FileClass ../TestSuite/Test</font>
<font color=#009900>//{-msc}</font>
<font color=#009900>// Testing class File</font>
#include <font color=#004488>"FileClass.h"</font>
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#009900>// Opens and tests:</font>
  FileClass f(<font color=#004488>"FileClassTest.cpp"</font>); 
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> bsize = 100;
  <font color=#0000ff>char</font> buf[bsize];
  <font color=#0000ff>while</font>(fgets(buf, bsize, f.fp()))
    puts(buf);
} <font color=#009900>// File automatically closed by destructor</font>
<font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You create the <B>FileClass</B> object
and use it in normal C file I/O function calls by calling <B>fp(&#160;)</B>.
When you&#8217;re done with it, just forget about it, and the file is closed by
the destructor at the end of the
scope.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I8">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I9"></a>
</FONT><A NAME="_Toc312373875"></A><A NAME="_Toc519041943"></A><BR></P></DIV>
<A NAME="Heading107"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
True wrapping</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Even though the FILE pointer is private,
it isn&#8217;t particularly safe because <B>fp(&#160;)</B> retrieves it. The
only effect seems to be guaranteed initialization and cleanup, so why not make
it public, or use a <B>struct</B> instead? Notice that while you can get a copy
of <B>f</B> using <B>fp(&#160;)</B>, you cannot assign to <B>f</B> &#8211;
that&#8217;s completely under the control of the class. Of course, after
capturing the pointer returned by <B>fp(&#160;)</B>, the client programmer can
still assign to the structure elements, so the safety is in guaranteeing a valid
FILE pointer rather than proper contents of the
structure.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I9">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I10"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you want complete safety, you have to
prevent the user from direct access to the FILE pointer. This means some version
of all the normal file I/O functions will have to show up as class members, so
everything you can do with the C approach is available in the C++
class:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I10">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I11"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:Fullwrap.h</font>
<font color=#009900>// Completely hidden file IO</font>
#ifndef FULLWRAP_H
#define FULLWRAP_H

<font color=#0000ff>class</font> File {
  std::FILE* f;
  std::FILE* F(); <font color=#009900>// Produces checked pointer to f</font>
<font color=#0000ff>public</font>:
  File(); <font color=#009900>// Create object but don't open file</font>
  File(<font color=#0000ff>const</font> <font color=#0000ff>char</font>* path,
       <font color=#0000ff>const</font> <font color=#0000ff>char</font>* mode = <font color=#004488>"r"</font>);
  ~File();
  <font color=#0000ff>int</font> open(<font color=#0000ff>const</font> <font color=#0000ff>char</font>* path,
           <font color=#0000ff>const</font> <font color=#0000ff>char</font>* mode = <font color=#004488>"r"</font>);
  <font color=#0000ff>int</font> reopen(<font color=#0000ff>const</font> <font color=#0000ff>char</font>* path,
             <font color=#0000ff>const</font> <font color=#0000ff>char</font>* mode);
  <font color=#0000ff>int</font> getc();
  <font color=#0000ff>int</font> ungetc(<font color=#0000ff>int</font> c);
  <font color=#0000ff>int</font> putc(<font color=#0000ff>int</font> c);
  <font color=#0000ff>int</font> puts(<font color=#0000ff>const</font> <font color=#0000ff>char</font>* s);
  <font color=#0000ff>char</font>* gets(<font color=#0000ff>char</font>* s, <font color=#0000ff>int</font> n);
  <font color=#0000ff>int</font> printf(<font color=#0000ff>const</font> <font color=#0000ff>char</font>* format, ...);
  size_t read(<font color=#0000ff>void</font>* ptr, size_t size,
              size_t n);
  size_t write(<font color=#0000ff>const</font> <font color=#0000ff>void</font>* ptr,
                size_t size, size_t n);
  <font color=#0000ff>int</font> eof();
  <font color=#0000ff>int</font> close();
  <font color=#0000ff>int</font> flush();
  <font color=#0000ff>int</font> seek(<font color=#0000ff>long</font> offset, <font color=#0000ff>int</font> whence);
  <font color=#0000ff>int</font> getpos(fpos_t* pos);
  <font color=#0000ff>int</font> setpos(<font color=#0000ff>const</font> fpos_t* pos);
  <font color=#0000ff>long</font> tell();
  <font color=#0000ff>void</font> rewind();
  <font color=#0000ff>void</font> setbuf(<font color=#0000ff>char</font>* buf);
  <font color=#0000ff>int</font> setvbuf(<font color=#0000ff>char</font>* buf, <font color=#0000ff>int</font> type, size_t sz);
  <font color=#0000ff>int</font> error();
  <font color=#0000ff>void</font> clearErr();
};
#endif <font color=#009900>// FULLWRAP_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This class contains almost all the file
I/O functions from <B>cstdio</B>. <B>vfprintf(&#160;)</B> is missing; it is used
to implement the <B>printf(&#160;)</B> <A NAME="Index174"></A>member
function.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I11">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I12"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>File</B> has the same constructor as
in the previous example, and it also has a default constructor. The default
constructor is important if you want to create an array of <B>File</B> objects
or use a <B>File</B> object as a member of another class where the
initialization doesn&#8217;t happen in the constructor (but sometime after the
enclosing object is
created).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I12">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I13"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The default constructor sets the private
<B>FILE</B> pointer <B>f</B> to zero. But now, before any reference to <B>f</B>,
its value must be checked to ensure it isn&#8217;t zero. This is accomplished
with the last member function in the class, <B>F(&#160;)</B>, which is
<B>private</B> because it is intended to be used only by other member functions.
(We don&#8217;t want to give the user direct access to the <B>FILE</B> structure
in this
class.)</FONT><A NAME="fnB10" HREF="#fn10">[10]</A><FONT FACE="Georgia">
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I13">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I14"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is not a terrible solution by any
means. It&#8217;s quite functional, and you could imagine making similar classes
for standard (console) I/O and for in-core formatting (reading/writing a piece
of memory rather than a file or the
console).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I14">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I15"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The big stumbling block is the runtime
interpreter<A NAME="Index175"></A>
<A NAME="Index176"></A><A NAME="Index177"></A>used for the variable-argument
list functions. This is the code that parses through your format string at
runtime and grabs and interprets arguments from the variable argument list.
It&#8217;s a problem for four
reasons.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I15">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I16"></a>
</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Even if you use only a
fraction of the functionality of the interpreter, the whole thing gets loaded.
So if you say:</FONT><BR><TT><FONT FACE="Courier New">printf("%c",
'x');</FONT></TT><BR><FONT FACE="Georgia">you&#8217;ll get the whole package,
including the parts that print out floating-point numbers and strings.
There&#8217;s no option for reducing the amount of space used by the
program.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Because the
interpretation happens at runtime there&#8217;s a performance overhead you
can&#8217;t get rid of. It&#8217;s frustrating because all the information is
<I>there</I> in the format string at compile time, but it&#8217;s not evaluated
until runtime. However, if you could parse the arguments in the format string at
compile time you could make hard function calls that have the potential to be
much faster than a runtime interpreter (although the <B>printf(&#160;)</B>
family of functions is usually quite well
optimized).</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">A worse
problem occurs because the evaluation of the format string doesn&#8217;t happen
until runtime: there can be no compile-time error
checkin</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">g<A NAME="Index178"></A><A NAME="Index179"></A>.
You&#8217;re probably very familiar with this problem if you&#8217;ve tried to
find bugs that came from using the wrong number or type of arguments in a
<B>printf(&#160;)</B> statement. C++ makes a big deal out of compile-time error
checking to find errors early and make your life easier. It seems a shame to
throw it away for an I/O library, especially because I/O is used a
lot.</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">For C++, the most
important problem is that the <B>printf(&#160;)</B> family of functions is not
particularly
extensibl</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">e<A NAME="Index180"></A>.
They&#8217;re really designed to handle the four basic data types
<A NAME="Index181"></A>in C <A NAME="Index182"></A>(<B>char</B>, <B>int</B>,
<B>float</B>, <B>double</B> and their variations). You might think that every
time you add a new class, you could add an overloaded <B>printf(&#160;)</B> and
<B>scanf(&#160;)</B> function (and their variants for files and strings) but
remember, overloaded functions must have different types in their argument lists
and the <B>printf(&#160;)</B> family hides its type information in the format
string and in the variable argument
list<A NAME="Index183"></A><A NAME="Index184"></A>. For a language like C++,
whose goal is to be able to easily add new data types, this is an ungainly
restriction.</FONT><A NAME="_Toc305628664"></A><A NAME="_Toc312373876"></A><A NAME="_Toc519041944"></A><BR></P></DIV>
<A NAME="Heading108"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Iostreams to the rescue</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All these issues make it clear that one
of the first standard class libraries for C++ should handle I/O. Because
&#8220;hello, world&#8221; is the first program just about everyone writes in a
new language, and because I/O is part of virtually every program, the I/O
library in C++ must be particularly easy to use. It also has the much greater
challenge that it can never know all the classes it must accommodate, but it
must nevertheless be adaptable to use any new class. Thus its constraints
required that this first class be a truly inspired
design.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I16">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I17"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This chapter won&#8217;t look at the
details of the design and how to add iostream functionality to your own classes
(you&#8217;ll learn that in a later chapter). First, you need to learn to use
iostreams. In addition to gaining a great deal of leverage and clarity in your
dealings with I/O and formatting, you&#8217;ll also see how a really powerful
C++ library can
work.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I17">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I18"></a>
</FONT><A NAME="_Toc312373877"></A><A NAME="_Toc519041945"></A><BR></P></DIV>
<A NAME="Heading109"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Sneak preview of operator overloading<BR><A NAME="Index185"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Before you can use the iostreams library,
you must understand one new feature of the language that won&#8217;t be covered
in detail until a later chapter. To use iostreams, you need to know that in C++
all the operators can take on different meanings. In this chapter, we&#8217;re
particularly interested in <B>&lt;&lt;</B> and <B>&gt;&gt;</B>. The statement
&#8220;operators can take on different meanings&#8221; deserves some extra
insight.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I18">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I19"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In Chapter XX, you learned how function
overloading allows you to use the same function name with different argument
lists. Now imagine that when the compiler sees an expression consisting of an
argument followed by an operator followed by an argument, it simply calls a
function. That is, an operator is simply a function call with a different
syntax.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I19">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I20"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, this is C++, which is very
particular about data types. So there must be a previously declared function to
match that operator and those particular argument types, or the compiler will
not accept the
expression.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I20">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I21"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What most people find immediately
disturbing about operator overloading is the thought that maybe everything they
know about operators in C is suddenly wrong. This is absolutely false. Here are
two of the sacred design goals of
C++<A NAME="Index186"></A><A NAME="Index187"></A>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I21">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I22"></a>
</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">A program that compiles in
C will compile in C++. The only compilation errors and warnings from the C++
compiler will result from the &#8220;holes&#8221; in the C language, and fixing
these will require only local editing. (Indeed, the complaints by the C++
compiler usually lead you directly to undiscovered bugs in the C
program.)</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">The C++
compiler will not secretly change the behavior of a C program by recompiling it
under C++.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Keeping these goals
in mind will help answer a lot of questions; knowing there are no capricious
changes to C when moving to C++ helps make the transition easy. In particular,
operators for built-in types won&#8217;t suddenly start working differently
&#8211; you cannot change their meaning. Overloaded operators can be created
only where new data types are involved. So you can create a new overloaded
operator for a new class, but the
expression
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I22">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I23"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>1 &lt;&lt; 4;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">won&#8217;t suddenly change its meaning,
and the illegal code
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I23">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I24"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>1.414 &lt;&lt; 1;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">won&#8217;t suddenly start
working.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I24">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I25"></a>
</FONT><A NAME="_Toc312373878"></A><A NAME="_Toc519041946"></A><BR></P></DIV>
<A NAME="Heading110"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Inserters and extractors</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the iostreams library, two operators
have been overloaded to make the use of iostreams easy. The operator
<B>&lt;&lt;</B> <A NAME="Index188"></A>is often referred to as an
<I>inserter</I> <A NAME="Index189"></A>for iostreams, and the operator
<B>&gt;&gt;</B> <A NAME="Index190"></A>is often referred to as an
<I>extractor<A NAME="Index191"></A></I>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I25">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I26"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <I>stream</I> <A NAME="Index192"></A>is
an object that formats and holds bytes. You can have an input stream
(<I>istream<A NAME="Index193"></A></I>) or an output stream
(<I>ostream<A NAME="Index194"></A></I>). There are different types of istreams
and ostreams: <I>ifstreams <A NAME="Index195"></A></I>and <I>ofstreams</I>
<A NAME="Index196"></A>for files<A NAME="Index197"></A>, <I>istrstreams
<A NAME="Index198"></A></I>, and <I>ostrstreams</I> <A NAME="Index199"></A>for
<B>char*</B> <A NAME="Index200"></A>memory (in-core formatting), and
<I>istringstreams</I> <A NAME="Index201"></A>&amp; <I>ostringstreams</I>
<A NAME="Index202"></A>for interfacing with the Standard C++ <B>string</B>
class<A NAME="Index203"></A><A NAME="Index204"></A><A NAME="Index205"></A><A NAME="Index206"></A>.
All these stream objects have the same interface, regardless of whether
you&#8217;re working with a file, standard I/O, a piece of memory or a
<B>string</B> object. The single interface you learn also works for extensions
added to support new
classes.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I26">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I27"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If a stream is capable of producing bytes
(an istream), you can get information from the stream using an extractor. The
extractor produces and formats the type of information that&#8217;s expected by
the destination object. To see an example of this, you can use the <B>cin</B>
object, which is the iostream equivalent of <B>stdin</B> in C, that is,
redirectable standard input. This object is pre-defined whenever you include the
<B>iostream.h </B>header file. (Thus, the iostream library is automatically
linked with most
compilers.)
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I27">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I28"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>  <font color=#0000ff>int</font> i;
  cin &gt;&gt; i;

  <font color=#0000ff>float</font> f;
  cin &gt;&gt; f;

  <font color=#0000ff>char</font> c;
  cin &gt;&gt; c;

  <font color=#0000ff>char</font> buf[100];
  cin &gt;&gt; buf;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s an overloaded <B>operator
&gt;&gt;</B> for every data type you can use as the right-hand argument of
<B>&gt;&gt;</B> in an iostream statement. (You can also overload your own, which
you&#8217;ll see in a later
chapter.)
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I28">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I29"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To find out what you have in the various
variables, you can use the <B>cout</B> object (corresponding to standard output;
there&#8217;s also a <B>cerr</B> object corresponding to standard error) with
the inserter
<B>&lt;&lt;</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I29">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I30"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>  cout &lt;&lt; <font color=#004488>"i = "</font>;
  cout &lt;&lt; i;
  cout &lt;&lt; <font color=#004488>"\n"</font>;
  cout &lt;&lt; <font color=#004488>"f = "</font>;
  cout &lt;&lt; f;
  cout &lt;&lt; <font color=#004488>"\n"</font>;
  cout &lt;&lt; <font color=#004488>"c = "</font>;
  cout &lt;&lt; c;
  cout &lt;&lt; <font color=#004488>"\n"</font>;
  cout &lt;&lt; <font color=#004488>"buf = "</font>;
  cout &lt;&lt; buf;
  cout &lt;&lt; <font color=#004488>"\n"</font>;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is notably tedious, and
doesn&#8217;t seem like much of an improvement over <B>printf(&#160;)</B>, type
checking or no. Fortunately, the overloaded inserters and extractors in
iostreams are designed to be chained <A NAME="Index207"></A>together into a
complex expression that is much easier to
write:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I30">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I31"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>  cout &lt;&lt; <font color=#004488>"i = "</font> &lt;&lt; i &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"f = "</font> &lt;&lt; f &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"c = "</font> &lt;&lt; c &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"buf = "</font> &lt;&lt; buf &lt;&lt; endl;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll understand how this can
happen in a later chapter, but for now it&#8217;s sufficient to take the
attitude of a class user and just know it works that
way.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I31">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I32"></a>
</FONT><BR></P></DIV>
<A NAME="Heading111"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Manipulators</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One new element has been added here: a
<I>manipulator</I> <A NAME="Index208"></A>called
<B>endl<A NAME="Index209"></A></B>. A manipulator acts on the stream itself; in
this case it inserts a newline and <I>flushes</I> the stream (puts out all
pending characters that have been stored in the internal stream buffer but not
yet output). You can also just flush
<A NAME="Index210"></A><A NAME="Index211"></A>the
stream:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I32">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I33"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE> cout &lt;&lt; flush;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are additional basic manipulators
that will change the number base to <B>oct</B> (octal)<A NAME="Index212"></A>,
<B>dec</B> (decimal)<A NAME="Index213"></A><A NAME="Index214"></A> or <B>hex</B>
(hexadecimal)<A NAME="Index215"></A><A NAME="Index216"></A>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I33">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I34"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE> cout &lt;&lt; hex &lt;&lt; <font color=#004488>"0x"</font> &lt;&lt; i &lt;&lt; endl;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s a manipulator for
extraction that &#8220;eats&#8221; white
space:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I34">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I35"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>cin &gt;&gt; ws;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">and a manipulator called
<B>ends<A NAME="Index217"></A></B>, <A NAME="Index218"></A>which is like
<B>endl</B>, only for strstreams (covered in a while). These are all the
manipulators in <B>&lt;iostream&gt;</B>, but there are more in
<B>&lt;iomanip&gt; </B>you&#8217;ll see later in the
chapter.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I35">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I36"></a>
</FONT><A NAME="_Toc312373879"></A><A NAME="_Toc519041947"></A><BR></P></DIV>
<A NAME="Heading112"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Common usage</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although <B>cin</B> and the extractor
<B>&gt;&gt;</B> provide a nice balance to <B>cout</B> and the inserter
<B>&lt;&lt;</B>, in practice using formatted input routines, especially with
standard input, has the same problems you run into with <B>scanf(&#160;)</B>. If
the input produces an unexpected value, the process is skewed, and it&#8217;s
very difficult to recover. In addition, formatted input defaults to whitespace
delimiters. So if you collect the above code fragments into a
program
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I36">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I37"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:Iosexamp.cpp</font>
<font color=#009900>// Iostream examples</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> i;
  cin &gt;&gt; i;

  <font color=#0000ff>float</font> f;
  cin &gt;&gt; f;

  <font color=#0000ff>char</font> c;
  cin &gt;&gt; c;

  <font color=#0000ff>char</font> buf[100];
  cin &gt;&gt; buf;

  cout &lt;&lt; <font color=#004488>"i = "</font> &lt;&lt; i &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"f = "</font> &lt;&lt; f &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"c = "</font> &lt;&lt; c &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"buf = "</font> &lt;&lt; buf &lt;&lt; endl;

  cout &lt;&lt; flush;
  cout &lt;&lt; hex &lt;&lt; <font color=#004488>"0x"</font> &lt;&lt; i &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">and give it the following
input,
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I37">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I38"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>12 1.4 c <font color=#0000ff>this</font> is a test</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">you&#8217;ll get the same output as if
you give it
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I38">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I39"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>12
1.4
c
<font color=#0000ff>this</font> is a test</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">and the output is, somewhat
unexpectedly,
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I39">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I40"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>i = 12
f = 1.4
c = c
buf = <font color=#0000ff>this</font>
0xc</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Notice that <B>buf</B> got only the first
word because the input routine looked for a space to delimit the input, which it
saw after &#8220;this.&#8221; In addition, if the continuous input string is
longer than the storage allocated for <B>buf</B>, you&#8217;ll overrun the
buffer.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I40">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I41"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It seems <B>cin</B> and the extractor are
provided only for completeness, and this is probably a good way to look at it.
In practice, you&#8217;ll usually want to get your input a line at a time
<A NAME="Index219"></A><A NAME="Index220"></A>as a sequence of characters and
then scan them and perform conversions once they&#8217;re safely in a buffer.
This way you don&#8217;t have to worry about the input routine choking on
unexpected data.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I41">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I42"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Another thing to consider is the whole
concept of a command-line
interface<A NAME="Index221"></A><A NAME="Index222"></A>. This has made sense in
the past when the console was little more than a glass typewriter, but the world
is rapidly changing to one where the graphical user interface (GUI)
<A NAME="Index223"></A><A NAME="Index224"></A><A NAME="Index225"></A>dominates.
What is the meaning of console I/O
<A NAME="Index226"></A><A NAME="Index227"></A>in such a world? It makes much
more sense to ignore <B>cin</B> altogether other than for very simple examples
or tests, and take the following
approaches:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I42">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I43"></a>
</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">If your program requires
input, read that input from a file &#8211; you&#8217;ll soon see it&#8217;s
remarkably easy to use files with iostreams.
Iostreams</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">
<A NAME="Index228"></A><A NAME="Index229"></A>for files still works fine with a
GUI.</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Read the input without
attempting to convert it. Once the input is someplace where it can&#8217;t foul
things up during conversion, then you can safely scan
it.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Output is
different. If you&#8217;re using a GUI, <B>cout</B> doesn&#8217;t work and you
must send it to a file (which is identical to sending it to <B>cout</B>) or use
the GUI facilities for data display. Otherwise it often makes sense to send it
to <B>cout</B>. In both cases, the output formatting functions of iostreams are
highly
useful.</FONT><A NAME="_Toc312373880"></A><A NAME="_Toc519041948"></A></OL><A NAME="Heading113"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Line-oriented input</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To grab input a line at a time, you have
two choices: the member functions <B>get(&#160;)</B> <A NAME="Index230"></A>and
<B>getline(&#160;)<A NAME="Index231"></A></B>. Both functions take three
arguments: a pointer to a character buffer in which to store the result, the
size of that buffer (so they don&#8217;t overrun it), and the terminating
character, to know when to stop reading input. The terminating character has a
default value of <B>&#8216;\n&#8217;</B>, which is what you&#8217;ll usually
use. Both functions store a zero in the result buffer when they encounter the
terminating character in the
input.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I43">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I44"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So what&#8217;s the difference? Subtle,
but important: <B>get(&#160;)</B> stops when it <I>sees</I> the delimiter in the
input stream, but it doesn&#8217;t extract it from the input stream. Thus, if
you did another <B>get(&#160;)</B> using the same delimiter it would immediately
return with no fetched input. (Presumably, you either use a different delimiter
in the next <B>get(&#160;)</B> statement or a different input function.)
<B>getline(&#160;)</B>, on the other hand, extracts the delimiter from the input
stream, but still doesn&#8217;t store it in the result
buffer.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I44">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I45"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Generally, when you&#8217;re processing a
text file that you read a line at a time, you&#8217;ll want to use
<B>getline(&#160;)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I45">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I46"></a>
</FONT><BR></P></DIV>
<A NAME="Heading114"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Overloaded versions of get(&#160;)</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>get(&#160;)</B> also comes in three
other overloaded versions<A NAME="Index232"></A>: one with no arguments that
returns the next character, using an <B>int</B> return value; one that stuffs a
character into its <B>char</B> argument, using a <I>reference</I> (You&#8217;ll
have to jump forward to Chapter XX if you want to understand it right this
minute . . . .); and one that stores directly into the underlying buffer
structure of another iostream object. That is explored later in the
chapter.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I46">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I47"></a>
</FONT><BR></P></DIV>
<A NAME="Heading115"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Reading raw
bytes<BR><A NAME="Index233"></A><A NAME="Index234"></A><A NAME="Index235"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you know exactly what you&#8217;re
dealing with and want to move the bytes directly into a variable, array, or
structure in memory, you can use <B>read(&#160;)<A NAME="Index236"></A></B>. The
first argument is a pointer to the destination memory, and the second is the
number of bytes to read. This is especially useful if you&#8217;ve previously
stored the information to a file, for example, in binary form using the
complementary <B>write(&#160;)<A NAME="Index237"></A></B> member function for an
output stream. You&#8217;ll see examples of all these functions
later.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I47">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I48"></a>
</FONT><BR></P></DIV>
<A NAME="Heading116"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Error handling<BR><A NAME="Index238"></A><A NAME="Index239"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All the versions of <B>get(&#160;)</B>
and <B>getline(&#160;)</B> return the input stream from which the characters
came <I>except</I> for <B>get(&#160;)</B> with no arguments, which returns the
next character or EOF. If you get the input stream object back, you can ask it
if it&#8217;s still OK. In fact, you can ask <I>any</I> iostream object if
it&#8217;s OK using the member functions
<B>good(&#160;)<A NAME="Index240"></A><A NAME="Index241"></A></B>,
<B>eof(&#160;)<A NAME="Index242"></A><A NAME="Index243"></A></B>,
<B>fail(&#160;)<A NAME="Index244"></A><A NAME="Index245"></A></B>, and
<B>bad(&#160;)<A NAME="Index246"></A><A NAME="Index247"></A></B>. These return
state information based on the <B>eofbit<A NAME="Index248"></A></B>
<A NAME="Index249"></A>(indicates the buffer is at the end of sequence), the
<B>failbit<A NAME="Index250"></A></B> <A NAME="Index251"></A>(indicates some
operation has failed because of formatting issues or some other problem that
does not affect the buffer) and the
<B>badbit<A NAME="Index252"></A><A NAME="Index253"></A></B> (indicates something
has gone wrong with the
buffer).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I48">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I49"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">However, as mentioned earlier, the state
of an input stream generally gets corrupted in weird ways only when you&#8217;re
trying to do input to specific types and the type read from the input is
inconsistent with what is expected. Then of course you have the problem of what
to do with the input stream to correct the problem. If you follow my advice and
read input a line at a time or as a big glob of characters (with
<B>read(&#160;)</B>) and don&#8217;t attempt to use the input formatting
functions except in simple cases, then all you&#8217;re concerned with is
whether you&#8217;re at the end of the input (EOF). Fortunately, testing for
this turns out to be simple and can be done inside of conditionals, such as
<B>while(cin)</B> or <B>if(cin)</B>. For now you&#8217;ll have to accept that
when you use an input stream object in this context, the right value is safely,
correctly and magically produced to indicate whether the object has reached the
end of the input. You can also use the Boolean NOT operator <B>!</B>, as in
<B>if(!cin)</B>, to indicate the stream is <I>not</I> OK; that is, you&#8217;ve
probably reached the end of input and should quit trying to read the
stream.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I49">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I50"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are times when the stream becomes
not-OK, but you understand this condition and want to go on using it. For
example, if you reach the end of an input file, the <B>eofbit</B> and
<B>failbit</B> are set, so a conditional on that stream object will indicate the
stream is no longer good. However, you may want to continue using the file, by
seeking to an earlier position and reading more data. To correct the condition,
simply call the <B>clear(&#160;)<A NAME="Index254"></A></B> member
function.</FONT><A NAME="fnB11" HREF="#fn11">[11]</A><FONT FACE="Georgia">
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I50">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I51"></a>
</FONT><A NAME="_Toc305628665"></A><A NAME="_Toc312373881"></A><A NAME="_Toc519041949"></A><BR></P></DIV>
<A NAME="Heading117"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
File iostreams</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Manipulating files with iostreams is much
easier and safer than using <B>cstdio <A NAME="Index255"></A></B>in C. All you
do to open a file is create an object; the constructor does the work. You
don&#8217;t have to explicitly close a file (although you can, using the
<B>close(&#160;)</B> member function) because the destructor will close it when
the object goes out of
scope.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I51">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I52"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To create a file that defaults to input,
make an <B>ifstream</B> <A NAME="Index256"></A>object. To create one that
defaults to output, make an <B>ofstream</B>
<A NAME="Index257"></A>object.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I52">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I53"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s an example that shows many
of the features discussed so far. Note the inclusion of <B>&lt;fstream&gt;
<A NAME="Index258"></A></B>to declare the file I/O classes; this also includes
<B>&lt;iostream&gt;<A NAME="Index259"></A></B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I53">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I54"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:Strfile.cpp</font>
<font color=#009900>// Stream I/O with files</font>
<font color=#009900>// The difference between get() &amp; getline()</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;fstream&gt;  
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> sz = 100; <font color=#009900>// Buffer size;</font>
  <font color=#0000ff>char</font> buf[sz];
  {
    ifstream in(<font color=#004488>"Strfile.cpp"</font>); <font color=#009900>// Read</font>
    assure(in, <font color=#004488>"Strfile.cpp"</font>); <font color=#009900>// Verify open</font>
    ofstream out(<font color=#004488>"Strfile.out"</font>); <font color=#009900>// Write</font>
    assure(out, <font color=#004488>"Strfile.out"</font>);
    <font color=#0000ff>int</font> i = 1; <font color=#009900>// Line counter</font>

    <font color=#009900>// A less-convenient approach for line input:</font>
    <font color=#0000ff>while</font>(in.get(buf, sz)) { <font color=#009900>// Leaves \n in input</font>
      in.get(); <font color=#009900>// Throw away next character (\n)</font>
      cout &lt;&lt; buf &lt;&lt; endl; <font color=#009900>// Must add \n</font>
      <font color=#009900>// File output just like standard I/O:</font>
      out &lt;&lt; i++ &lt;&lt; <font color=#004488>": "</font> &lt;&lt; buf &lt;&lt; endl;
    }
  } <font color=#009900>// Destructors close in &amp; out</font>

  ifstream in(<font color=#004488>"Strfile.out"</font>);
  assure(in, <font color=#004488>"Strfile.out"</font>);
  <font color=#009900>// More convenient line input:</font>
  <font color=#0000ff>while</font>(in.getline(buf, sz)) { <font color=#009900>// Removes \n</font>
    <font color=#0000ff>char</font>* cp = buf;
    <font color=#0000ff>while</font>(*cp != ':')
      cp++;
    cp += 2; <font color=#009900>// Past ": "</font>
    cout &lt;&lt; cp &lt;&lt; endl; <font color=#009900>// Must still add \n</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The creation of both the <B>ifstream</B>
and <B>ofstream</B> are followed by an <B>assure(&#160;)</B> to guarantee the
file has been successfully opened. Here again the object, used in a situation
where the compiler expects an integral result, produces a value that indicates
success or failure. (To do this, an automatic type conversion member function is
called. These are discussed in Chapter
XX.)
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I54">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I55"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first <B>while</B> loop demonstrates
the use of two forms of the <B>get(&#160;)</B>
<A NAME="Index260"></A><A NAME="Index261"></A>function. The first gets
characters into a buffer and puts a zero terminator in the buffer when either
<B>sz &#8211; 1</B> characters have been read or the third argument (defaulted
to <B>&#8216;\n&#8217;</B>) is encountered. <B>get(&#160;)</B> leaves the
terminator character in the input stream, so this terminator must be thrown away
via <B>in.get(&#160;)</B> using the form of <B>get(&#160;)</B> with no argument,
which fetches a single byte and returns it as an <B>int</B>. You can also use
the <B>ignore(&#160;)</B> <A NAME="Index262"></A><A NAME="Index263"></A>member
function, which has two defaulted arguments. The first is the number of
characters to throw away, and defaults to one. The second is the character at
which the <B>ignore(&#160;)</B> function quits (after extracting it) and
defaults to EOF.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I55">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I56"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Next you see two output statements that
look very similar: one to <B>cout </B>and one to the file <B>out</B>. Notice the
convenience here; you don&#8217;t need to worry about what kind of object
you&#8217;re dealing with because the formatting statements work the same with
all <B>ostream</B> <A NAME="Index264"></A>objects. The first one echoes the line
to standard output, and the second writes the line out to the new file and
includes a line number.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I56">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I57"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To demonstrate
<B>getline(&#160;)<A NAME="Index265"></A><A NAME="Index266"></A></B>, it&#8217;s
interesting to open the file we just created and strip off the line numbers. To
ensure the file is properly closed before opening it to read, you have two
choices. You can surround the first part of the program in braces to force the
<B>out</B> object out of scope, thus calling the destructor and closing the
file, which is done here. You can also call <B>close(&#160;)</B> for both files;
if you want, you can even reuse the <B>in</B> object by calling the
<B>open(&#160;)</B> member function (you can also create and destroy the object
dynamically on the heap as is in Chapter
XX).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I57">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I58"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second <B>while</B> loop shows how
<B>getline(&#160;)</B> removes the terminator character (its third argument,
which defaults to <B>&#8216;\n&#8217;</B>) from the input stream when it&#8217;s
encountered. Although <B>getline(&#160;)</B>, like <B>get(&#160;)</B>, puts a
zero in the buffer, it still doesn&#8217;t insert the terminating
character.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I58">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I59"></a>
</FONT><A NAME="_Toc312373882"></A><A NAME="_Toc519041950"></A><BR></P></DIV>
<A NAME="Heading118"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Open
modes<BR><A NAME="Index267"></A><A NAME="Index268"></A><A NAME="Index269"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can control the way a file is opened
by changing a default argument. The following table shows the flags that control
the mode of the file:</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=92 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B>Flag</B></FONT><BR></P></DIV>
</TH>
<TH WIDTH=176 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B>Function</B></FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ios::in</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Opens an input file. Use this as an open
mode for an <B>ofstream</B> to prevent truncating an existing
file.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ios::out</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Opens an output file. When used for an
<B>ofstream</B> without <B>ios::app</B>, <B>ios::ate</B> or <B>ios::in</B>,
<B>ios::trunc</B> is implied.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ios::app</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Opens an output file for
appending.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ios::ate</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Opens an existing file (either input or
output) and seeks the end.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ios::nocreate</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Opens a file only if it already exists.
(Otherwise it fails.)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ios::noreplace</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Opens a file only if it does not exist.
(Otherwise it fails.)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ios::trunc</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Opens a file and deletes the old file, if
it already exists.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ios::binary</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Opens a file in binary mode. Default is
text mode.</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">These flags can be combined using a
bitwise
<I>or</I>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I59">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I60"></a>
</FONT><A NAME="_Toc305628666"></A><A NAME="_Toc312373883"></A><A NAME="_Toc519041951"></A><BR></P></DIV>
<A NAME="Heading119"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Iostream buffering<BR><A NAME="Index270"></A><A NAME="Index271"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Whenever you create a new class, you
should endeavor to hide the details of the underlying implementation as possible
from the user of the class. Try to show them only what they need to know and
make the rest <B>private </B>to avoid confusion. Normally when using iostreams
you don&#8217;t know or care where the bytes are being produced or consumed;
indeed, this is different depending on whether you&#8217;re dealing with
standard I/O, files, memory, or some newly created class or
device.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I60">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I61"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There comes a time, however, when it
becomes important to be able to send messages to the part of the iostream that
produces and consumes bytes. To provide this part with a common interface and
still hide its underlying implementation, it is abstracted into its own class,
called <B>streambuf<A NAME="Index272"></A></B>. Each iostream object contains a
pointer to some kind of <B>streambuf</B>. (The kind depends on whether it deals
with standard I/O, files, memory, etc.) You can access the <B>streambuf
</B>directly; for example, you can move raw bytes into and out of the
<B>streambuf</B>, without formatting them through the enclosing iostream. This
is accomplished, of course, by calling member functions for the <B>streambuf</B>
object.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I61">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I62"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Currently, the most important thing for
you to know is that every iostream object contains a pointer to a
<B>streambuf</B> object, and the <B>streambuf</B> has some member functions you
can call if you need to.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I62">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I63"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To allow you to access the
<B>streambuf</B>, every iostream object has a member function called
<B>rdbuf(&#160;)<A NAME="Index273"></A><A NAME="Index274"></A></B> that returns
the pointer to the object&#8217;s <B>streambuf</B>. This way you can call any
member function for the underlying <B>streambuf</B>. However, one of the most
interesting things you can do with the <B>streambuf</B> pointer is to connect it
to another iostream object using the <B>&lt;&lt;</B> operator. This drains all
the bytes from your object into the one on the left-hand side of the
<B>&lt;&lt;</B>. This means if you want to move all the bytes from one iostream
to another, you don&#8217;t have to go through the tedium (and potential coding
errors) of reading them one byte or one line at a time. It&#8217;s a much more
elegant approach.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I63">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I64"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For example, here&#8217;s a very simple
program that opens a file and sends the contents out to standard output (similar
to the previous example):
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I64">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I65"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:Stype.cpp</font>
<font color=#009900>// Type a file to standard output</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;fstream&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  ifstream in(<font color=#004488>"Stype.cpp"</font>);
  assure(in, <font color=#004488>"Stype.cpp"</font>);
  cout &lt;&lt; in.rdbuf(); <font color=#009900>// Outputs entire file</font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An <B>ifstream</B>
<A NAME="Index275"></A>is created using the source  code file for this program
as an argument. The <B>assure( ) </B> will report a failure if the file cannot
be opened. All the work really happens in the
statement:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I65">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I67"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>cout &lt;&lt; in.rdbuf();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">which causes the entire contents of the
file to be sent to <B>cout</B>. This is not only more succinct to code, it is
often more efficient than moving the bytes one at a
time.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I67">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I68"></a>
</FONT><A NAME="_Toc312373884"></A><A NAME="_Toc519041952"></A><BR></P></DIV>
<A NAME="Heading120"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Using get(&#160;) with a streambuf</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There is a form of
<B>get(&#160;)<A NAME="Index276"></A><A NAME="Index277"></A></B> that allows you
to write directly into the <B>streambuf</B> of another object. The first
argument is the destination <B>streambuf</B> (whose address is mysteriously
taken using a <I>reference</I>, discussed in Chapter XX), and the second is the
terminating character, which stops the <B>get(&#160;)</B> function. So yet
another way to print a file to standard output
is
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I68">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I69"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:Sbufget.cpp</font>
<font color=#009900>// Get directly into a streambuf</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-g++295}</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;fstream&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  ifstream in(<font color=#004488>"Sbufget.cpp"</font>);
  assure(in, <font color=#004488>"Sbufget.cpp"</font>);
  <font color=#0000ff>while</font>(in.get(*cout.rdbuf()))
    in.ignore();
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>rdbuf(&#160;)</B> returns a pointer,
so it must be dereferenced to satisfy the function&#8217;s need to see an
object. The <B>get(&#160;)</B> function, remember, doesn&#8217;t pull the
terminating character from the input stream, so it must be removed using
<B>ignore(&#160;)</B> so <B>get(&#160;)</B> doesn&#8217;t just bonk up against
the newline forever (which it will,
otherwise).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I69">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I70"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You probably won&#8217;t need to use a
technique like this very often, but it may be useful to know it
exists.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I70">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I71"></a>
</FONT><A NAME="_Toc305628667"></A><A NAME="_Toc312373885"></A><A NAME="_Toc519041953"></A><BR></P></DIV>
<A NAME="Heading121"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Seeking in iostreams<BR><A NAME="Index278"></A><A NAME="Index279"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each type of iostream has a concept of
where its &#8220;next&#8221; character will come from (if it&#8217;s an
<B>istream</B>) or go (if it&#8217;s an <B>ostream</B>). In some situations you
may want to move this stream position. You can do it using two models: One uses
an absolute location in the stream called the
<B>streampos<A NAME="Index280"></A></B>; the second works like the Standard C
library functions
<B>fseek(&#160;)<A NAME="Index281"></A><A NAME="Index282"></A></B> for a file
and moves a given number of bytes from the beginning, end, or current position
in the file.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I71">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I72"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>streampos</B> approach requires
that you first call a &#8220;tell&#8221; function:
<B>tellp(&#160;)<A NAME="Index283"></A><A NAME="Index284"></A></B> for an
<B>ostream</B> or
<B>tellg(&#160;)<A NAME="Index285"></A><A NAME="Index286"></A></B> for an
<B>istream</B>. (The &#8220;p&#8221; refers to the &#8220;put
pointer&#8221;<A NAME="Index287"></A> and the &#8220;g&#8221; refers to the
&#8220;get pointer.&#8221;) This function returns a <B>streampos</B> you can
later use in the single-argument version of
<B>seekp(&#160;)<A NAME="Index288"></A><A NAME="Index289"></A></B> for an
<B>ostream</B> or
<B>seekg(&#160;)<A NAME="Index290"></A><A NAME="Index291"></A></B> for an
<B>istream</B>, when you want to return to that position in the
stream.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I72">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I73"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second approach is a relative seek
and uses overloaded versions of <B>seekp(&#160;)</B> and <B>seekg(&#160;)</B>.
The first argument is the number of bytes to move: it may be positive or
negative. The second argument is the seek direction:</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="CENTER"><FONT FACE="Georgia">ios::beg</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="CENTER"><FONT FACE="Georgia">From beginning of
stream</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="CENTER"><FONT FACE="Georgia">ios::cur</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="CENTER"><FONT FACE="Georgia">Current position in
stream</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="CENTER"><FONT FACE="Georgia">ios::end</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="CENTER"><FONT FACE="Georgia">From end of stream</FONT><BR></P></DIV>
</TD>
</TR>
<A NAME="Index292"></A><A NAME="Index293"></A><A NAME="Index294"></A></TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s an example that shows the
movement through a file, but remember, you&#8217;re not limited to seeking
within files, as you are with C and <B>cstdio</B>. With C++, you can seek in any
type of iostream (although the behavior of <B>cin</B> &amp; <B>cout</B> when
seeking is undefined):
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I73">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I74"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:Seeking.cpp</font>
<font color=#009900>// Seeking in iostreams</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  ifstream in(<font color=#004488>"Seeking.cpp"</font>);
  assure(in, <font color=#004488>"Seeking.cpp"</font>); <font color=#009900>// File must already exist</font>
  in.seekg(0, ios::end); <font color=#009900>// End of file</font>
  streampos sp = in.tellg(); <font color=#009900>// Size of file</font>
  cout &lt;&lt; <font color=#004488>"file size = "</font> &lt;&lt; sp &lt;&lt; endl;
  in.seekg(-sp/10, ios::end);
  streampos sp2 = in.tellg();
  in.seekg(0, ios::beg); <font color=#009900>// Start of file</font>
  cout &lt;&lt; in.rdbuf(); <font color=#009900>// Print whole file</font>
  in.seekg(sp2); <font color=#009900>// Move to streampos</font>
  <font color=#009900>// Prints the last 1/10th of the file:</font>
  cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; in.rdbuf() &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This program picks a file name off the
command line and opens it as an <B>ifstream</B>. <B>assert(&#160;) </B>detects
an open failure. Because this is a type of <B>istream</B>, <B>seekg(&#160;)</B>
is used to position the &#8220;get pointer<A NAME="Index295"></A>.&#8221; The
first call seeks zero bytes off the end of the file, that is, to the end.
Because a <B>streampos</B> is a <B>typedef</B> for a <B>long</B>, calling
<B>tellg(&#160;)</B> at that point also returns the size of the file, which is
printed out. Then a seek is performed moving the get pointer 1/10 the size of
the file &#8211; notice it&#8217;s a negative seek from the end of the file, so
it backs up from the end. If you try to seek positively from the end of the
file, the get pointer will just stay at the end. The <B>streampos</B> at that
point is captured into <B>sp2</B>, then a <B>seekg(&#160;)</B> is performed back
to the beginning of the file so the whole thing can be printed out using the
<B>streambuf</B> pointer produced with <B>rdbuf(&#160;)</B>. Finally, the
overloaded version of <B>seekg(&#160;)</B> is used with the <B>streampos</B>
<B>sp2</B> to move to the previous position, and the last portion of the file is
printed
out.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I74">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I75"></a>
</FONT><A NAME="_Toc312373886"></A><A NAME="_Toc519041954"></A><BR></P></DIV>
<A NAME="Heading122"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Creating read/write files</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now that you know about the
<B>streambuf</B> and how to seek, you can understand how to create a stream
object that will both read and write a file. The following code first creates an
<B>ifstream</B> with flags that say it&#8217;s both an input and an output file.
The compiler won&#8217;t let you write to an <B>ifstream</B>, however, so you
need to create an <B>ostream</B> with the underlying stream
buffer:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I75">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I76"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>      ifstream in(<font color=#004488>"filename"</font>, ios::in|ios::out);
      ostream out(in.rdbuf());</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You may wonder what happens when you
write to one of these objects. Here&#8217;s an
example:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I76">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I77"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:Iofile.cpp</font>
<font color=#009900>// Reading &amp; writing one file</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  ifstream in(<font color=#004488>"Iofile.cpp"</font>);
  assure(in, <font color=#004488>"Iofile.cpp"</font>);
  ofstream out(<font color=#004488>"Iofile.out"</font>);
  assure(out, <font color=#004488>"Iofile.out"</font>);
  out &lt;&lt; in.rdbuf(); <font color=#009900>// Copy file</font>
  in.close();
  out.close();
  <font color=#009900>// Open for reading and writing:</font>
  ifstream in2(<font color=#004488>"Iofile.out"</font>, ios::in | ios::out);
  assure(in2, <font color=#004488>"Iofile.out"</font>);
  ostream out2(in2.rdbuf());
  cout &lt;&lt; in2.rdbuf();  <font color=#009900>// Print whole file</font>
  out2 &lt;&lt; <font color=#004488>"Where does this end up?"</font>;
  out2.seekp(0, ios::beg);
  out2 &lt;&lt; <font color=#004488>"And what about this?"</font>;
  in2.seekg(0, ios::beg);
  cout &lt;&lt; in2.rdbuf();
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first five lines copy the source code
for this program into a file called <B>iofile.out</B>, and then close the files.
This gives us a safe text file to play around with. Then the aforementioned
technique is used to create two objects that read and write to the same file. In
<B>cout &lt;&lt; in2.rdbuf(&#160;)</B>, you can see the &#8220;get&#8221;
pointer is initialized to the beginning of the file. The &#8220;put&#8221;
pointer, however, is set to the end of the file because &#8220;Where does this
end up?&#8221; appears appended to the file. However, if the put pointer is
moved to the beginning with a <B>seekp(&#160;)</B>, all the inserted text
<I>overwrites </I>the existing text. Both writes are seen when the get pointer
is moved back to the beginning with a <B>seekg(&#160;)</B>, and the file is
printed out. Of course, the file is automatically saved and closed when
<B>out2</B> goes out of scope and its destructor is
called.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I77">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I78"></a>
</FONT><A NAME="_Toc305628668"></A><A NAME="_Toc312373887"></A><A NAME="_Toc519041955"></A><BR></P></DIV>
<A NAME="Heading123"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
stringstreams<A NAME="_Toc519041956"></A></H2></FONT>
<A NAME="Heading124"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
strstreams</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Before there were <B>stringstream</B>s,
there were the more primitive <B>strstream</B>s. Although these are not an
official part of Standard C++, they have been around a long time so compilers
will no doubt leave in the <B>strstream</B> support in perpetuity, to compile
legacy code. You should always use <B>stringstream</B>s, but it&#8217;s
certainly likely that you&#8217;ll come across code that uses <B>strstream</B>s
and at that point this section should come in handy. In addition, this section
should make it fairly clear why <B>stringstream</B>s have replace<B>
strstream</B>s.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I78">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I79"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index296"></A><FONT FACE="Georgia">A <B>strstream</B>
works directly with memory instead of a file or standard output. It allows you
to use the same reading and formatting functions to manipulate bytes in memory.
On old computers the memory was referred to as <I>core</I> so this type of
functionality is often called <I>in-core
formatting<A NAME="Index297"></A><A NAME="Index298"></A></I>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I79">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I80"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The class names for strstreams echo those
for file streams. If you want to create a strstream to extract characters from,
you create an <B>istrstream<A NAME="Index299"></A></B>. If you want to put
characters into a strstream, you create an
<B>ostrstream<A NAME="Index300"></A></B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I80">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I81"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">String streams work with memory, so you
must deal with the issue of where the memory comes from and where it goes. This
isn&#8217;t terribly complicated, but you must understand it and pay attention
(it turned out is was too easy to lose track of this particular issue, thus the
birth of
<B>stringstream</B>s).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I81">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I82"></a>
</FONT><A NAME="_Toc312373888"></A><A NAME="_Toc519041957"></A><BR></P></DIV>
<A NAME="Heading125"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
User-allocated storage<BR><A NAME="Index301"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The easiest approach to understand is
when the user is responsible for allocating the storage. With <B>istrstream</B>s
this is the only allowed approach. There are two
constructors:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I82">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I83"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>istrstream::istrstream(<font color=#0000ff>char</font>* buf);
istrstream::istrstream(<font color=#0000ff>char</font>* buf, <font color=#0000ff>int</font> size);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first constructor takes a pointer to
a zero-terminated character array; you can extract bytes until the zero. The
second constructor additionally requires the size of the array, which
doesn&#8217;t have to be zero-terminated. You can extract bytes all the way to
<B>buf[size]</B>, whether or not you encounter a zero along the
way.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I83">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I84"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you hand an <B>istrstream</B>
constructor the address of an array, that array must already be filled with the
characters you want to extract and presumably format into some other data type.
Here&#8217;s a simple
example:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I84">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I85"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:Istring.cpp</font>
<font color=#009900>// Input strstreams</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;iostream&gt;
#include &lt;strstream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  istrstream s(<font color=#004488>"47 1.414 This is a test"</font>);
  <font color=#0000ff>int</font> i;
  <font color=#0000ff>float</font> f;
  s &gt;&gt; i &gt;&gt; f; <font color=#009900>// Whitespace-delimited input</font>
  <font color=#0000ff>char</font> buf2[100];
  s &gt;&gt; buf2;
  cout &lt;&lt; <font color=#004488>"i = "</font> &lt;&lt; i &lt;&lt; <font color=#004488>", f = "</font> &lt;&lt; f;
  cout &lt;&lt; <font color=#004488>" buf2 = "</font> &lt;&lt; buf2 &lt;&lt; endl;
  cout &lt;&lt; s.rdbuf(); <font color=#009900>// Get the rest...</font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that this is a more flexible
and general approach to transforming character strings to typed
values<A NAME="Index302"></A><A NAME="Index303"></A><A NAME="Index304"></A><A NAME="Index305"></A>
than the Standard C Library functions like
<B>atof(&#160;)<A NAME="Index306"></A></B>,
<B>atoi(&#160;)<A NAME="Index307"></A></B>, and so
on.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I85">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I86"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The compiler handles the static storage
allocation of the string
in
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I86">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I87"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>  istrstream s(<font color=#004488>"47 1.414 This is a test"</font>);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can also hand it a pointer to a
zero-terminated string allocated on the stack or the
heap.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I87">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I88"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>s &gt;&gt; i &gt;&gt; f</B>, the
first number is extracted into <B>i</B> and the second into <B>f</B>. This
isn&#8217;t &#8220;the first whitespace-delimited set of characters&#8221;
because it depends on the data type it&#8217;s being extracted into. For
example, if the string were instead, &#8220;<B>1.414 47 This is a
test</B>,&#8221; then <B>i</B> would get the value one because the input routine
would stop at the decimal point. Then <B>f</B> would get <B>0.414</B>. This
could be useful if you want to break a floating-point number into a whole number
and a fraction part. Otherwise it would seem to be an
error.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I88">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I89"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As you may already have guessed,
<B>buf2</B> doesn&#8217;t get the rest of the string, just the next
whitespace-delimited word. In general, it seems the best place to use the
extractor in iostreams is when you know the exact sequence of data in the input
stream and you&#8217;re converting to some type other than a character string.
However, if you want to extract the rest of the string all at once and send it
to another iostream, you can use <B>rdbuf(&#160;)</B> as
shown.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I89">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I90"></a>
</FONT><BR></P></DIV>
<A NAME="Heading126"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Output strstreams<BR><A NAME="Index308"></A><A NAME="Index309"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Output strstreams also allow you to
provide your own storage; in this case it&#8217;s the place in memory the bytes
are formatted <I>into</I>. The appropriate constructor
is
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I90">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I91"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>ostrstream::ostrstream(<font color=#0000ff>char</font>*, <font color=#0000ff>int</font>, <font color=#0000ff>int</font> = ios::out);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first argument is the preallocated
buffer where the characters will end up, the second is the size of the buffer,
and the third is the mode. If the mode is left as the default, characters are
formatted into the starting address of the buffer. <A NAME="Index310"></A> If
the mode is either <B>ios::ate</B> <A NAME="Index311"></A>or <B>ios::app</B>
<A NAME="Index312"></A>(same effect), the character buffer is assumed to already
contain a zero-terminated string, and any new characters are added starting at
the zero terminator.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I91">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I92"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second constructor argument is the
size of the array and is used by the object to ensure it doesn&#8217;t overwrite
the end of the array. If you fill the array up and try to add more bytes, they
won&#8217;t go in.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I92">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I93"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An important thing to remember about
<B>ostrstream</B>s is that the zero terminator
<A NAME="Index313"></A><A NAME="Index314"></A><A NAME="Index315"></A>you
normally need at the end of a character array <I>is not</I> inserted for you.
When you&#8217;re ready to zero-terminate the string, use the special
manipulator
<B>ends<A NAME="Index316"></A><A NAME="Index317"></A></B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I93">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I94"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once you&#8217;ve created an
<B>ostrstream</B> you can insert anything you want, and it will magically end up
formatted in the memory buffer. Here&#8217;s an
example:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I94">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I95"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:Ostring.cpp</font>
<font color=#009900>// Output strstreams</font>
#include &lt;iostream&gt;
#include &lt;strstream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> sz = 100;
  cout &lt;&lt; <font color=#004488>"type an int, a float and a string:"</font>;
  <font color=#0000ff>int</font> i;
  <font color=#0000ff>float</font> f;
  cin &gt;&gt; i &gt;&gt; f;
  cin &gt;&gt; ws; <font color=#009900>// Throw away white space</font>
  <font color=#0000ff>char</font> buf[sz];
  cin.getline(buf, sz); <font color=#009900>// Get rest of the line</font>
  <font color=#009900>// (cin.rdbuf() would be awkward)</font>
  ostrstream os(buf, sz, ios::app);
  os &lt;&lt; endl;
  os &lt;&lt; <font color=#004488>"integer = "</font> &lt;&lt; i &lt;&lt; endl;
  os &lt;&lt; <font color=#004488>"float = "</font> &lt;&lt; f &lt;&lt; endl;
  os &lt;&lt; ends;
  cout &lt;&lt; buf;
  cout &lt;&lt; os.rdbuf(); <font color=#009900>// Same effect</font>
  cout &lt;&lt; os.rdbuf(); <font color=#009900>// NOT the same effect</font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is similar to the previous example
in fetching the <B>int</B> and <B>float</B>. You might think the logical way to
get the rest of the line is to use <B>rdbuf(&#160;)</B>; this works, but
it&#8217;s awkward because all the input including newlines is collected until
the user presses control-Z (control-D on Unix) to indicate the end of the input.
The approach shown, using <B>getline(&#160;)<A NAME="Index318"></A></B>, gets
the input until the user presses the carriage return. This input is fetched into
<B>buf</B>, which is subsequently used to construct the <B>ostrstream os</B>. If
the third argument <B>ios::app</B> weren&#8217;t supplied, the constructor would
default to writing at the beginning of <B>buf</B>, overwriting the line that was
just collected. However, the &#8220;append&#8221; flag causes it to put the rest
of the formatted information at the end of the
string.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I95">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I96"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that, like the other output
streams, you can use the ordinary formatting tools for sending bytes to the
<B>ostrstream</B>. The only difference is that you&#8217;re responsible for
inserting the zero at the end with <B>ends</B>. Note that <B>endl</B> inserts a
newline in the strstream, but no
zero.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I96">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I97"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now the information is formatted in
<B>buf</B>, and you can send it out directly with <B>cout &lt;&lt; buf</B>.
However, it&#8217;s also possible to send the information out with
<B>os.rdbuf(&#160;)</B>. When you do this, the get pointer
<A NAME="Index319"></A>inside the <B>streambuf</B> is moved forward as the
characters are output. For this reason, if you say <B>cout &lt;&lt;
os.rdbuf(&#160;)</B> a second time, nothing happens &#8211; the get pointer is
already at the
end.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I97">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I98"></a>
</FONT><A NAME="_Toc312373889"></A><A NAME="_Toc519041958"></A><BR></P></DIV>
<A NAME="Heading127"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Automatic storage allocation<BR><A NAME="Index320"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Output strstreams (but <I>not</I>
<B>istrstream</B>s) give you a second option for memory allocation: they can do
it themselves. All you do is create an <B>ostrstream</B> with no constructor
arguments:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I98">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I99"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>ostrstream a;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now <B>a</B> takes care of all its own
storage allocation on the heap. You can put as many bytes into <B>a</B> as you
want, and if it runs out of storage, it will allocate more, moving the block of
memory, if necessary.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I99">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I100"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is a very nice solution if you
don&#8217;t know how much space you&#8217;ll need, because it&#8217;s completely
flexible. And if you simply format data into the strstream and then hand its
<B>streambuf</B> off to another iostream, things work
perfectly:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I100">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I101"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>a &lt;&lt; <font color=#004488>"hello, world. i = "</font> &lt;&lt; i &lt;&lt; endl &lt;&lt; ends;
cout &lt;&lt; a.rdbuf();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is the best of all possible
solutions. But what happens if you want the physical address of the memory that
<B>a</B>&#8217;s characters have been formatted into? It&#8217;s readily
available &#8211; you simply call the <B>str(&#160;)</B> member
function:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I101">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I102"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>char</font>* cp = a.str();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s a problem now. What if you
want to put more characters into <B>a</B>? It would be OK if you knew <B>a</B>
had already allocated enough storage for all the characters you want to give it,
but that&#8217;s not true. Generally, <B>a</B> will run out of storage when you
give it more characters, and ordinarily it would try to allocate more storage on
the heap. This would usually require moving the block of memory. But the stream
objects has just handed you the address of its memory block, so it can&#8217;t
very well move that block, because you&#8217;re expecting it to be at a
particular location.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I102">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I103"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The way an <B>ostrstream</B> handles this
problem is by
&#8220;freezing&#8221;<A NAME="Index321"></A><A NAME="Index322"></A> itself. As
long as you don&#8217;t use <B>str(&#160;)</B> to ask for the internal
<B>char*</B>, you can add as many characters as you want to the
<B>ostrstream</B>. It will allocate all the necessary storage from the heap, and
when the object goes out of scope, that heap storage is automatically
released.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I103">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I104"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">However, if you call
<B>str(&#160;)<A NAME="Index323"></A><A NAME="Index324"></A></B>, the
<B>ostrstream</B> becomes &#8220;frozen.&#8221; You can&#8217;t add any more
characters to it. Rather, you aren&#8217;t <I>supposed</I> to &#8211;
implementations are not required to detect the error. Adding characters to a
frozen <B>ostrstream</B> results in undefined behavior. In addition, the
<B>ostrstream</B> is no longer responsible for cleaning up the storage. You took
over that responsibility when you asked for the <B>char*</B> with
<B>str(&#160;)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I104">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I105"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To prevent a memory leak, the storage
must be cleaned up somehow. There are two approaches. The more common one is to
directly release the memory when you&#8217;re done. To understand this, you need
a sneak preview of two new keywords in C++: <B>new</B>
<A NAME="Index325"></A>and <B>delete<A NAME="Index326"></A></B>. As you&#8217;ll
see in Chapter XX, these do quite a bit, but for now you can think of them as
replacements for <B>malloc(&#160;)<A NAME="Index327"></A></B> and
<B>free(&#160;)<A NAME="Index328"></A></B> in C. The operator <B>new</B> returns
a chunk of memory, and <B>delete</B> frees it. It&#8217;s important to know
about them here because virtually all memory allocation in C++ is performed with
<B>new</B>, and this is also true with <B>ostrstream</B>. If it&#8217;s
allocated with <B>new</B>, it must be released with <B>delete</B>, so if you
have an <B>ostrstream a</B> and you get the <B>char*</B> using
<B>str(&#160;)</B>, the typical way to clean up the storage
is
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I105">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I106"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>delete</font> []a.str();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This satisfies most needs, but
there&#8217;s a second, much less common way to release the storage: You can
unfreeze the <B>ostrstream</B>. You do this by calling
<B>freeze(&#160;)<A NAME="Index329"></A></B>, which is a member function of the
<B>ostrstream</B>&#8217;s <B>streambuf</B>. <B>freeze(&#160;)</B> has a default
argument of one, which freezes the stream, but an argument of zero will unfreeze
it:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I106">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I107"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>a.rdbuf()-&gt;freeze(0);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now the storage is deallocated when
<B>a</B> goes out of scope and its destructor is called. In addition, you can
add more bytes to <B>a</B>. However, this may cause the storage to move, so you
better not use any pointer you previously got by calling <B>str(&#160;)</B>
&#8211; it won&#8217;t be reliable after adding more
characters.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I107">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I108"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example tests the ability
to add more characters after a stream has been
unfrozen:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I108">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I109"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:Walrus.cpp</font>
<font color=#009900>// Freezing a strstream</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;iostream&gt;
#include &lt;strstream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  ostrstream s;
  s &lt;&lt; <font color=#004488>"'The time has come', the walrus said,"</font>;
  s &lt;&lt; ends;
  cout &lt;&lt; s.str() &lt;&lt; endl; <font color=#009900>// String is frozen</font>
  <font color=#009900>// s is frozen; destructor won't delete</font>
  <font color=#009900>// the streambuf storage on the heap</font>
  s.seekp(-1, ios::cur); <font color=#009900>// Back up before NULL</font>
  s.rdbuf()-&gt;freeze(0); <font color=#009900>// Unfreeze it</font>
  <font color=#009900>// Now destructor releases memory, and</font>
  <font color=#009900>// you can add more characters (but you</font>
  <font color=#009900>// better not use the previous str() value)</font>
  s &lt;&lt; <font color=#004488>" 'To speak of many things'"</font> &lt;&lt; ends;
  cout &lt;&lt; s.rdbuf();
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">After putting the first string into
<B>s</B>, an <B>ends</B> is added so the string can be printed using the
<B>char*</B> produced by <B>str(&#160;)</B>. At that point, <B>s</B> is frozen.
We want to add more characters to <B>s</B>, but for it to have any effect, the
put pointer must be backed up one so the next character is placed on top of the
zero inserted by <B>ends</B>. (Otherwise the string would be printed only up to
the original zero.) This is accomplished with <B>seekp(&#160;)</B>. Then
<B>s</B> is unfrozen by fetching the underlying <B>streambuf</B> pointer using
<B>rdbuf(&#160;)</B> and calling <B>freeze(0)</B>. At this point <B>s</B> is
like it was before calling <B>str(&#160;)</B>: We can add more characters, and
cleanup will occur automatically, with the
destructor.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I109">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I110"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It is <I>possible</I> to unfreeze an
<B>ostrstream</B> and continue adding characters, but it is not common practice.
Normally, if you want to add more characters once you&#8217;ve gotten the
<B>char*</B> of a <B>ostrstream</B>, you create a new one, pour the old stream
into the new one using <B>rdbuf(&#160;)</B> and continue adding new characters
to the new
<B>ostrstream</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I110">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I111"></a>
</FONT><BR></P></DIV>
<A NAME="Heading128"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Proving movement</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you&#8217;re still not convinced you
should be responsible for the storage of a <B>ostrstream</B> if you call
<B>str(&#160;)</B>, here&#8217;s an example that demonstrates the storage
location is moved, therefore the old pointer returned by <B>str(&#160;)</B> is
invalid:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I111">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I112"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:Strmove.cpp</font>
<font color=#009900>// ostrstream memory movement</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;iostream&gt;
#include &lt;strstream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  ostrstream s;
  s &lt;&lt; <font color=#004488>"hi"</font>;
  <font color=#0000ff>char</font>* old = s.str(); <font color=#009900>// Freezes s</font>
  s.rdbuf()-&gt;freeze(0); <font color=#009900>// Unfreeze</font>
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 100; i++)
    s &lt;&lt; <font color=#004488>"howdy"</font>; <font color=#009900>// Should force reallocation</font>
  cout &lt;&lt; <font color=#004488>"old = "</font> &lt;&lt; (<font color=#0000ff>void</font>*)old &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"new = "</font> &lt;&lt; (<font color=#0000ff>void</font>*)s.str(); <font color=#009900>// Freezes</font>
  <font color=#0000ff>delete</font> s.str(); <font color=#009900>// Release storage</font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">After inserting a string to <B>s</B> and
capturing the <B>char*</B> with <B>str(&#160;)</B>, the string is unfrozen and
enough new bytes are inserted to virtually assure the memory is reallocated and
most likely moved. After printing out the old and new <B>char*</B> values, the
storage is explicitly released with <B>delete</B> because the second call to
<B>str(&#160;)</B> froze the string
again.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I112">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I113"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To print out addresses instead of the
strings they point to, you must cast the <B>char*</B> to a <B>void*</B>. The
operator <B>&lt;&lt;</B> for <B>char*</B> prints out the string it is pointing
to, while the operator <B>&lt;&lt;</B> for <B>void*</B> prints out the hex
representation of the
pointer.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I113">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I114"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s interesting to note that if
you don&#8217;t insert a string to <B>s</B> before calling <B>str(&#160;)</B>,
the result is zero. This means no storage is allocated until the first time you
try to insert bytes to the
<B>ostrstream</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I114">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I115"></a>
</FONT><BR></P></DIV>
<A NAME="Heading129"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
A better way</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Again, remember that this section was
only left in to support legacy code. You should always use <B>string</B> and
<B>stringstream</B> rather than character arrays and <B>strstream</B>. The
former is much safer and easier to use and will help ensure your projects get
finished
faster.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I115">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I116"></a>
</FONT><A NAME="_Toc305628669"></A><A NAME="_Toc312373890"></A><A NAME="_Toc519041959"></A><BR></P></DIV>
<A NAME="Heading130"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Output stream
formatting<BR><A NAME="Index330"></A><A NAME="Index331"></A><A NAME="Index332"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The whole goal of this effort, and all
these different types of iostreams, is to allow you to easily move and translate
bytes from one place to another. It certainly wouldn&#8217;t be very useful if
you couldn&#8217;t do all the formatting with the
<B>printf(&#160;)<A NAME="Index333"></A></B> family of functions. In this
section, you&#8217;ll learn all the output formatting functions that are
available for iostreams, so you can get your bytes the way you want
them.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I116">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I117"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The formatting functions in iostreams can
be somewhat confusing at first because there&#8217;s often more than one way to
control the formatting: through both member functions and manipulators. To
further confuse things, there is a generic member function to set state flags to
control formatting, such as left- or right-justification, whether to use
uppercase letters for hex notation, whether to always use a decimal point for
floating-point values, and so on. On the other hand, there are specific member
functions to set and read values for the fill character, the field width, and
the precision.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I117">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I118"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In an attempt to clarify all this, the
internal formatting data of an iostream is examined first, along with the member
functions that can modify that data. (Everything can be controlled through the
member functions.) The manipulators are covered
separately.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I118">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I119"></a>
</FONT><A NAME="_Toc312373891"></A><A NAME="_Toc519041960"></A><BR></P></DIV>
<A NAME="Heading131"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Internal formatting data<BR><A NAME="Index334"></A><A NAME="Index335"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The class <B>ios</B> (which you can see
in the header file <B>&lt;iostream&gt;</B>) contains data members to store all
the formatting data pertaining to that stream. Some of this data has a range of
values and is stored in variables: the floating-point precision, the output
field width, and the character used to pad the output (normally a space). The
rest of the formatting is determined by flags, which are usually combined to
save space and are referred to collectively as the <I>format
flags<A NAME="Index336"></A><A NAME="Index337"></A><A NAME="Index338"></A></I>.
You can find out the value of the format flags with the
<B>ios::flags(&#160;)<A NAME="Index339"></A></B> member function, which takes no
arguments and returns a <B>long</B> (<B>typedef</B>ed to <B>fmtflags</B>) that
contains the current format flags. All the rest of the functions make changes to
the format flags and return the previous value of the format
flags.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I119">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I120"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>fmtflags ios::flags(fmtflags newflags);
fmtflags ios::setf(fmtflags ored_flag);
fmtflags ios::unsetf(fmtflags clear_flag);
fmtflags ios::setf(fmtflags bits, fmtflags field);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first function forces <I>all</I> the
flags to change, which you do sometimes. More often, you change one flag at a
time using the remaining three functions.

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I120">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I121"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The use of
<B>setf(&#160;)<A NAME="Index340"></A></B> <A NAME="Index341"></A>can seem more
confusing: To know which overloaded version to use, you must know what type of
flag you&#8217;re changing. There are two types of flags: ones that are simply
on or off, and ones that work in a group with other flags. The on/off flags are
the simplest to understand because you turn them on with <B>setf(fmtflags)</B>
and off with <B>unsetf(fmtflags)</B>. These flags are</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=90 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B>on/off flag</B></FONT><BR></P></DIV>
</TH>
<TH WIDTH=176 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B>effect</B></FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">ios::skipws<A NAME="Index342"></A></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Skip white space. (For input; this is the
default.)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">ios::showbase<A NAME="Index343"></A></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Indicate the numeric base (dec, oct, or
hex) when printing an integral value. The format used can be read by the C++
compiler.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">ios::showpoint<A NAME="Index344"></A></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Show decimal point and trailing zeros for
floating-point values.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">ios::uppercase<A NAME="Index345"></A></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Display uppercase A-F for hexadecimal
values and E for scientific values.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">ios::showpos<A NAME="Index346"></A></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Show plus sign (+) for positive
values.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">ios::unitbuf<A NAME="Index347"></A></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">&#8220;Unit buffering.&#8221; The stream
is flushed after each insertion.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">ios::stdio<A NAME="Index348"></A></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Synchronizes the stream with the C
standard I/O system.</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I121">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I122"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For example, to show the plus sign for
<B>cout</B>, you say <B>cout.setf(ios::showpos)</B>. To stop showing the plus
sign, you say
<B>cout.unsetf(ios::showpos)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I122">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I123"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The last two flags deserve some
explanation. You turn on unit buffering
<A NAME="Index349"></A><A NAME="Index350"></A>when you want to make sure each
character is output as soon as it is inserted into an output stream. You could
also use unbuffered output, but unit buffering provides better
performance.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I123">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I124"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>ios::stdio</B>
<A NAME="Index351"></A>flag is used when you have a program that uses both
iostreams and the C standard I/O library
<A NAME="Index352"></A><A NAME="Index353"></A><A NAME="Index354"></A>(not
unlikely if you&#8217;re using C libraries). If you discover your iostream
output and <B>printf(&#160;)</B> output are occurring in the wrong order, try
setting this flag.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I124">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I125"></a>
</FONT><BR></P></DIV>
<A NAME="Heading132"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Format fields</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second type of formatting flags work
in a group. You can have only one of these flags on at a time, like the buttons
on old car radios &#8211; you push one in, the rest pop out. Unfortunately this
doesn&#8217;t happen automatically, and you have to pay attention to what flags
you&#8217;re setting so you don&#8217;t accidentally call the wrong
<B>setf(&#160;)</B> function. For example, there&#8217;s a flag for each of the
number bases: hexadecimal<A NAME="Index355"></A>, decimal,
<A NAME="Index356"></A>and octal. Collectively, these flags are referred to as
the <B>ios::basefield<A NAME="Index357"></A></B>. If the <B>ios::dec</B> flag is
set and you call <B>setf(ios::hex)</B>, you&#8217;ll set the <B>ios::hex</B>
flag, but you <I>won&#8217;t</I> clear the <B>ios::dec</B> bit, resulting in
undefined behavior. The proper thing to do is call the second form of
<B>setf(&#160;)</B> like this: <B>setf(ios::hex, ios::basefield)</B>. This
function first clears all the bits in the <B>ios::basefield</B>, <I>then</I>
sets <B>ios::hex</B>. Thus, this form of <B>setf(&#160;)</B> ensures that the
other flags in the group &#8220;pop out&#8221; whenever you set one. Of course,
the <B>hex(&#160;)<A NAME="Index358"></A></B> manipulator does all this for you,
automatically, so you don&#8217;t have to concern yourself with the internal
details of the implementation of this class or to even <I>care</I> that
it&#8217;s a set of binary flags. Later you&#8217;ll see there are manipulators
to provide equivalent functionality in all the places you would use
<B>setf(&#160;)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I125">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I126"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here are the flag groups and their
effects:</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=119 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B>ios::basefield</B></FONT><BR></P></DIV>
</TH>
<TH WIDTH=162 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B>effect</B></FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">ios::dec<A NAME="Index359"></A></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Format integral values in base 10
(decimal) (default radix).</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">ios::hex<A NAME="Index360"></A></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Format integral values in base 16
(hexadecimal).</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">ios::oct<A NAME="Index361"></A></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Format integral values in base 8
(octal).</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>

<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=119 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B>ios::floatfield</B></FONT><BR></P></DIV>
</TH>
<TH WIDTH=162 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B>effect</B></FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">ios::scientific<A NAME="Index362"></A></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Display floating-point numbers in
scientific format. Precision field indicates number of digits after the decimal
point.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">ios::fixed<A NAME="Index363"></A></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Display floating-point numbers in fixed
format. Precision field indicates number of digits after the decimal
point.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">&#8220;automatic<A NAME="Index364"></A>&#8221;
(Neither bit is set.)</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Precision field indicates the total
number of significant digits.</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>

<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=119 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B>ios::adjustfield</B></FONT><BR></P></DIV>
</TH>
<TH WIDTH=162 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B>effect</B></FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">ios::left<A NAME="Index365"></A></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Left-align values; pad on the right with
the fill character.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">ios::right<A NAME="Index366"></A></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Right-align values. Pad on the left with
the fill character. This is the default alignment.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">ios::internal<A NAME="Index367"></A></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Add fill characters after any leading
sign or base indicator, but before the value.</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>

<A NAME="Heading133"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Width, fill and
precision<BR><A NAME="Index368"></A><A NAME="Index369"></A><A NAME="Index370"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The internal variables that control the
width of the output field, the fill character used when the data doesn&#8217;t
fill the output field, and the precision for printing floating-point numbers are
read and written by member functions of the same name.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=119 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B>function</B></FONT><BR></P></DIV>
</TH>
<TH WIDTH=162 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B>effect</B></FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">int
ios::width(&#160;)<A NAME="Index371"></A></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Reads the current width. (Default is 0.)
Used for both insertion and extraction.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">int ios::width(int n)</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Sets the width, returns the previous
width.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">int
ios::fill(&#160;)<A NAME="Index372"></A></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Reads the current fill character.
(Default is space.)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">int ios::fill(int n)</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Sets the fill character, returns the
previous fill character.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">int
ios::precision(&#160;)<A NAME="Index373"></A></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Reads current floating-point precision.
(Default is 6.) </FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">int ios::precision(int
n)</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Sets floating-point precision, returns
previous precision. See <B>ios::floatfield</B> table for the meaning of
&#8220;precision.&#8221;</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I126">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I127"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The fill and precision values are fairly
straightforward, but width requires some explanation. When the width is zero,
inserting a value will produce the minimum number of characters necessary to
represent that value. A positive width means that inserting a value will produce
at least as many characters as the width; if the value has less than width
characters, the fill character is used to pad the field. However, the value will
never be truncated, so if you try to print 123 with a width of two, you&#8217;ll
still get 123. The field width specifies a <I>minimum</I> number of characters;
there&#8217;s no way to specify a maximum
number.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I127">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I128"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The width is also distinctly different
because it&#8217;s reset to zero by each inserter or extractor that could be
influenced by its value. It&#8217;s really not a state variable, but an implicit
argument to the inserters and extractors. If you want to have a constant width,
you have to call <B>width(&#160;)</B> after each insertion or
extraction.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I128">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I129"></a>
</FONT><A NAME="_Toc312373892"></A><A NAME="_Toc519041961"></A><BR></P></DIV>
<A NAME="Heading134"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
An exhaustive example</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To make sure you know how to call all the
functions previously discussed, here&#8217;s an example that calls them
all:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I129">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I130"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:Format.cpp</font>
<font color=#009900>// Formatting functions</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-g++3} g++3 is correct, this program is not</font>
#include &lt;fstream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;
#define D(A) T &lt;&lt; #A &lt;&lt; endl; A
ofstream T(<font color=#004488>"format.out"</font>);

<font color=#0000ff>int</font> main() {
  D(<font color=#0000ff>int</font> i = 47;)
  D(<font color=#0000ff>float</font> f = 2300114.414159;)
  <font color=#0000ff>char</font>* s = <font color=#004488>"Is there any more?"</font>;

  D(T.setf(ios::unitbuf);)
<font color=#009900>//  D(T.setf(ios::stdio);)  // SOMETHING MAY HAVE CHANGED</font>

  D(T.setf(ios::showbase);)
  D(T.setf(ios::uppercase);)
  D(T.setf(ios::showpos);)
  D(T &lt;&lt; i &lt;&lt; endl;) <font color=#009900>// Default to dec</font>
  D(T.setf(ios::hex, ios::basefield);)
  D(T &lt;&lt; i &lt;&lt; endl;)
  D(T.unsetf(ios::uppercase);)
  D(T.setf(ios::oct, ios::basefield);)
  D(T &lt;&lt; i &lt;&lt; endl;)
  D(T.unsetf(ios::showbase);)
  D(T.setf(ios::dec, ios::basefield);)
  D(T.setf(ios::left, ios::adjustfield);)
  D(T.fill('0');)
  D(T &lt;&lt; <font color=#004488>"fill char: "</font> &lt;&lt; T.fill() &lt;&lt; endl;)
  D(T.width(10);)
  T &lt;&lt; i &lt;&lt; endl;
  D(T.setf(ios::right, ios::adjustfield);)
  D(T.width(10);)
  T &lt;&lt; i &lt;&lt; endl;
  D(T.setf(ios::internal, ios::adjustfield);)
  D(T.width(10);)
  T &lt;&lt; i &lt;&lt; endl;
  D(T &lt;&lt; i &lt;&lt; endl;) <font color=#009900>// Without width(10)</font>

  D(T.unsetf(ios::showpos);)
  D(T.setf(ios::showpoint);)
  D(T &lt;&lt; <font color=#004488>"prec = "</font> &lt;&lt; T.precision() &lt;&lt; endl;)
  D(T.setf(ios::scientific, ios::floatfield);)
  D(T &lt;&lt; endl &lt;&lt; f &lt;&lt; endl;)
  D(T.setf(ios::fixed, ios::floatfield);)
  D(T &lt;&lt; f &lt;&lt; endl;)
  D(T.setf(0, ios::floatfield);) <font color=#009900>// Automatic</font>
  D(T &lt;&lt; f &lt;&lt; endl;)
  D(T.precision(20);)
  D(T &lt;&lt; <font color=#004488>"prec = "</font> &lt;&lt; T.precision() &lt;&lt; endl;)
  D(T &lt;&lt; endl &lt;&lt; f &lt;&lt; endl;)
  D(T.setf(ios::scientific, ios::floatfield);)
  D(T &lt;&lt; endl &lt;&lt; f &lt;&lt; endl;)
  D(T.setf(ios::fixed, ios::floatfield);)
  D(T &lt;&lt; f &lt;&lt; endl;)
  D(T.setf(0, ios::floatfield);) <font color=#009900>// Automatic</font>
  D(T &lt;&lt; f &lt;&lt; endl;)

  D(T.width(10);)
  T &lt;&lt; s &lt;&lt; endl;
  D(T.width(40);)
  T &lt;&lt; s &lt;&lt; endl;
  D(T.setf(ios::left, ios::adjustfield);)
  D(T.width(40);)
  T &lt;&lt; s &lt;&lt; endl;

  D(T.unsetf(ios::showpoint);)
  D(T.unsetf(ios::unitbuf);)
<font color=#009900>//  D(T.unsetf(ios::stdio);) // SOMETHING MAY HAVE CHANGED</font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example uses a trick to create a
trace file so you can monitor what&#8217;s happening. The macro <B>D(a)</B> uses
the preprocessor
&#8220;stringizing&#8221;<A NAME="Index374"></A><A NAME="Index375"></A> to turn
<B>a</B> into a string to print out. Then it reiterates <B>a</B> so the
statement takes effect. The macro sends all the information out to a file called
<B>T</B>, which is the trace file. The output
is
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I130">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I131"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font> i = 47;
<font color=#0000ff>float</font> f = 2300114.414159;
T.setf(ios::unitbuf);
T.setf(ios::stdio);
T.setf(ios::showbase);
T.setf(ios::uppercase);
T.setf(ios::showpos);
T &lt;&lt; i &lt;&lt; endl;
+47
T.setf(ios::hex, ios::basefield);
T &lt;&lt; i &lt;&lt; endl;
+0X2F
T.unsetf(ios::uppercase);
T.setf(ios::oct, ios::basefield);
T &lt;&lt; i &lt;&lt; endl;
+057
T.unsetf(ios::showbase);
T.setf(ios::dec, ios::basefield);
T.setf(ios::left, ios::adjustfield);
T.fill('0');
T &lt;&lt; <font color=#004488>"fill char: "</font> &lt;&lt; T.fill() &lt;&lt; endl;
fill <font color=#0000ff>char</font>: 0
T.width(10);
+470000000
T.setf(ios::right, ios::adjustfield);
T.width(10);
0000000+47
T.setf(ios::internal, ios::adjustfield);
T.width(10);
+000000047
T &lt;&lt; i &lt;&lt; endl;
+47
T.unsetf(ios::showpos);
T.setf(ios::showpoint);
T &lt;&lt; <font color=#004488>"prec = "</font> &lt;&lt; T.precision() &lt;&lt; endl;
prec = 6
T.setf(ios::scientific, ios::floatfield);
T &lt;&lt; endl &lt;&lt; f &lt;&lt; endl;

2.300115e+06
T.setf(ios::fixed, ios::floatfield);
T &lt;&lt; f &lt;&lt; endl;
2300114.500000
T.setf(0, ios::floatfield);
T &lt;&lt; f &lt;&lt; endl;
2.300115e+06
T.precision(20);
T &lt;&lt; <font color=#004488>"prec = "</font> &lt;&lt; T.precision() &lt;&lt; endl;
prec = 20
T &lt;&lt; endl &lt;&lt; f &lt;&lt; endl;

2300114.50000000020000000000
T.setf(ios::scientific, ios::floatfield);
T &lt;&lt; endl &lt;&lt; f &lt;&lt; endl;

2.30011450000000020000e+06
T.setf(ios::fixed, ios::floatfield);
T &lt;&lt; f &lt;&lt; endl;
2300114.50000000020000000000
T.setf(0, ios::floatfield);
T &lt;&lt; f &lt;&lt; endl;
2300114.50000000020000000000
T.width(10);
Is there any more?
T.width(40);
0000000000000000000000Is there any more?
T.setf(ios::left, ios::adjustfield);
T.width(40);
Is there any more?0000000000000000000000
T.unsetf(ios::showpoint);
T.unsetf(ios::unitbuf);
T.unsetf(ios::stdio);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Studying this output should clarify your
understanding of the iostream formatting member
functions.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I131">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I132"></a>
</FONT><A NAME="_Toc305628670"></A><A NAME="_Toc312373893"></A><A NAME="_Toc519041962"></A><BR></P></DIV>
<A NAME="Heading135"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Formatting
manipulators<BR><A NAME="Index376"></A><A NAME="Index377"></A><A NAME="Index378"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As you can see from the previous example,
calling the member functions can get a bit tedious. To make things easier to
read and write, a set of manipulators is supplied to duplicate the actions
provided by the member
functions.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I132">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I133"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Manipulators with no arguments are
provided in <B>&lt;iostream&gt;</B>. These include
<B>dec<A NAME="Index379"></A><A NAME="Index380"></A></B>, <B>oct</B>,
<A NAME="Index381"></A> <A NAME="Index382"></A>and <B>hex</B>
<A NAME="Index383"></A><A NAME="Index384"></A>, which perform the same action
as, respectively, <B>setf(ios::dec, ios::basefield)</B>, <B>setf(ios::oct,
ios::basefield)</B>, and <B>setf(ios::hex, ios::basefield)</B>, albeit more
succinctly.
<B>&lt;iostream&gt;</B></FONT><A NAME="fnB12" HREF="#fn12">[12]</A><FONT FACE="Georgia">
also includes <B>ws<A NAME="Index385"></A><A NAME="Index386"></A></B>,
<B>endl<A NAME="Index387"></A><A NAME="Index388"></A></B>, <B>ends</B>, and
<B>flush<A NAME="Index389"></A><A NAME="Index390"></A></B> and the additional
set shown here:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I133">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I134"></a>
</FONT><BR></P></DIV>

<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=126 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B>manipulator</B></FONT><BR></P></DIV>
</TH>
<TH WIDTH=150 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B>effect</B></FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">showbase<A NAME="Index391"></A></FONT><BR><FONT FACE="Georgia">noshowbase<A NAME="Index392"></A></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Indicate the numeric base (dec, oct, or
hex) when printing an integral value. The format used can be read by the C++
compiler.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">showpos<A NAME="Index393"></A></FONT><BR><FONT FACE="Georgia">noshowpos<A NAME="Index394"></A></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Show plus sign (+) for positive
values</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">uppercase<A NAME="Index395"></A></FONT><BR><FONT FACE="Georgia">nouppercase<A NAME="Index396"></A></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Display uppercase A-F for hexadecimal
values, and E for scientific values</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">showpoint<A NAME="Index397"></A></FONT><BR><FONT FACE="Georgia">noshowpoint<A NAME="Index398"></A></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Show decimal point and trailing zeros for
floating-point values.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">skipws<A NAME="Index399"></A></FONT><BR><FONT FACE="Georgia">noskipws<A NAME="Index400"></A></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Skip white space on
input.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">left<A NAME="Index401"></A></FONT><BR><FONT FACE="Georgia">right<A NAME="Index402"></A></FONT><BR><FONT FACE="Georgia">internal<A NAME="Index403"></A></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Left-align, pad on
right.</FONT><BR><FONT FACE="Georgia">Right-align, pad on
left.</FONT><BR><FONT FACE="Georgia">Fill between leading sign or base indicator
and value.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">scientific<A NAME="Index404"></A></FONT><BR><FONT FACE="Georgia">fixed<A NAME="Index405"></A></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Use scientific
notation</FONT><BR><FONT FACE="Georgia"><B>setprecision(&#160;)</B> or
<B>ios::precision(&#160;)</B> sets number of places after the decimal
point.</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="_Toc312373894"></A><A NAME="_Toc519041963"></A><BR></P></DIV>
<A NAME="Heading136"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Manipulators with arguments</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you are using manipulators with
arguments, you must also include the header file &lt;<B>iomanip&gt;</B>. This
contains code to solve the general problem of creating manipulators with
arguments. In addition, it has six predefined manipulators:</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=126 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B>manipulator</B></FONT><BR></P></DIV>
</TH>
<TH WIDTH=150 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B>effect</B></FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">setiosflags<A NAME="Index406"></A>
(fmtflags n)</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Sets only the format flags specified by
n. Setting remains in effect until the next change, like
<B>ios::setf(&#160;)</B>.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">resetiosflags<A NAME="Index407"></A>(fmtflags
n)</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Clears only the format flags specified by
n. Setting remains in effect until the next change, like
<B>ios::unsetf(&#160;)</B>.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">setbase<A NAME="Index408"></A>(base
n)</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Changes base to n, where n is 10, 8, or
16. (Anything else results in 0.) If n is zero, output is base 10, but input
uses the C conventions: 10 is 10, 010 is 8, and 0xf is 15. You might as well use
<B>dec</B>, <B>oct</B>, and <B>hex</B> for output.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">setfill<A NAME="Index409"></A>(char
n)</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Changes the fill character to n, like
<B>ios::fill(&#160;)</B>.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">setprecision<A NAME="Index410"></A>(int
n)</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Changes the precision to n, like
<B>ios::precision(&#160;)</B>.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">setw<A NAME="Index411"></A>(int
n)</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Changes the field width to n, like
<B>ios::width(&#160;)</B>.</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you&#8217;re using a lot of inserters,
you can see how this can clean things up. As an example, here&#8217;s the
previous program rewritten to use the manipulators. (The macro has been removed
to make it easier to
read.)
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I134">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I135"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:Manips.cpp</font>
<font color=#009900>// Format.cpp using manipulators</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-g++3} g++3 is probably correct, the problem</font>
<font color=#009900>// is most likely with this program.</font>
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  ofstream trc(<font color=#004488>"trace.out"</font>);
  <font color=#0000ff>int</font> i = 47;
  <font color=#0000ff>float</font> f = 2300114.414159;
  <font color=#0000ff>char</font>* s = <font color=#004488>"Is there any more?"</font>;

  trc &lt;&lt; setiosflags(
         ios::unitbuf <font color=#009900>/*| ios::stdio */</font> <font color=#009900>/// ?????</font>
         | ios::showbase | ios::uppercase
         | ios::showpos);
  trc &lt;&lt; i &lt;&lt; endl; <font color=#009900>// Default to dec</font>
  trc &lt;&lt; hex &lt;&lt; i &lt;&lt; endl;
  trc &lt;&lt; resetiosflags(ios::uppercase)
    &lt;&lt; oct &lt;&lt; i &lt;&lt; endl;
  trc.setf(ios::left, ios::adjustfield);
  trc &lt;&lt; resetiosflags(ios::showbase)
    &lt;&lt; dec &lt;&lt; setfill('0');
  trc &lt;&lt; <font color=#004488>"fill char: "</font> &lt;&lt; trc.fill() &lt;&lt; endl;
  trc &lt;&lt; setw(10) &lt;&lt; i &lt;&lt; endl;
  trc.setf(ios::right, ios::adjustfield);
  trc &lt;&lt; setw(10) &lt;&lt; i &lt;&lt; endl;
  trc.setf(ios::internal, ios::adjustfield);
  trc &lt;&lt; setw(10) &lt;&lt; i &lt;&lt; endl;
  trc &lt;&lt; i &lt;&lt; endl; <font color=#009900>// Without setw(10)</font>

  trc &lt;&lt; resetiosflags(ios::showpos)
    &lt;&lt; setiosflags(ios::showpoint)
    &lt;&lt; <font color=#004488>"prec = "</font> &lt;&lt; trc.precision() &lt;&lt; endl;
  trc.setf(ios::scientific, ios::floatfield);
  trc &lt;&lt; f &lt;&lt; endl;
  trc.setf(ios::fixed, ios::floatfield);
  trc &lt;&lt; f &lt;&lt; endl;
  trc.setf(0, ios::floatfield); <font color=#009900>// Automatic</font>
  trc &lt;&lt; f &lt;&lt; endl;
  trc &lt;&lt; setprecision(20);
  trc &lt;&lt; <font color=#004488>"prec = "</font> &lt;&lt; trc.precision() &lt;&lt; endl;
  trc &lt;&lt; f &lt;&lt; endl;
  trc.setf(ios::scientific, ios::floatfield);
  trc &lt;&lt; f &lt;&lt; endl;
  trc.setf(ios::fixed, ios::floatfield);
  trc &lt;&lt; f &lt;&lt; endl;
  trc.setf(0, ios::floatfield); <font color=#009900>// Automatic</font>
  trc &lt;&lt; f &lt;&lt; endl;

  trc &lt;&lt; setw(10) &lt;&lt; s &lt;&lt; endl;
  trc &lt;&lt; setw(40) &lt;&lt; s &lt;&lt; endl;
  trc.setf(ios::left, ios::adjustfield);
  trc &lt;&lt; setw(40) &lt;&lt; s &lt;&lt; endl;

  trc &lt;&lt; resetiosflags(
         ios::showpoint | ios::unitbuf
         <font color=#009900>// | ios::stdio // ?????????</font>
 );
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that a lot of the multiple
statements have been condensed into a single chained insertion. Note the calls
to <B>setiosflags(&#160;)</B> and <B>resetiosflags(&#160;)</B>, where the flags
have been bitwise-ORed together. This could also have been done with
<B>setf(&#160;)</B> and <B>unsetf(&#160;)</B> in the previous
example.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I135">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I136"></a>
</FONT><A NAME="_Toc312373895"></A><A NAME="_Toc519041964"></A><BR></P></DIV>
<A NAME="Heading137"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Creating
manipulators<BR><A NAME="Index412"></A><A NAME="Index413"></A><A NAME="Index414"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">(Note: This section contains some
material that will not be introduced until later chapters.) Sometimes
you&#8217;d like to create your own manipulators, and it turns out to be
remarkably simple. A zero-argument manipulator like <B>endl </B>is simply a
function that takes as its argument an <B>ostream</B> reference (references are
a different way to pass arguments, discussed in Chapter XX). The declaration for
<B>endl</B> is
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I136">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I137"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>ostream&amp; endl(ostream&amp;);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now, when you
say:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I137">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I138"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>cout &lt;&lt; &#8220;howdy&#8221; &lt;&lt; endl;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">the <B>endl</B> produces the
<I>address</I> of that function. So the compiler says &#8220;is there a function
I can call that takes the address of a function as its argument?&#8221; There is
a pre-defined function in <B>Iostream.h </B>to do this; it&#8217;s called an
<I>applicator<A NAME="Index415"></A><A NAME="Index416"></A></I>. The applicator
calls the function, passing it the <B>ostream</B> object as an
argument.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I138">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I139"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You don&#8217;t need to know how the
applicator works to create your own manipulator; you only need to know the
applicator exists. Here&#8217;s an example that creates a manipulator called
<B>nl</B> that emits a newline
<A NAME="Index417"></A><A NAME="Index418"></A><I>without</I> flushing the
stream:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I139">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I140"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:nl.cpp</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>// Creating a manipulator</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

ostream&amp; nl(ostream&amp; os) {
  <font color=#0000ff>return</font> os &lt;&lt; '\n';
}

<font color=#0000ff>int</font> main() {
  cout &lt;&lt; <font color=#004488>"newlines"</font> &lt;&lt; nl &lt;&lt; <font color=#004488>"between"</font> &lt;&lt; nl
       &lt;&lt; <font color=#004488>"each"</font> &lt;&lt; nl &lt;&lt; <font color=#004488>"word"</font> &lt;&lt; nl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The expression</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>os &lt;&lt; '\n';</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">calls a function that returns <B>os</B>,
which is what is returned from
<B>nl</B>.</FONT><A NAME="fnB13" HREF="#fn13">[13]</A><FONT FACE="Georgia">
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I140">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I141"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">People often argue that the <B>nl</B>
approach shown above is preferable to using <B>endl</B> because the latter
always flushes the output stream, which may incur a performance
penalty.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I141">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I142"></a>
</FONT><A NAME="_Toc312373896"></A><A NAME="_Toc519041965"></A><BR></P></DIV>
<A NAME="Heading138"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Effectors</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As you&#8217;ve seen, zero-argument
manipulators are quite easy to create. But what if you want to create a
manipulator that takes arguments? The iostream library has a rather convoluted
and confusing way to do this, but Jerry Schwarz<A NAME="Index419"></A>, the
creator of the iostream library,
suggests</FONT><A NAME="fnB14" HREF="#fn14">[14]</A><FONT FACE="Georgia"> a
scheme he calls <I>effectors<A NAME="Index420"></A><A NAME="Index421"></A></I>.
An effector is a simple class whose constructor performs the desired operation,
along with an overloaded <B>operator&lt;&lt;</B> that works with the class.
Here&#8217;s an example with two effectors. The first outputs a truncated
character string, and the second prints a number in binary
<A NAME="Index422"></A><A NAME="Index423"></A>(the process of defining an
overloaded <B>operator&lt;&lt;</B> will not be discussed until Chapter
XX):
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I142">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I143"></a>
</FONT><A NAME="_Toc305628671"></A><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:Effector.cpp</font>
<font color=#009900>// Jerry Schwarz's "effectors"</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;string&gt;
#include &lt;climits&gt; <font color=#009900>// ULONG_MAX</font>
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#009900>// Put out a portion of a string:</font>
<font color=#0000ff>class</font> Fixw {
  string str;
<font color=#0000ff>public</font>:
  Fixw(<font color=#0000ff>const</font> string&amp; s, <font color=#0000ff>int</font> width)
    : str(s, 0, width) {}
  <font color=#0000ff>friend</font> ostream&amp; 
  <font color=#0000ff>operator</font>&lt;&lt;(ostream&amp; os, <font color=#0000ff>const</font> Fixw&amp; fw) {
    <font color=#0000ff>return</font> os &lt;&lt; fw.str;
  }
};

<font color=#0000ff>typedef</font> <font color=#0000ff>unsigned</font> <font color=#0000ff>long</font> ulong;

<font color=#009900>// Print a number in binary:</font>
<font color=#0000ff>class</font> Bin {
  ulong n;
<font color=#0000ff>public</font>:
  Bin(ulong nn) { n = nn; }
  <font color=#0000ff>friend</font> 
  ostream&amp; <font color=#0000ff>operator</font>&lt;&lt;(ostream&amp;, <font color=#0000ff>const</font> Bin&amp;);
};

ostream&amp; <font color=#0000ff>operator</font>&lt;&lt;(ostream&amp; os, <font color=#0000ff>const</font> Bin&amp; b) {
  ulong bit = ~(ULONG_MAX &gt;&gt; 1); <font color=#009900>// Top bit set</font>
  <font color=#0000ff>while</font>(bit) {
    os &lt;&lt; (b.n &amp; bit ? '1' : '0');
    bit &gt;&gt;= 1;
  }
  <font color=#0000ff>return</font> os;
}

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>char</font>* string =
    <font color=#004488>"Things that make us happy, make us wise"</font>;
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 1; i &lt;= strlen(string); i++)
    cout &lt;&lt; Fixw(string, i) &lt;&lt; endl;
  ulong x = 0xCAFEBABEUL;
  ulong y = 0x76543210UL;
  cout &lt;&lt; <font color=#004488>"x in binary: "</font> &lt;&lt; Bin(x) &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"y in binary: "</font> &lt;&lt; Bin(y) &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The constructor for <B>Fixw</B> creates a
shortened copy of its <B>char*</B> argument, and the destructor releases the
memory created for this copy. The overloaded <B>operator&lt;&lt;</B> takes the
contents of its second argument, the <B>Fixw</B> object, and inserts it into the
first argument, the <B>ostream</B>, then returns the <B>ostream</B> so it can be
used in a chained expression. When you use <B>Fixw</B> in an expression like
this:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I143">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I144"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>cout &lt;&lt; Fixw(string, i) &lt;&lt; endl;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">a <I>temporary object</I>
<A NAME="Index424"></A><A NAME="Index425"></A>is created by the call to the
<B>Fixw</B> constructor, and that temporary is passed to
<B>operator&lt;&lt;</B>. The effect is that of a manipulator with
arguments.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I144">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I145"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Bin</B> effector relies on the
fact that shifting an unsigned number to the right shifts zeros into the high
bits. ULONG_MAX <A NAME="Index426"></A>(the largest <B>unsigned long</B> value,
from the standard include file <B>&lt;climits&gt;</B> <A NAME="Index427"></A>)
is used to produce a value with the high bit set, and this value is moved across
the number in question (by shifting it), masking each
bit.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I145">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I146"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Initially the problem with this technique
was that once you created a class called <B>Fixw</B> for <B>char*</B> or <B>Bin
</B>for <B>unsigned long</B>,<B> </B>no one else could create a different
<B>Fixw</B> or <B>Bin </B>class for their type. However, with <I>namespaces</I>
<A NAME="Index428"></A>(covered in Chapter XX), this problem is
eliminated.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I146">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I147"></a>
</FONT><A NAME="_Toc312373897"></A><A NAME="_Toc519041966"></A><BR></P></DIV>
<A NAME="Heading139"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Iostream examples</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In this section you&#8217;ll see some
examples of what you can do with all the information you&#8217;ve learned in
this chapter. Although many tools exist to manipulate bytes (stream editors like
<B>sed</B> <A NAME="Index429"></A>and <B>awk</B> <A NAME="Index430"></A>from
Unix <A NAME="Index431"></A>are perhaps the most well known, but a text editor
also fits this category), they generally have some limitations. <B>sed</B> and
<B>awk</B> can be slow and can only handle lines in a forward sequence, and text
editors usually require human interaction, or at least learning a proprietary
macro language. The programs you write with iostreams have none of these
limitations: They&#8217;re fast, portable, and flexible. It&#8217;s a very
useful tool to have in your
kit.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I147">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I148"></a>
</FONT><A NAME="_Toc312373898"></A><A NAME="_Toc519041967"></A><BR></P></DIV>
<A NAME="Heading140"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Code generation</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first examples concern the generation
of programs that, coincidentally, fit the format used in this book. This
provides a little extra speed and consistency when developing code. The first
program creates a file to hold <B>main(&#160;)</B> (assuming it takes no
command-line arguments and uses the iostream
library):
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I148">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I149"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:Makemain.cpp</font>
<font color=#009900>// Create a shell main() file</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;fstream&gt;
#include &lt;strstream&gt;
#include &lt;cstring&gt;
#include &lt;cctype&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>void</font> makeMain(<font color=#0000ff>char</font>* fileName) {
  ofstream mainfile(fileName);
  assure(mainfile, fileName);
  istrstream name(fileName);
  ostrstream CAPname;
  <font color=#0000ff>char</font> c;
  <font color=#0000ff>while</font>(name.get(c))
    CAPname &lt;&lt; <font color=#0000ff>char</font>(toupper(c));
  CAPname &lt;&lt; ends;
  mainfile &lt;&lt; <font color=#004488>"</font><font color=#004488>/</font><font color=#004488>/"</font> &lt;&lt; <font color=#004488>": "</font> &lt;&lt; CAPname.rdbuf()
    &lt;&lt; <font color=#004488>" -- "</font> &lt;&lt; endl
    &lt;&lt; <font color=#004488>"#include &lt;iostream&gt;"</font> &lt;&lt; endl
    &lt;&lt; endl
    &lt;&lt; <font color=#004488>"main() {"</font> &lt;&lt; endl &lt;&lt; endl
    &lt;&lt; <font color=#004488>"}"</font> &lt;&lt; endl;
}

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  <font color=#0000ff>if</font>(argc &gt; 1)
    makeMain(argv[1]);
  <font color=#0000ff>else</font>
    makeMain(<font color=#004488>"mainTest.cpp"</font>);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The file name is used to create an
<B>istrstream</B>, so the characters can be extracted one at a time and
converted to upper case with the Standard C library macro
<B>toupper(&#160;)<A NAME="Index432"></A><A NAME="Index433"></A></B>. This
returns an <B>int</B> so it must be explicitly cast to a <B>char</B>. This name
is used in the headline, followed by the remainder of the generated
file.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I149">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I150"></a>
</FONT><BR></P></DIV>
<A NAME="Heading141"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Maintaining class library
source<BR><A NAME="Index434"></A><A NAME="Index435"></A><A NAME="Index436"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second example performs a more
complex and useful task. Generally, when you create a class you think in library
terms, and make a header file <B>Name.h </B>for the class declaration and a file
where the member functions are implemented, called <B>Name.cpp</B>. These files
have certain requirements: a particular coding standard (the program shown here
will use the coding format for this book), and in the header file the
declarations are generally surrounded by some preprocessor statements to prevent
multiple declarations of classes. (Multiple declarations confuse the compiler
&#8211; it doesn&#8217;t know which one you want to use. They could be
different, so it throws up its hands and gives an error
message.)
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I150">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I151"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example allows you to create a new
header-implementation pair of files, or to modify an existing pair. If the files
already exist, it checks and potentially modifies the files, but if they
don&#8217;t exist, it creates them using the proper
format.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I151">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I152"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">[[ This still needs work.
]]</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:Cppcheck.cpp</font>
<font color=#009900>// Configures .h &amp; .cpp files to conform to style</font>
<font color=#009900>// standard. Tests existing files for conformance.</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;fstream&gt;
#include &lt;strstream&gt;
#include &lt;string&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>void</font> cppCheck(string fileName) {
  <font color=#0000ff>enum</font> bufs { base, header, implement,
    Hline1, guard1, guard2, guard3,
    CPPline1, include, bufnum };
  string part[bufnum + 1];
  part[base] = fileName;
  <font color=#009900>// Find any '.' in the string:</font>
  <font color=#0000ff>int</font> loc = part[base].find('.');
  <font color=#0000ff>if</font>(loc != string::npos) 
    part[base][loc] = 0; <font color=#009900>// Strip extension</font>
  <font color=#009900>// Force to upper case:</font>
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; part[base].size(); i++)
    part[base][i] = toupper(part[base][i]);
  <font color=#009900>// Create file names and internal lines:</font>
  part[header] = part[base] + <font color=#004488>".h"</font>;
  part[implement] = part[base] + <font color=#004488>".cpp"</font>;
  part[Hline1] = string(<font color=#004488>"</font><font color=#004488>/</font><font color=#004488>/"</font>) + string(<font color=#004488>": "</font>) 
    + part[header] + <font color=#004488>" -- "</font>;
  part[guard1] = <font color=#004488>"#ifndef "</font> + part[base] + <font color=#004488>"_H"</font>;
  part[guard2] = <font color=#004488>"#define "</font> + part[base] + <font color=#004488>"_H"</font>;
  part[guard3] = <font color=#004488>"#endif </font><font color=#004488>/</font><font color=#004488>/ "</font> + part[base] +<font color=#004488>"_H"</font>;
  part[CPPline1] = string(<font color=#004488>"</font><font color=#004488>/</font><font color=#004488>/"</font>) + <font color=#004488>": "</font> 
    + part[implement] + <font color=#004488>" -- "</font>;
  part[include] = <font color=#004488>"#include \"</font>" + part[header] 
    + <font color=#004488>"\"</font>";
  <font color=#009900>// First, try to open existing files:</font>
  ifstream existh(part[header].c_str()),
           existcpp(part[implement].c_str());
  <font color=#0000ff>if</font>(!existh) { <font color=#009900>// Doesn't exist; create it</font>
    ofstream newheader(part[header].c_str());
    assure(newheader, part[header].c_str());
    newheader &lt;&lt; part[Hline1] &lt;&lt; endl
      &lt;&lt; part[guard1] &lt;&lt; endl
      &lt;&lt; part[guard2] &lt;&lt; endl &lt;&lt; endl
      &lt;&lt; part[guard3] &lt;&lt; endl;
  }
  <font color=#0000ff>if</font>(!existcpp) { <font color=#009900>// Create cpp file</font>
    ofstream newcpp(part[implement].c_str());
    assure(newcpp, part[implement].c_str());
    newcpp &lt;&lt; part[CPPline1] &lt;&lt; endl
      &lt;&lt; part[include] &lt;&lt; endl;
  }
  <font color=#0000ff>if</font>(existh) { <font color=#009900>// Already exists; verify it</font>
    strstream hfile; <font color=#009900>// Write &amp; read</font>
    ostrstream newheader; <font color=#009900>// Write</font>
    hfile &lt;&lt; existh.rdbuf() &lt;&lt; ends;
    <font color=#009900>// Check that first line conforms:</font>
    string s;
    <font color=#0000ff>if</font>(getline(hfile, s)) {
      <font color=#0000ff>if</font>(s.find(<font color=#004488>"</font><font color=#004488>/</font><font color=#004488>/"</font> <font color=#004488>":"</font>) == string::npos ||
         s.find(part[header]) == string::npos)
        newheader &lt;&lt; part[Hline1] &lt;&lt; endl;
    }
    <font color=#009900>// Ensure guard lines are in header:</font>
    string head = string(hfile.str());
    <font color=#0000ff>if</font>(head.find(part[guard1]) == string::npos ||
      head.find(part[guard2]) == string::npos ||
      head.find(part[guard3]) == string::npos) {
       newheader &lt;&lt; part[guard1] &lt;&lt; endl
         &lt;&lt; part[guard2] &lt;&lt; endl
         &lt;&lt; s
         &lt;&lt; hfile.rdbuf() &lt;&lt; endl
         &lt;&lt; part[guard3] &lt;&lt; endl &lt;&lt; ends;
    } <font color=#0000ff>else</font>
      newheader &lt;&lt; s
        &lt;&lt; hfile.rdbuf() &lt;&lt; ends;
    <font color=#009900>// If there were changes, overwrite file:</font>
    <font color=#0000ff>if</font>(strcmp(hfile.str(),newheader.str())!=0){
      existh.close();
      ofstream newH(part[header].c_str());
      assure(newH, part[header].c_str());
      newH &lt;&lt; <font color=#004488>"</font><font color=#004488>/</font><font color=#004488>/@</font><font color=#004488>/</font><font color=#004488>/"</font> &lt;&lt; endl <font color=#009900>// Change marker</font>
        &lt;&lt; newheader.rdbuf();
    }
    <font color=#0000ff>delete</font> hfile.str();
    <font color=#0000ff>delete</font> newheader.str();
  }
  <font color=#0000ff>if</font>(existcpp) { <font color=#009900>// Already exists; verify it</font>
    strstream cppfile;
    ostrstream newcpp;
    cppfile &lt;&lt; existcpp.rdbuf() &lt;&lt; ends;
    string s;
    <font color=#009900>// Check that first line conforms:</font>
    <font color=#0000ff>if</font>(getline(cppfile, s))
      <font color=#0000ff>if</font>(s != <font color=#004488>"</font><font color=#004488>/</font><font color=#004488>/"</font> <font color=#004488>":"</font> || s != part[implement])
        newcpp &lt;&lt; part[CPPline1] &lt;&lt; endl;
    <font color=#009900>// Ensure header is included:</font>
    <font color=#0000ff>if</font>(string(cppfile.str()) != part[include])
      newcpp &lt;&lt; part[include] &lt;&lt; endl;
    <font color=#009900>// Put in the rest of the file:</font>
    newcpp &lt;&lt; s &lt;&lt; endl; <font color=#009900>// First line read</font>
    newcpp &lt;&lt; cppfile.rdbuf() &lt;&lt; ends;
    <font color=#009900>// If there were changes, overwrite file:</font>
    <font color=#0000ff>if</font>(string(cppfile.str()) != string(newcpp.str())){
      existcpp.close();
      ofstream newCPP(part[implement].c_str());
      assure(newCPP, part[implement].c_str());
      newCPP &lt;&lt; <font color=#004488>"</font><font color=#004488>/</font><font color=#004488>/@</font><font color=#004488>/</font><font color=#004488>/"</font> &lt;&lt; endl <font color=#009900>// Change marker</font>
        &lt;&lt; newcpp.rdbuf();
    }
    <font color=#0000ff>delete</font> cppfile.str();
    <font color=#0000ff>delete</font> newcpp.str();
  }
}

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  <font color=#0000ff>if</font>(argc &gt; 1)
    cppCheck(argv[1]);
  <font color=#0000ff>else</font>
    cppCheck(<font color=#004488>"cppCheckTest.h"</font>);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example requires a lot of string
formatting in many different buffers. Rather than creating a lot of individually
named buffers and <B>ostrstream</B> <A NAME="Index437"></A>objects, a single set
of names is created in the <B>enum</B> <B>bufs</B>. Then two arrays are created:
an array of character buffers and an array of <B>ostrstream</B> objects built
from those character buffers. Note that in the definition for the
two-dimensional array of <B>char</B> buffers <B>b</B>, the number of <B>char</B>
arrays is determined by <B>bufnum</B>, the last enumerator in <B>bufs</B>. When
you create an enumeration<A NAME="Index438"></A>, the compiler assigns integral
values to all the <B>enum</B> labels starting at zero, so the sole purpose of
<B>bufnum</B> is to be a counter for the number of enumerators in <B>buf</B>.
The length of each string in <B>b</B> is
<B>sz</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I152">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I153"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The names in the enumeration are
<B>base</B>, the capitalized base file name without extension; <B>header</B>,
the header file name; <B>implement</B>, the implementation file (<B>cpp</B>)
name; <B>Hline1</B>, the skeleton first line of the header file; <B>guard1</B>,
<B>guard2</B>, and <B>guard3</B>, the &#8220;guard&#8221; lines in the header
file (to prevent multiple inclusion); <B>CPPline1</B>, the skeleton first line
of the <B>cpp</B> file; and <B>include</B>, the line in the <B>cpp</B> file that
includes the header
file.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I153">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I154"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>osarray</B> is an array of
<B>ostrstream</B> objects created using aggregate initialization and automatic
counting. Of course, this is the form of the <B>ostrstream</B> constructor that
takes two arguments (the buffer address and buffer size), so the constructor
calls must be formed accordingly inside the aggregate initializer list. Using
the <B>bufs</B> enumerators, the appropriate array element of <B>b</B> is tied
to the corresponding <B>osarray</B> object. Once the array is created, the
objects in the array can be selected using the enumerators, and the effect is to
fill the corresponding <B>b</B> element. You can see how each string is built in
the lines following the <B>ostrstream</B> array
definition.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I154">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I155"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once the strings have been created, the
program attempts to open existing versions of both the header and <B>cpp</B>
file as <B>ifstream</B>s. If you test the object using the operator
&#8216;<B>!</B>&#8217; and the file doesn&#8217;t exist, the test will fail. If
the header or implementation file doesn&#8217;t exist, it is created using the
appropriate lines of text built
earlier.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I155">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I156"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If the files <I>do</I> exist, then they
are verified to ensure the proper format is followed. In both cases, a
<B>strstream</B> <A NAME="Index439"></A>is created and the whole file is read
in; then the first line is read and checked to make sure it follows the format
by seeing if it contains both a &#8220;<B>//:</B>&#8221; and the name of the
file. This is accomplished with the Standard C library function
<B>strstr(&#160;)<A NAME="Index440"></A></B>. If the first line doesn&#8217;t
conform, the one created earlier is inserted into an <B>ostrstream</B> that has
been created to hold the edited
file.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I156">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I157"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the header file, the whole file is
searched (again using <B>strstr(&#160;)</B>) to ensure it contains the three
&#8220;guard&#8221; lines; if not, they are inserted. The implementation file is
checked for the existence of the line that includes the header file (although
the compiler effectively guarantees its
existence).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I157">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I158"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In both cases, the original file (in its
<B>strstream</B>) and the edited file (in the <B>ostrstream</B>) are compared to
see if there are any changes. If there are, the existing file is closed, and a
new <B>ofstream</B> object is created to overwrite it. The <B>ostrstream</B> is
output to the file after a special change marker is added at the beginning, so
you can use a text search program to rapidly find any files that need reviewing
to make additional
changes.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I158">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I159"></a>
</FONT><BR></P></DIV>
<A NAME="Heading142"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Detecting compiler errors</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All the code in this book is designed to
compile as shown without errors<A NAME="Index441"></A>. Any line of code that
should generate a compile-time error is commented out with the special comment
sequence &#8220;//!&#8221;. The following program will remove these special
comments and append a numbered comment to the line, so that when you run your
compiler it should generate error messages and you should see all the numbers
appear when you compile all the files. It also appends the modified line to a
special file so you can easily locate any lines that don&#8217;t generate
errors:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I159">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I160"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:Showerr.cpp</font>
<font color=#009900>// Un-comment error generators</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;strstream&gt;
#include &lt;cctype&gt;
#include &lt;cstring&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;
<font color=#0000ff>char</font>* marker = <font color=#004488>"</font><font color=#004488>/</font><font color=#004488>/!"</font>;

<font color=#0000ff>char</font>* usage =
<font color=#004488>"usage: showerr filename chapnum\n"</font>
<font color=#004488>"where filename is a C++ source file\n"</font>
<font color=#004488>"and chapnum is the chapter name it's in.\n"</font>
<font color=#004488>"Finds lines commented with </font><font color=#004488>/</font><font color=#004488>/! and removes\n"</font>
<font color=#004488>"comment, appending </font><font color=#004488>/</font><font color=#004488>/(#) where # is unique\n"</font>
<font color=#004488>"across all files, so you can determine\n"</font>
<font color=#004488>"if your compiler finds the error.\n"</font>
<font color=#004488>"showerr </font><font color=#004488>/r\n"</font>
<font color=#004488>"resets the unique counter."</font>;

<font color=#009900>// File containing error number counter:</font>
<font color=#0000ff>char</font>* errnum = <font color=#004488>"..</font><font color=#004488>/errnum.txt"</font>;
<font color=#009900>// File containing error lines:</font>
<font color=#0000ff>char</font>* errfile = <font color=#004488>"..</font><font color=#004488>/errlines.txt"</font>;
ofstream errlines(errfile,ios::app);

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  requireArgs(argc, 2, usage);
  <font color=#0000ff>if</font>(argv[1][0] == '/' || argv[1][0] == '-') {
    <font color=#009900>// Allow for other switches:</font>
    <font color=#0000ff>switch</font>(argv[1][1]) {
      <font color=#0000ff>case</font> 'r': <font color=#0000ff>case</font> 'R':
        cout &lt;&lt; <font color=#004488>"reset counter"</font> &lt;&lt; endl;
        remove(errnum); <font color=#009900>// Delete files</font>
        remove(errfile);
        <font color=#0000ff>return</font> 0;
      <font color=#0000ff>default</font>:
        cerr &lt;&lt; usage &lt;&lt; endl;
        <font color=#0000ff>return</font> 1;
    }
  }
  <font color=#0000ff>char</font>* chapter = argv[2];
  strstream edited; <font color=#009900>// Edited file</font>
  <font color=#0000ff>int</font> counter = 0;
  {
    ifstream infile(argv[1]);
    assure(infile, argv[1]);
    ifstream count(errnum);
    assure(count, errnum);
    <font color=#0000ff>if</font>(count) count &gt;&gt; counter;
    <font color=#0000ff>int</font> linecount = 0;
    <font color=#0000ff>const</font> <font color=#0000ff>int</font> sz = 255;
    <font color=#0000ff>char</font> buf[sz];
    <font color=#0000ff>while</font>(infile.getline(buf, sz)) {
      linecount++;
      <font color=#009900>// Eat white space:</font>
      <font color=#0000ff>int</font> i = 0;
      <font color=#0000ff>while</font>(isspace(buf[i]))
        i++;
      <font color=#009900>// Find marker at start of line:</font>
      <font color=#0000ff>if</font>(strstr(&amp;buf[i], marker) == &amp;buf[i]) {
        <font color=#009900>// Erase marker:</font>
        memset(&amp;buf[i], ' ', strlen(marker));
        <font color=#009900>// Append counter &amp; error info:</font>
        ostrstream out(buf, sz, ios::ate);
        out &lt;&lt; <font color=#004488>"</font><font color=#004488>/</font><font color=#004488>/("</font> &lt;&lt; ++counter &lt;&lt; <font color=#004488>") "</font>
            &lt;&lt; <font color=#004488>"Chapter "</font> &lt;&lt; chapter
            &lt;&lt; <font color=#004488>" File: "</font> &lt;&lt; argv[1]
            &lt;&lt; <font color=#004488>" Line "</font> &lt;&lt; linecount &lt;&lt; endl
            &lt;&lt; ends;
          edited &lt;&lt; buf;
        errlines &lt;&lt; buf; <font color=#009900>// Append error file</font>
      } <font color=#0000ff>else</font>
        edited &lt;&lt; buf &lt;&lt; <font color=#004488>"\n"</font>; <font color=#009900>// Just copy</font>
    }
  } <font color=#009900>// Closes files</font>
  ofstream outfile(argv[1]); <font color=#009900>// Overwrites</font>
  assure(outfile, argv[1]);
  outfile &lt;&lt; edited.rdbuf();
  ofstream count(errnum); <font color=#009900>// Overwrites</font>
  assure(count, errnum);
  count &lt;&lt; counter; <font color=#009900>// Save new counter</font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The marker can be replaced with one of
your choice.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I160">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I161"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each file is read a line at a time, and
each line is searched for the marker appearing at the head of the line; the line
is modified and put into the error line list and into the <B>strstream</B>
<B>edited</B>. When the whole file is processed, it is closed (by reaching the
end of a scope), reopened as an output file and <B>edited</B> is poured into the
file. Also notice the counter is saved in an external file, so the next time
this program is invoked it continues to sequence the
counter.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I161">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I162"></a>
</FONT><A NAME="_Toc312373899"></A><A NAME="_Toc519041968"></A><BR></P></DIV>
<A NAME="Heading143"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
A simple datalogger<BR><A NAME="Index442"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example shows an approach you might
take to log data to disk and later retrieve it for processing. The example is
meant to produce a temperature-depth profile of the ocean at various points. To
hold the data, a class is
used:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I162">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I163"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:DataLogger.h</font>
<font color=#009900>// Datalogger record layout</font>
#ifndef DATALOG_H
#define DATALOG_H
#include &lt;ctime&gt;
#include &lt;iostream&gt;
<font color=#009900>// MS std namespace work-around</font>
#ifndef _MSC_VER
<font color=#0000ff>using</font> std::tm;
#endif

<font color=#0000ff>class</font> DataPoint {
  tm time; <font color=#009900>// Time &amp; day</font>
  <font color=#0000ff>enum</font> { bsz = 10 };
  <font color=#009900>// Ascii degrees (*) minutes (') seconds ("):</font>
  <font color=#0000ff>char</font> latitude[bsz], longitude[bsz];
  <font color=#0000ff>double</font> depth, temperature;
<font color=#0000ff>public</font>:
  tm getTime();
  <font color=#0000ff>void</font> setTime(tm t);
  <font color=#0000ff>const</font> <font color=#0000ff>char</font>* getLatitude();
  <font color=#0000ff>void</font> setLatitude(<font color=#0000ff>const</font> <font color=#0000ff>char</font>* l);
  <font color=#0000ff>const</font> <font color=#0000ff>char</font>* getLongitude();
  <font color=#0000ff>void</font> setLongitude(<font color=#0000ff>const</font> <font color=#0000ff>char</font>* l);
  <font color=#0000ff>double</font> getDepth();
  <font color=#0000ff>void</font> setDepth(<font color=#0000ff>double</font> d);
  <font color=#0000ff>double</font> getTemperature();
  <font color=#0000ff>void</font> setTemperature(<font color=#0000ff>double</font> t);
  <font color=#0000ff>void</font> print(std::ostream&amp; os);
};
#endif <font color=#009900>// DATALOG_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The access functions provide controlled
reading and writing to each of the data members. The <B>print(&#160;)</B>
function formats the <B>DataPoint</B> in a readable form onto an <B>ostream</B>
object (the argument to <B>print(&#160;)</B>). Here&#8217;s the definition
file:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I163">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I164"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:Datalog.cpp {O}</font>
<font color=#009900>// Datapoint member functions</font>
#include <font color=#004488>"DataLogger.h"</font>
#include &lt;iomanip&gt;
#include &lt;cstring&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

tm DataPoint::getTime() { <font color=#0000ff>return</font> time; }

<font color=#0000ff>void</font> DataPoint::setTime(tm t) { time = t; }

<font color=#0000ff>const</font> <font color=#0000ff>char</font>* DataPoint::getLatitude() {
  <font color=#0000ff>return</font> latitude;
}

<font color=#0000ff>void</font> DataPoint::setLatitude(<font color=#0000ff>const</font> <font color=#0000ff>char</font>* l) {
  latitude[bsz - 1] = 0;
  strncpy(latitude, l, bsz - 1);
}

<font color=#0000ff>const</font> <font color=#0000ff>char</font>* DataPoint::getLongitude() {
  <font color=#0000ff>return</font> longitude;
}

<font color=#0000ff>void</font> DataPoint::setLongitude(<font color=#0000ff>const</font> <font color=#0000ff>char</font>* l) {
  longitude[bsz - 1] = 0;
  strncpy(longitude, l, bsz - 1);
}

<font color=#0000ff>double</font> DataPoint::getDepth() { <font color=#0000ff>return</font> depth; }

<font color=#0000ff>void</font> DataPoint::setDepth(<font color=#0000ff>double</font> d) { depth = d; }

<font color=#0000ff>double</font> DataPoint::getTemperature() {
  <font color=#0000ff>return</font> temperature;
}

<font color=#0000ff>void</font> DataPoint::setTemperature(<font color=#0000ff>double</font> t) {
  temperature = t;
}

<font color=#0000ff>void</font> DataPoint::print(ostream&amp; os) {
  os.setf(ios::fixed, ios::floatfield);
  os.precision(4);
  os.fill('0'); <font color=#009900>// Pad on left with '0'</font>
  os &lt;&lt; setw(2) &lt;&lt; getTime().tm_mon &lt;&lt; '\\'
     &lt;&lt; setw(2) &lt;&lt; getTime().tm_mday &lt;&lt; '\\'
     &lt;&lt; setw(2) &lt;&lt; getTime().tm_year &lt;&lt; ' '
     &lt;&lt; setw(2) &lt;&lt; getTime().tm_hour &lt;&lt; ':'
     &lt;&lt; setw(2) &lt;&lt; getTime().tm_min &lt;&lt; ':'
     &lt;&lt; setw(2) &lt;&lt; getTime().tm_sec;
  os.fill(' '); <font color=#009900>// Pad on left with ' '</font>
  os &lt;&lt; <font color=#004488>" Lat:"</font> &lt;&lt; setw(9) &lt;&lt; getLatitude()
     &lt;&lt; <font color=#004488>", Long:"</font> &lt;&lt; setw(9) &lt;&lt; getLongitude()
     &lt;&lt; <font color=#004488>", depth:"</font> &lt;&lt; setw(9) &lt;&lt; getDepth()
     &lt;&lt; <font color=#004488>", temp:"</font> &lt;&lt; setw(9) &lt;&lt; getTemperature()
     &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>print(&#160;)</B>, the call to
<B>setf(&#160;)<A NAME="Index443"></A><A NAME="Index444"></A></B> causes the
floating-point output to be fixed-precision, and
<B>precision(&#160;)<A NAME="Index445"></A><A NAME="Index446"></A></B> sets the
number of decimal places to
four.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I164">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I165"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The default is to right-justify the data
within the field. The time information consists of two digits each for the
hours, minutes and seconds, so the width is set to two with
<B>setw(&#160;)<A NAME="Index447"></A><A NAME="Index448"></A></B> in each case.
(Remember that any changes to the field width affect only the next output
operation, so <B>setw(&#160;)</B> must be given for each output.) But first, to
put a zero in the left position if the value is less than 10, the fill character
<A NAME="Index449"></A>is set to &#8216;0&#8217;. Afterwards, it is set back to
a space.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I165">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I166"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The latitude and longitude are
zero-terminated character fields, which hold the information as degrees (here,
&#8216;*&#8217; denotes degrees), minutes (&#8216;), and seconds(&#8220;). You
can certainly devise a more efficient storage layout for latitude and longitude
if you desire.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I166">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I167"></a>
</FONT><BR></P></DIV>
<A NAME="Heading144"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Generating test data</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s a program that creates a
file of test data in binary form (using <B>write(&#160;)</B>) and a second file
in ASCII form using <B>DataPoint::print(&#160;)</B>. You can also print it out
to the screen but it&#8217;s easier to inspect in file
form.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I167">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I168"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:Datagen.cpp</font>
<font color=#009900>// Test data generator</font>
<font color=#009900>//{L} Datalog ../TestSuite/Test</font>
#include <font color=#004488>"DataLogger.h"</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;fstream&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  ofstream data(<font color=#004488>"data.txt"</font>);
  assure(data, <font color=#004488>"data.txt"</font>);
  ofstream bindata(<font color=#004488>"data.bin"</font>, ios::binary);
  assure(bindata, <font color=#004488>"data.bin"</font>);
  time_t timer;
  <font color=#009900>// Seed random number generator:</font>
  srand(time(&amp;timer)); 
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 100; i++) {
    DataPoint d;
    <font color=#009900>// Convert date/time to a structure:</font>
    d.setTime(*localtime(&amp;timer));
    timer += 55; <font color=#009900>// Reading each 55 seconds</font>
    d.setLatitude(<font color=#004488>"45*20'31\"</font>");
    d.setLongitude(<font color=#004488>"22*34'18\"</font>");
    <font color=#009900>// Zero to 199 meters:</font>
    <font color=#0000ff>double</font> newdepth  = rand() % 200;
    <font color=#0000ff>double</font> fraction = rand() % 100 + 1;
    newdepth += <font color=#0000ff>double</font>(1) / fraction;
    d.setDepth(newdepth);
    <font color=#0000ff>double</font> newtemp = 150 + rand()%200; <font color=#009900>// Kelvin</font>
    fraction = rand() % 100 + 1;
    newtemp += (<font color=#0000ff>double</font>)1 / fraction;
    d.setTemperature(newtemp);
    d.print(data);
    bindata.write((<font color=#0000ff>const</font> <font color=#0000ff>char</font>*)&amp;d, <font color=#0000ff>sizeof</font>(d));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The file <B>data.txt </B>is created in
the ordinary way as an ASCII file, but <B>data.bin </B>has the flag
<B>ios::binary</B> to tell the constructor to set it up as a binary
file.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I168">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I169"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Standard C library function
<B>time(&#160;)</B>, when called with a zero argument, returns the current time
as a <B>time_t</B> value, which is the number of seconds elapsed since 00:00:00
GMT, January 1 1970 (the dawning of the age of Aquarius?). The current time is
the most convenient way to seed the random number generator with the Standard C
library function <B>srand(&#160;)</B>, as is done
here.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I169">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I170"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Sometimes a more convenient way to store
the time is as a <B>tm</B> structure, which has all the elements of the time and
date broken up into their constituent parts as
follows:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I170">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I171"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>struct</font> tm {
  <font color=#0000ff>int</font> tm_sec; <font color=#009900>// 0-59 seconds</font>
  <font color=#0000ff>int</font> tm_min; <font color=#009900>// 0-59 minutes</font>
  <font color=#0000ff>int</font> tm_hour; <font color=#009900>// 0-23 hours</font>
  <font color=#0000ff>int</font> tm_mday; <font color=#009900>// Day of month</font>
  <font color=#0000ff>int</font> tm_mon; <font color=#009900>// 0-11 months</font>
  <font color=#0000ff>int</font> tm_year; <font color=#009900>// Calendar year</font>
  <font color=#0000ff>int</font> tm_wday; <font color=#009900>// Sunday == 0, etc.</font>
  <font color=#0000ff>int</font> tm_yday; <font color=#009900>// 0-365 day of year</font>
  <font color=#0000ff>int</font> tm_isdst; <font color=#009900>// Daylight savings?</font>
};</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To convert from the time in seconds to
the local time in the <B>tm</B> format, you use the Standard C library
<B>localtime(&#160;)<A NAME="Index450"></A><A NAME="Index451"></A></B> function,
which takes the number of seconds and returns a pointer to the resulting
<B>tm</B>. This <B>tm</B>, however, is a <B>static</B> structure inside the
<B>localtime(&#160;)</B> function, which is rewritten every time
<B>localtime(&#160;)</B> is called. To copy the contents into the <B>tm</B>
<B>struct</B> inside <B>DataPoint</B>, you might think you must copy each
element individually. However, all you must do is a structure assignment, and
the compiler will take care of the rest. This means the right-hand side must be
a structure, not a pointer, so the result of <B>localtime(&#160;)</B> is
dereferenced. The desired result is achieved
with
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I171">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I172"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>d.setTime(*localtime(&amp;timer));</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">After this, the <B>timer</B> is
incremented by 55 seconds to give an interesting interval between
readings.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I172">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I173"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The latitude and longitude used are fixed
values to indicate a set of readings at a single location. Both the depth and
the temperature are generated with the Standard C library
<B>rand(&#160;)<A NAME="Index452"></A></B> <A NAME="Index453"></A>function,
which returns a pseudorandom number between zero and the constant
RAND_MAX<A NAME="Index454"></A>. To put this in a desired range, use the modulus
operator <A NAME="Index455"></A><A NAME="Index456"></A><B>%</B> and the upper
end of the range. These numbers are integral; to add a fractional part, a second
call to <B>rand(&#160;)</B> is made, and the value is inverted after adding one
(to prevent divide-by-zero
errors).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I173">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I174"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In effect, the <B>data.bin </B>file is
being used as a container for the data in the program, even though the container
exists on disk and not in RAM. To send the data out to the disk in binary form,
<B>write(&#160;)</B> is used. The first argument is the starting address of the
source block &#8211; notice it must be cast to an <B>unsigned char*</B> because
that&#8217;s what the function expects. The second argument is the number of
bytes to write, which is the size of the <B>DataPoint</B> object. Because no
pointers are contained in <B>DataPoint</B>, there is no problem in writing the
object to disk. If the object is more sophisticated, you must implement a scheme
for <I>serialization</I> <A NAME="Index457"></A>. (Most vendor class libraries
have some sort of serialization structure built into
them.)
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I174">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I175"></a>
</FONT><BR></P></DIV>
<A NAME="Heading145"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Verifying &amp; viewing the data</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To check the validity of the data stored
in binary format, it is read from the disk and put in text form in
<B>data2.txt</B>, so that file can be compared to <B>data.txt </B>for
verification. In the following program, you can see how simple this data
recovery is. After the test file is created, the records are read at the command
of the user.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I175">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I176"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:Datascan.cpp</font>
<font color=#009900>//{L} Datalog ../TestSuite/Test</font>
<font color=#009900>// Verify and view logged data</font>
#include <font color=#004488>"DataLogger.h"</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;strstream&gt;
#include &lt;iomanip&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  ifstream bindata(<font color=#004488>"data.bin"</font>, ios::binary);
  assure(bindata, <font color=#004488>"data.bin"</font>);
  <font color=#009900>// Create comparison file to verify data.txt:</font>
  ofstream verify(<font color=#004488>"data2.txt"</font>);
  assure(verify, <font color=#004488>"data2.txt"</font>);
  DataPoint d;
  <font color=#0000ff>while</font>(bindata.read((<font color=#0000ff>char</font>*)&amp;d, <font color=#0000ff>sizeof</font> d))
    d.print(verify);
  bindata.clear(); <font color=#009900>// Reset state to "good"</font>
  <font color=#009900>// Left-align everything:</font>
  cout.setf(ios::left, ios::adjustfield);
  <font color=#009900>// Fixed precision of 4 decimal places:</font>
  cout.setf(ios::fixed, ios::floatfield);
  cout.precision(4);
  <font color=#0000ff>int</font> recnum = 0;
  <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
    bindata.seekg(recnum* <font color=#0000ff>sizeof</font> d, ios::beg);
    cout &lt;&lt; <font color=#004488>"record "</font> &lt;&lt; recnum &lt;&lt; endl;
    <font color=#0000ff>if</font>(bindata.read((<font color=#0000ff>char</font>*)&amp;d, <font color=#0000ff>sizeof</font> d)) {
      cout &lt;&lt; asctime(&amp;(d.getTime()));
      cout &lt;&lt; setw(11) &lt;&lt; <font color=#004488>"Latitude"</font>
           &lt;&lt; setw(11) &lt;&lt; <font color=#004488>"Longitude"</font>
           &lt;&lt; setw(10) &lt;&lt; <font color=#004488>"Depth"</font>
           &lt;&lt; setw(12) &lt;&lt; <font color=#004488>"Temperature"</font>
           &lt;&lt; endl;
      <font color=#009900>// Put a line after the description:</font>
      cout &lt;&lt; setfill('-') &lt;&lt; setw(43) &lt;&lt; '-'
           &lt;&lt; setfill(' ') &lt;&lt; endl;
      cout &lt;&lt; setw(11) &lt;&lt; d.getLatitude()
           &lt;&lt; setw(11) &lt;&lt; d.getLongitude()
           &lt;&lt; setw(10) &lt;&lt; d.getDepth()
           &lt;&lt; setw(12) &lt;&lt; d.getTemperature()
           &lt;&lt; endl;
    } <font color=#0000ff>else</font> {
      cout &lt;&lt; <font color=#004488>"invalid record number"</font> &lt;&lt; endl;
      exit(0);
    }
    recnum++;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>ifstream</B> <B>bindata</B> is
created from DATA.BIN as a binary file, with the <B>ios::nocreate</B> flag on to
cause the <B>assert(&#160;)</B> to fail if the file doesn&#8217;t exist. The
<B>read(&#160;)<A NAME="Index458"></A><A NAME="Index459"></A></B> statement
reads a single record and places it directly into the <B>DataPoint d</B>.
(Again, if <B>DataPoint</B> contained pointers this would result in meaningless
pointer values.) This <B>read(&#160;)</B> action will set <B>bindata</B>&#8217;s
<B>failbit</B> <A NAME="Index460"></A><A NAME="Index461"></A>when the end of the
file is reached, which will cause the <B>while</B> statement to fail. At this
point, however, you can&#8217;t move the get
pointer<A NAME="Index462"></A><A NAME="Index463"></A> back and read more records
because the state of the stream won&#8217;t allow further reads. So the
<B>clear(&#160;)<A NAME="Index464"></A><A NAME="Index465"></A></B> function is
called to reset the
<B>failbit</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I176">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I177"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once the record is read in from disk, you
can do anything you want with it, such as perform calculations or make graphs.
Here, it is displayed to further exercise your knowledge of iostream
formatting.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I177">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I178"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The rest of the program displays a record
number (represented by <B>recnum</B>) selected by the user. As before, the
precision is fixed at four decimal places, but this time everything is left
justified.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I178">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I179"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The formatting of this output looks
different from before:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I179">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I180"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>record 0
Tue Nov 16 18:15:49 1993
Latitude   Longitude  Depth     Temperature
-------------------------------------------
45*20'31<font color=#004488>"  22*34'18"</font>  186.0172  269.0167    </PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To make sure the labels and the data
columns line up, the labels are put in the same width fields as the columns,
using <B>setw(&#160;)</B>. The line in between is generated by setting the fill
character to &#8216;-&#8217;, the width to the desired line width, and
outputting a single
&#8216;-&#8217;.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I180">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I181"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If the <B>read(&#160;)</B> fails,
you&#8217;ll end up in the <B>else</B> part, which tells the user the record
number was invalid. Then, because the <B>failbit</B> was set, it must be reset
with a call to <B>clear(&#160;)</B> so the next <B>read(&#160;)</B> is
successful (assuming it&#8217;s in the right
range).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I181">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I182"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, you can also open the binary
data file for writing as well as reading. This way you can retrieve the records,
modify them, and write them back to the same location, thus creating a flat-file
database management system. In my very first programming job, I also had to
create a flat-file DBMS &#8211; but using BASIC on an Apple II. It took months,
while this took minutes. Of course, it might make more sense to use a packaged
DBMS now, but with C++ and iostreams you can still do all the low-level
operations that are necessary in a
lab.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I182">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I183"></a>
</FONT><A NAME="_Toc305628672"></A><A NAME="_Toc312373900"></A><A NAME="_Toc519041969"></A><BR></P></DIV>
<A NAME="Heading146"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Counting editor</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Often you have some editing task where
you must go through and sequentially number something, but all the other text is
duplicated. I encountered this problem when pasting digital photos into a Web
page &#8211; I got the formatting just right, then duplicated it, then had the
problem of incrementing the photo number for each one. So I replaced the photo
number with XXX, duplicated that, and wrote the following program to find and
replace the &#8220;XXX&#8221; with an incremented count. Notice the formatting,
so the value will be &#8220;001,&#8221; &#8220;002,&#8221;
etc.:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I183">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I184"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:NumberPhotos.cpp</font>
<font color=#009900>// Find the marker "XXX" and replace it with an</font>
<font color=#009900>// incrementing number whereever it appears. Used</font>
<font color=#009900>// to help format a web page with photos in it</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  requireArgs(argc, 2);
  ifstream in(argv[1]);
  assure(in, argv[1]);
  ofstream out(argv[2]);
  assure(out, argv[2]);
  string line;
  <font color=#0000ff>int</font> counter = 1;
  <font color=#0000ff>while</font>(getline(in, line)) {
    <font color=#0000ff>int</font> xxx = line.find(<font color=#004488>"XXX"</font>);
    <font color=#0000ff>if</font>(xxx != string::npos) {
      ostringstream cntr;
      cntr &lt;&lt; setfill('0') &lt;&lt; setw(3) &lt;&lt; counter++;
      line.replace(xxx, 3, cntr.str());
    }
    out &lt;&lt; line &lt;&lt; endl;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><A NAME="_Toc519041970"></A><BR></P></DIV>
<A NAME="Heading147"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Breaking up big files</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This program was created to break up big
files into smaller ones, in particular so they could be more easily downloaded
from an Internet server (since hangups sometimes occur, this allows someone to
download a file a piece at a time and then re-assemble it at the client end).
You&#8217;ll note that the program also creates a reassembly batch file for DOS
(where it is messier), whereas under Linux/Unix you simply say something like
&#8220;<B>cat *piece* &gt;
destination.file</B>&#8221;.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I184">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I185"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This program reads the entire file into
memory, which of course relies on having a 32-bit operating system with virtual
memory for big files. It then pieces it out in chunks to the smaller files,
generating the names as it goes. Of course, you can come up with a possibly more
reasonable strategy that reads a chunk, creates a file, reads another chunk,
etc.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I185">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I186"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that this program can be run on the
server, so you only have to download the big file once and then break it up once
it&#8217;s on the
server.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I186">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I187"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C05:Breakup.cpp</font>
<font color=#009900>// Breaks a file up into smaller files for </font>
<font color=#009900>// easier downloads</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;strstream&gt;
#include &lt;string&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  requireArgs(argc, 1);
  ifstream in(argv[1], ios::binary);
  assure(in, argv[1]);
  in.seekg(0, ios::end); <font color=#009900>// End of file</font>
  <font color=#0000ff>long</font> fileSize = in.tellg(); <font color=#009900>// Size of file</font>
  cout &lt;&lt; <font color=#004488>"file size = "</font> &lt;&lt; fileSize &lt;&lt; endl;
  in.seekg(0, ios::beg); <font color=#009900>// Start of file</font>
  <font color=#0000ff>char</font>* fbuf = <font color=#0000ff>new</font> <font color=#0000ff>char</font>[fileSize];
  require(fbuf != 0);
  in.read(fbuf, fileSize);
  in.close();
  string infile(argv[1]);
  <font color=#0000ff>int</font> dot = infile.find('.');
  <font color=#0000ff>while</font>(dot != string::npos) {
    infile.replace(dot, 1, <font color=#004488>"-"</font>);
    dot = infile.find('.');
  }
  string batchName(
    <font color=#004488>"DOSAssemble"</font> + infile + <font color=#004488>".bat"</font>);
  ofstream batchFile(batchName.c_str());
  batchFile &lt;&lt; <font color=#004488>"copy </font><font color=#004488>/b "</font>;
  <font color=#0000ff>int</font> filecount = 0;
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> sbufsz = 128;
  <font color=#0000ff>char</font> sbuf[sbufsz];
  <font color=#0000ff>const</font> <font color=#0000ff>long</font> pieceSize = 1000L * 100L;
  <font color=#0000ff>long</font> byteCounter = 0;
  <font color=#0000ff>while</font>(byteCounter &lt; fileSize) {
    ostrstream name(sbuf, sbufsz);
    name &lt;&lt; argv[1] &lt;&lt; <font color=#004488>"-part"</font> &lt;&lt; setfill('0') 
      &lt;&lt; setw(2) &lt;&lt; filecount++ &lt;&lt; ends;
    cout &lt;&lt; <font color=#004488>"creating "</font> &lt;&lt; sbuf &lt;&lt; endl;
    <font color=#0000ff>if</font>(filecount &gt; 1) 
      batchFile &lt;&lt; <font color=#004488>"+"</font>;
    batchFile &lt;&lt; sbuf;
    ofstream out(sbuf, ios::out | ios::binary);
    assure(out, sbuf);
    <font color=#0000ff>long</font> byteq;
    <font color=#0000ff>if</font>(byteCounter + pieceSize &lt; fileSize)
      byteq = pieceSize;
    <font color=#0000ff>else</font>
      byteq = fileSize - byteCounter;
    out.write(fbuf + byteCounter, byteq);
    cout &lt;&lt; <font color=#004488>"wrote "</font> &lt;&lt; byteq &lt;&lt; <font color=#004488>" bytes, "</font>;
    byteCounter += byteq;
    out.close();
    cout &lt;&lt; <font color=#004488>"ByteCounter = "</font> &lt;&lt; byteCounter 
      &lt;&lt; <font color=#004488>", fileSize = "</font> &lt;&lt; fileSize &lt;&lt; endl;
  }
  batchFile &lt;&lt; <font color=#004488>" "</font> &lt;&lt; argv[1] &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I187">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I188"></a>
</FONT><A NAME="_Toc519041971"></A><BR></P></DIV>
<A NAME="Heading148"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Locales<A NAME="_Toc519041972"></A></H2></FONT>
<A NAME="Heading149"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Summary</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This chapter has given you a fairly
thorough introduction to the iostream class library. In all likelihood, it is
all you need to create programs using iostreams. (In later chapters you&#8217;ll
see simple examples of adding iostream functionality to your own classes.)
However, you should be aware that there are some additional features in
iostreams that are not used often, but which you can discover by looking at the
iostream header files and by reading your compiler&#8217;s documentation on
iostreams.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I188">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I189"></a>
</FONT><A NAME="_Toc312373901"></A><A NAME="_Toc519041973"></A><BR></P></DIV>
<A NAME="Heading150"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Exercises</H2></FONT>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Open a file by creating an
ifstream object called in. Make an ostrstream object called os, and read the
entire contents into the ostrstream using the rdbuf(&#160;) member function. Get
the address of os&#8217;s char* with the str(&#160;) function, and capitalize
every character in the file using the Standard C toupper(&#160;) macro. Write
the result out to a new file, and delete the memory allocated by
os.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I189">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I190"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
a program that opens a file (the first argument on the command line) and
searches it for any one of a set of words (the remaining arguments on the
command line). Read the input a line at a time, and print out the lines (with
line numbers) that
match.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I190">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I191"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Write
a program that adds a copyright notice to the beginning of all source-code
files. This is a small modification to exercise
1.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I191">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER5_I192"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Use
your favorite text-searching program (grep, for example) to output the names
(only) of all the files that contain a particular pattern. Redirect the output
into a file. Write a program that uses the contents of that file to generate a
batch file that invokes your editor on each of the files found by the search
program.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER5_I192">Comment</a>&nbsp;]

</FONT></OL>
<HR><DIV ALIGN="LEFT"><P><A NAME="fn10" HREF="#fnB10">[10]</A><FONT FACE="Georgia" SIZE=2>
The implementation and test files for FULLWRAP are available in the freely
distributed source code for this book. See preface for details.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn11" HREF="#fnB11">[11]</A><FONT FACE="Georgia" SIZE=2>
Newer implementations of iostreams will still support this style of handling
errors, but in some cases will also throw exceptions.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn12" HREF="#fnB12">[12]</A><FONT FACE="Georgia" SIZE=2>
These only appear in the revised library; you won&#8217;t find them in older
implementations of iostreams.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn13" HREF="#fnB13">[13]</A><FONT FACE="Georgia" SIZE=2>
Before putting <B>nl</B> into a header file, you should make it an <B>inline</B>
function (see Chapter 7).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn14" HREF="#fnB14">[14]</A><FONT FACE="Georgia" SIZE=2>
In a private conversation.</FONT><BR></P></DIV>

<DIV ALIGN="CENTER">
    <FONT FACE="Verdana, Tahoma, Arial, Helvetica, Sans" size = "-1">
     [ <a href="Chap04.htm">Previous Chapter</a> ] 
    
    [ <a href="SimpCont.htm">Short TOC</a> ] 
    [ <a href="Contents.htm">Table of Contents</a> ] 
  
        [ <a href="DocIdx.htm">Index</a> ]
        
     [ <a href="Chap06.htm">Next Chapter</a> ] 
    </FONT>
    <BR>
 Last Update:08/19/2001</P></DIV>

</BODY>

</HTML>

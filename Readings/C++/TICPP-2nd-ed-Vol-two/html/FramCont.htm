<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:C:\TEMP\TicV2\html\TicV2.rtf
Application Directory:C:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:08/19/2001
Translation Time:14:24:49
Translation Platform:Win32
Number of Output files:19
This File:C:\TEMP\TicV2\html\FramCont.htm
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html">
<TITLE>Thinking in C++, 2nd ed. Volume 2 Revision 4.0 - Contents</TITLE><BASE  TARGET="RightFrame">

</HEAD>

<BODY  BGCOLOR="#FFFFFF"><H1>Thinking in C++, 2nd ed. Volume 2 Revision 4.0 - Contents </H1></FONT>
<H2><A HREF="FrontMtr.htm">Thinking in C++, 2nd ed. Volume 2 Revision 4.0 - Title Page </A></H2></FONT>
<UL>
<A HREF="Preface.htm">Preface</A><BR>
<UL>
<A HREF="Preface.htm#Heading2">What&#8217;s new in the second edition</A><BR>
<UL>
<A HREF="Preface.htm#Heading3">What&#8217;s in Volume 2 of this book</A><BR>
<A HREF="Preface.htm#Heading4">How to get Volume 2</A><BR>
</UL>
<A HREF="Preface.htm#Heading5">Prerequisites</A><BR>
<A HREF="Preface.htm#Heading6">Learning C++</A><BR>
<A HREF="Preface.htm#Heading7">Goals</A><BR>
<A HREF="Preface.htm#Heading8">Chapters</A><BR>
<A HREF="Preface.htm#Heading9">Exercises</A><BR>
<UL>
<A HREF="Preface.htm#Heading10">Exercise solutions</A><BR>
</UL>
<A HREF="Preface.htm#Heading11">Source code</A><BR>
<A HREF="Preface.htm#Heading12">Language standards</A><BR>
<UL>
<A HREF="Preface.htm#Heading13">Language support</A><BR>
</UL>
<A HREF="Preface.htm#Heading14">Seminars, CD Roms &amp; consulting</A><BR>
<A HREF="Preface.htm#Heading15">Errors</A><BR>
<A HREF="Preface.htm#Heading16">Acknowledgements</A><BR>
</UL>
<A HREF="Part1.htm">Part 1: Building Stable Systems</A><BR>
<A HREF="Chap01.htm">1: Exception handling</A><BR>
<UL>
<A HREF="Chap01.htm#Heading19">Error handling in C</A><BR>
<A HREF="Chap01.htm#Heading20">Throwing an exception</A><BR>
<A HREF="Chap01.htm#Heading21">Catching an exception</A><BR>
<UL>
<A HREF="Chap01.htm#Heading22">The try block</A><BR>
<A HREF="Chap01.htm#Heading23">Exception handlers</A><BR>
<UL>
<A HREF="Chap01.htm#Heading24">Termination vs. resumption</A><BR>
</UL>
<A HREF="Chap01.htm#Heading25">The exception specification</A><BR>
<UL>
<A HREF="Chap01.htm#Heading26">unexpected(&#160;)</A><BR>
<A HREF="Chap01.htm#Heading27">set_unexpected(&#160;)</A><BR>
</UL>
<A HREF="Chap01.htm#Heading28">Better exception specifications?</A><BR>
<A HREF="Chap01.htm#Heading29">Catching any exception</A><BR>
<A HREF="Chap01.htm#Heading30">Rethrowing an exception</A><BR>
<A HREF="Chap01.htm#Heading31">Uncaught exceptions</A><BR>
<UL>
<A HREF="Chap01.htm#Heading32">terminate(&#160;)</A><BR>
<A HREF="Chap01.htm#Heading33">set_terminate(&#160;)</A><BR>
</UL>
<A HREF="Chap01.htm#Heading34">Function-level try blocks</A><BR>
</UL>
<A HREF="Chap01.htm#Heading35">Cleaning up</A><BR>
<A HREF="Chap01.htm#Heading36">Constructors</A><BR>
<UL>
<A HREF="Chap01.htm#Heading37">Making everything an object</A><BR>
</UL>
<A HREF="Chap01.htm#Heading38">Exception matching</A><BR>
<A HREF="Chap01.htm#Heading39">Standard exceptions</A><BR>
<A HREF="Chap01.htm#Heading40">Programming with exceptions</A><BR>
<UL>
<A HREF="Chap01.htm#Heading41">When to avoid exceptions</A><BR>
<UL>
<A HREF="Chap01.htm#Heading42">Not for asynchronous events</A><BR>
<A HREF="Chap01.htm#Heading43">Not for ordinary error conditions</A><BR>
<A HREF="Chap01.htm#Heading44">Not for flow-of-control</A><BR>
<A HREF="Chap01.htm#Heading45">You&#8217;re not forced to use exceptions</A><BR>
<A HREF="Chap01.htm#Heading46">New exceptions, old code</A><BR>
</UL>
<A HREF="Chap01.htm#Heading47">Typical uses of exceptions</A><BR>
<UL>
<A HREF="Chap01.htm#Heading48">Always use exception specifications</A><BR>
<A HREF="Chap01.htm#Heading49">Start with standard exceptions</A><BR>
<A HREF="Chap01.htm#Heading50">Nest your own exceptions</A><BR>
<A HREF="Chap01.htm#Heading51">Use exception hierarchies</A><BR>
<A HREF="Chap01.htm#Heading52">Multiple inheritance</A><BR>
<A HREF="Chap01.htm#Heading53">Catch by reference, not by value</A><BR>
<A HREF="Chap01.htm#Heading54">Throw exceptions in constructors</A><BR>
<A HREF="Chap01.htm#Heading55">Don&#8217;t cause exceptions in destructors</A><BR>
<A HREF="Chap01.htm#Heading56">Avoid naked pointers</A><BR>
</UL>
</UL>
<A HREF="Chap01.htm#Heading57">Overhead</A><BR>
<A HREF="Chap01.htm#Heading58">Summary</A><BR>
<A HREF="Chap01.htm#Heading59">Exercises</A><BR>
</UL>
<A HREF="Chap02.htm">2: Defensive Programming</A><BR>
<UL>
<A HREF="Chap02.htm#Heading61">Assertions</A><BR>
<A HREF="Chap02.htm#Heading62">Design by Contract</A><BR>
<A HREF="Chap02.htm#Heading63">The Simplest Automated Unit Test Framework that could Possibly Work</A><BR>
<UL>
<A HREF="Chap02.htm#Heading64">Automated Testing</A><BR>
<A HREF="Chap02.htm#Heading65">The TestSuite Framework</A><BR>
<A HREF="Chap02.htm#Heading66">Test Suites</A><BR>
<A HREF="Chap02.htm#Heading67">The Test Framework Code</A><BR>
</UL>
<A HREF="Chap02.htm#Heading68">Exercises</A><BR>
</UL>
<A HREF="Chap03.htm">3: Debugging Techniques</A><BR>
<UL>
<A HREF="Chap03.htm#Heading70">Shared objects &amp; reference counting</A><BR>
<A HREF="Chap03.htm#Heading71">Reference-counted class hierarchies</A><BR>
<A HREF="Chap03.htm#Heading72">Debugging</A><BR>
<UL>
<A HREF="Chap03.htm#Heading73">Trace macros</A><BR>
<A HREF="Chap03.htm#Heading74">Trace file</A><BR>
<A HREF="Chap03.htm#Heading75">Abstract base class for debugging</A><BR>
</UL>
<A HREF="Chap03.htm#Heading76">Finding memory leaks</A><BR>
<UL>
<A HREF="Chap03.htm#Heading77">Tracking new/delete &amp; malloc/free</A><BR>
</UL>
<A HREF="Chap03.htm#Heading78">The canonical object &amp; singly-rooted hierarchies</A><BR>
<UL>
<A HREF="Chap03.htm#Heading79">An extended canonical form</A><BR>
</UL>
<A HREF="Chap03.htm#Heading80">Exercises</A><BR>
</UL>
<A HREF="Part2.htm">Part 2: The Standard C++ Library</A><BR>
<UL>
<A HREF="Part2.htm#Heading82">Library overview</A><BR>
</UL>
<A HREF="Chap04.htm">4: Strings in Depth</A><BR>
<UL>
<A HREF="Chap04.htm#Heading84">What&#8217;s in a string</A><BR>
<UL>
<A HREF="Chap04.htm#Heading85">Creating and initializing C++ strings</A><BR>
<UL>
<A HREF="Chap04.htm#Heading86">Initialization limitations</A><BR>
</UL>
</UL>
<A HREF="Chap04.htm#Heading87">Operating on strings</A><BR>
<UL>
<A HREF="Chap04.htm#Heading88">Appending, inserting and concatenating strings</A><BR>
<A HREF="Chap04.htm#Heading89">Replacing string characters</A><BR>
<UL>
<A HREF="Chap04.htm#Heading90">Simple character replacement using the STL replace(&#160;) algorithm</A><BR>
</UL>
<A HREF="Chap04.htm#Heading91">Concatenation using non-member overloaded operators</A><BR>
</UL>
<A HREF="Chap04.htm#Heading92">Searching in strings</A><BR>
<UL>
<A HREF="Chap04.htm#Heading93">Finding in reverse</A><BR>
<A HREF="Chap04.htm#Heading94">Finding first/last of a set</A><BR>
<A HREF="Chap04.htm#Heading95">Removing characters from strings</A><BR>
<UL>
<A HREF="Chap04.htm#Heading96">Stripping HTML tags</A><BR>
</UL>
<A HREF="Chap04.htm#Heading97">Comparing strings </A><BR>
<UL>
<A HREF="Chap04.htm#Heading98">Indexing with [ ] vs. at(&#160;)</A><BR>
</UL>
<A HREF="Chap04.htm#Heading99">Using iterators</A><BR>
<UL>
<A HREF="Chap04.htm#Heading100">Iterating in reverse</A><BR>
</UL>
<A HREF="Chap04.htm#Heading101">Strings and character traits</A><BR>
</UL>
<A HREF="Chap04.htm#Heading102">A string application</A><BR>
<A HREF="Chap04.htm#Heading103">Summary</A><BR>
<A HREF="Chap04.htm#Heading104">Exercises</A><BR>
</UL>
<A HREF="Chap05.htm">5: Iostreams</A><BR>
<UL>
<A HREF="Chap05.htm#Heading106">Why iostreams?</A><BR>
<UL>
<A HREF="Chap05.htm#Heading107">True wrapping</A><BR>
</UL>
<A HREF="Chap05.htm#Heading108">Iostreams to the rescue</A><BR>
<UL>
<A HREF="Chap05.htm#Heading109">Sneak preview of operator overloading</A><BR>
<A HREF="Chap05.htm#Heading110">Inserters and extractors</A><BR>
<UL>
<A HREF="Chap05.htm#Heading111">Manipulators</A><BR>
</UL>
<A HREF="Chap05.htm#Heading112">Common usage</A><BR>
<A HREF="Chap05.htm#Heading113">Line-oriented input</A><BR>
<UL>
<A HREF="Chap05.htm#Heading114">Overloaded versions of get(&#160;)</A><BR>
<A HREF="Chap05.htm#Heading115">Reading raw bytes</A><BR>
<A HREF="Chap05.htm#Heading116">Error handling</A><BR>
</UL>
</UL>
<A HREF="Chap05.htm#Heading117">File iostreams</A><BR>
<UL>
<A HREF="Chap05.htm#Heading118">Open modes</A><BR>
</UL>
<A HREF="Chap05.htm#Heading119">Iostream buffering</A><BR>
<UL>
<A HREF="Chap05.htm#Heading120">Using get(&#160;) with a streambuf</A><BR>
</UL>
<A HREF="Chap05.htm#Heading121">Seeking in iostreams</A><BR>
<UL>
<A HREF="Chap05.htm#Heading122">Creating read/write files</A><BR>
</UL>
<A HREF="Chap05.htm#Heading123">stringstreams</A><BR>
<A HREF="Chap05.htm#Heading124">strstreams</A><BR>
<UL>
<A HREF="Chap05.htm#Heading125">User-allocated storage</A><BR>
<UL>
<A HREF="Chap05.htm#Heading126">Output strstreams</A><BR>
</UL>
<A HREF="Chap05.htm#Heading127">Automatic storage allocation</A><BR>
<UL>
<A HREF="Chap05.htm#Heading128">Proving movement</A><BR>
<A HREF="Chap05.htm#Heading129">A better way</A><BR>
</UL>
</UL>
<A HREF="Chap05.htm#Heading130">Output stream formatting</A><BR>
<UL>
<A HREF="Chap05.htm#Heading131">Internal formatting data</A><BR>
<UL>
<A HREF="Chap05.htm#Heading132">Format fields</A><BR>
<A HREF="Chap05.htm#Heading133">Width, fill and precision</A><BR>
</UL>
<A HREF="Chap05.htm#Heading134">An exhaustive example</A><BR>
</UL>
<A HREF="Chap05.htm#Heading135">Formatting manipulators</A><BR>
<UL>
<A HREF="Chap05.htm#Heading136">Manipulators with arguments</A><BR>
</UL>
<A HREF="Chap05.htm#Heading137">Creating manipulators</A><BR>
<UL>
<A HREF="Chap05.htm#Heading138">Effectors</A><BR>
</UL>
<A HREF="Chap05.htm#Heading139">Iostream examples</A><BR>
<UL>
<A HREF="Chap05.htm#Heading140">Code generation</A><BR>
<UL>
<A HREF="Chap05.htm#Heading141">Maintaining class library source</A><BR>
<A HREF="Chap05.htm#Heading142">Detecting compiler errors</A><BR>
</UL>
<A HREF="Chap05.htm#Heading143">A simple datalogger</A><BR>
<UL>
<A HREF="Chap05.htm#Heading144">Generating test data</A><BR>
<A HREF="Chap05.htm#Heading145">Verifying &amp; viewing the data</A><BR>
</UL>
<A HREF="Chap05.htm#Heading146">Counting editor</A><BR>
<A HREF="Chap05.htm#Heading147">Breaking up big files</A><BR>
</UL>
<A HREF="Chap05.htm#Heading148">Locales</A><BR>
<A HREF="Chap05.htm#Heading149">Summary</A><BR>
<A HREF="Chap05.htm#Heading150">Exercises</A><BR>
</UL>
<A HREF="Chap06.htm">6: Templates in depth</A><BR>
<UL>
<A HREF="Chap06.htm#Heading152">Nontype template arguments</A><BR>
<A HREF="Chap06.htm#Heading153">Default template arguments</A><BR>
<A HREF="Chap06.htm#Heading154">The typename keyword</A><BR>
<UL>
<A HREF="Chap06.htm#Heading155">Typedefing a typename</A><BR>
<A HREF="Chap06.htm#Heading156">Using typename instead of class</A><BR>
</UL>
<A HREF="Chap06.htm#Heading157">Function templates</A><BR>
<UL>
<A HREF="Chap06.htm#Heading158">A string conversion system</A><BR>
<A HREF="Chap06.htm#Heading159">A memory allocation system</A><BR>
</UL>
<A HREF="Chap06.htm#Heading160">Type induction in function templates </A><BR>
<A HREF="Chap06.htm#Heading161">Taking the address of a generated function template </A><BR>
<A HREF="Chap06.htm#Heading162">Local classes in templates</A><BR>
<A HREF="Chap06.htm#Heading163">Applying a function to an STL sequence</A><BR>
<A HREF="Chap06.htm#Heading164">Expression templates</A><BR>
<A HREF="Chap06.htm#Heading165">Template-templates</A><BR>
<A HREF="Chap06.htm#Heading166">Member function templates</A><BR>
<UL>
<A HREF="Chap06.htm#Heading167">Why virtual member template functions are disallowed</A><BR>
<A HREF="Chap06.htm#Heading168">Nested template classes</A><BR>
</UL>
<A HREF="Chap06.htm#Heading169">Template specializations</A><BR>
<UL>
<A HREF="Chap06.htm#Heading170">Full specialization</A><BR>
<A HREF="Chap06.htm#Heading171">Partial Specialization</A><BR>
<A HREF="Chap06.htm#Heading172">A practical example</A><BR>
<UL>
<A HREF="Chap06.htm#Heading173">Pointer specialization</A><BR>
<A HREF="Chap06.htm#Heading174">Partial ordering of function templates</A><BR>
</UL>
<A HREF="Chap06.htm#Heading175">Design &amp; efficiency</A><BR>
<A HREF="Chap06.htm#Heading176">Preventing template bloat</A><BR>
</UL>
<A HREF="Chap06.htm#Heading177">Explicit instantiation</A><BR>
<UL>
<A HREF="Chap06.htm#Heading178">Explicit specification of template functions</A><BR>
</UL>
<A HREF="Chap06.htm#Heading179">Controlling template instantiation</A><BR>
<UL>
<A HREF="Chap06.htm#Heading180">The inclusion vs. separation models</A><BR>
<A HREF="Chap06.htm#Heading181">The export keyword</A><BR>
</UL>
<A HREF="Chap06.htm#Heading182">Template programming idioms</A><BR>
<UL>
<A HREF="Chap06.htm#Heading183">The &#8220;curiously-recurring template&#8221;</A><BR>
<A HREF="Chap06.htm#Heading184">Traits</A><BR>
<A HREF="Chap06.htm#Heading185">Implementing Locales</A><BR>
</UL>
<A HREF="Chap06.htm#Heading186">Summary</A><BR>
<A HREF="Chap06.htm#Heading187">Exercises</A><BR>
</UL>
<A HREF="Chap07.htm">7: STL Containers &amp; Iterators</A><BR>
<UL>
<A HREF="Chap07.htm#Heading189">Containers and iterators</A><BR>
<UL>
<A HREF="Chap07.htm#Heading190">STL reference documentation</A><BR>
</UL>
<A HREF="Chap07.htm#Heading191">The Standard Template Library </A><BR>
<A HREF="Chap07.htm#Heading192">The basic concepts</A><BR>
<A HREF="Chap07.htm#Heading193">Containers of strings</A><BR>
<A HREF="Chap07.htm#Heading194">Inheriting from STL containers</A><BR>
<A HREF="Chap07.htm#Heading195">A plethora of iterators</A><BR>
<UL>
<A HREF="Chap07.htm#Heading196">Iterators in reversible containers</A><BR>
<A HREF="Chap07.htm#Heading197">Iterator categories</A><BR>
<UL>
<A HREF="Chap07.htm#Heading198">Input: read-only, one pass</A><BR>
<A HREF="Chap07.htm#Heading199">Output: write-only, one pass</A><BR>
<A HREF="Chap07.htm#Heading200">Forward: multiple read/write</A><BR>
<A HREF="Chap07.htm#Heading201">Bidirectional: operator--</A><BR>
<A HREF="Chap07.htm#Heading202">Random-access: like a pointer</A><BR>
<A HREF="Chap07.htm#Heading203">Is this really important?</A><BR>
</UL>
<A HREF="Chap07.htm#Heading204">Predefined iterators</A><BR>
<UL>
<A HREF="Chap07.htm#Heading205">IO stream iterators</A><BR>
<A HREF="Chap07.htm#Heading206">Manipulating raw storage</A><BR>
</UL>
</UL>
<A HREF="Chap07.htm#Heading207">Basic sequences:  vector, list &amp; deque</A><BR>
<UL>
<A HREF="Chap07.htm#Heading208">Basic sequence operations</A><BR>
</UL>
<A HREF="Chap07.htm#Heading209">vector</A><BR>
<UL>
<A HREF="Chap07.htm#Heading210">Cost of overflowing allocated storage</A><BR>
<A HREF="Chap07.htm#Heading211">Inserting and erasing elements</A><BR>
</UL>
<A HREF="Chap07.htm#Heading212">deque</A><BR>
<UL>
<A HREF="Chap07.htm#Heading213">Converting between sequences</A><BR>
<A HREF="Chap07.htm#Heading214">Cost of overflowing allocated storage</A><BR>
<A HREF="Chap07.htm#Heading215">Checked random-access</A><BR>
</UL>
<A HREF="Chap07.htm#Heading216">list</A><BR>
<UL>
<A HREF="Chap07.htm#Heading217">Special list operations</A><BR>
<UL>
<A HREF="Chap07.htm#Heading218">list vs. set</A><BR>
</UL>
<A HREF="Chap07.htm#Heading219">Swapping all basic sequences</A><BR>
<A HREF="Chap07.htm#Heading220">Robustness of lists</A><BR>
</UL>
<A HREF="Chap07.htm#Heading221">Performance comparison</A><BR>
<A HREF="Chap07.htm#Heading222">set</A><BR>
<UL>
<A HREF="Chap07.htm#Heading223">Eliminating strtok(&#160;)</A><BR>
<A HREF="Chap07.htm#Heading224">StreamTokenizer:  a more flexible solution</A><BR>
<A HREF="Chap07.htm#Heading225">A completely reusable tokenizer</A><BR>
</UL>
<A HREF="Chap07.htm#Heading226">stack</A><BR>
<A HREF="Chap07.htm#Heading227">queue</A><BR>
<A HREF="Chap07.htm#Heading228">Priority queues</A><BR>
<A HREF="Chap07.htm#Heading229">Holding bits</A><BR>
<UL>
<A HREF="Chap07.htm#Heading230">bitset&lt;n&gt;</A><BR>
<A HREF="Chap07.htm#Heading231">vector&lt;bool&gt;</A><BR>
</UL>
<A HREF="Chap07.htm#Heading232">Associative containers</A><BR>
<UL>
<A HREF="Chap07.htm#Heading233">Generators and fillers for associative containers</A><BR>
<A HREF="Chap07.htm#Heading234">The magic of maps</A><BR>
<UL>
<A HREF="Chap07.htm#Heading235">A command-line argument tool</A><BR>
</UL>
<A HREF="Chap07.htm#Heading236">Multimaps and duplicate keys</A><BR>
<A HREF="Chap07.htm#Heading237">Multisets</A><BR>
</UL>
<A HREF="Chap07.htm#Heading238">Combining STL containers</A><BR>
<A HREF="Chap07.htm#Heading239">Cleaning up  containers of pointers</A><BR>
<A HREF="Chap07.htm#Heading240">Creating your own containers</A><BR>
<A HREF="Chap07.htm#Heading241">Freely-available  STL extensions</A><BR>
<A HREF="Chap07.htm#Heading242">Non-STL containers</A><BR>
<UL>
<A HREF="Chap07.htm#Heading243">Bitset</A><BR>
<A HREF="Chap07.htm#Heading244">Valarray</A><BR>
</UL>
<A HREF="Chap07.htm#Heading245">Summary</A><BR>
<A HREF="Chap07.htm#Heading246">Exercises</A><BR>
</UL>
<A HREF="Chap08.htm">8: STL Algorithms</A><BR>
<UL>
<A HREF="Chap08.htm#Heading248">Function objects</A><BR>
<UL>
<A HREF="Chap08.htm#Heading249">Classification of function objects</A><BR>
<A HREF="Chap08.htm#Heading250">Automatic creation of function objects</A><BR>
<UL>
<A HREF="Chap08.htm#Heading251">Binders</A><BR>
<A HREF="Chap08.htm#Heading252">Function pointer adapters</A><BR>
</UL>
<A HREF="Chap08.htm#Heading253">SGI extensions</A><BR>
</UL>
<A HREF="Chap08.htm#Heading254">A catalog of STL algorithms</A><BR>
<UL>
<A HREF="Chap08.htm#Heading255">Support tools for example creation</A><BR>
<A HREF="Chap08.htm#Heading256">Filling &amp; generating</A><BR>
<UL>
<A HREF="Chap08.htm#Heading257">Example</A><BR>
</UL>
<A HREF="Chap08.htm#Heading258">Counting</A><BR>
<UL>
<A HREF="Chap08.htm#Heading259">Example</A><BR>
</UL>
<A HREF="Chap08.htm#Heading260">Manipulating sequences</A><BR>
<UL>
<A HREF="Chap08.htm#Heading261">Example</A><BR>
</UL>
<A HREF="Chap08.htm#Heading262">Searching &amp; replacing</A><BR>
<UL>
<A HREF="Chap08.htm#Heading263">Example</A><BR>
</UL>
<A HREF="Chap08.htm#Heading264">Comparing ranges</A><BR>
<UL>
<A HREF="Chap08.htm#Heading265">Example</A><BR>
</UL>
<A HREF="Chap08.htm#Heading266">Removing elements</A><BR>
<UL>
<A HREF="Chap08.htm#Heading267">Example</A><BR>
</UL>
<A HREF="Chap08.htm#Heading268">Sorting and operations on sorted ranges</A><BR>
<UL>
<A HREF="Chap08.htm#Heading269">Sorting</A><BR>
<A HREF="Chap08.htm#Heading270">Example</A><BR>
<A HREF="Chap08.htm#Heading271">Locating elements in sorted ranges</A><BR>
<A HREF="Chap08.htm#Heading272">Example</A><BR>
<A HREF="Chap08.htm#Heading273">Merging sorted ranges</A><BR>
<A HREF="Chap08.htm#Heading274">Example</A><BR>
<A HREF="Chap08.htm#Heading275">Set operations on sorted ranges</A><BR>
<A HREF="Chap08.htm#Heading276">Example</A><BR>
</UL>
<A HREF="Chap08.htm#Heading277">Heap operations</A><BR>
<A HREF="Chap08.htm#Heading278">Applying an operation to each element in a range</A><BR>
<UL>
<A HREF="Chap08.htm#Heading279">Examples</A><BR>
</UL>
<A HREF="Chap08.htm#Heading280">Numeric algorithms</A><BR>
<UL>
<A HREF="Chap08.htm#Heading281">Example</A><BR>
</UL>
<A HREF="Chap08.htm#Heading282">General utilities</A><BR>
</UL>
<A HREF="Chap08.htm#Heading283">Creating your own STL-style algorithms</A><BR>
<A HREF="Chap08.htm#Heading284">Summary</A><BR>
<A HREF="Chap08.htm#Heading285">Exercises</A><BR>
</UL>
<A HREF="Part3.htm">Part 3: Advanced Topics</A><BR>
<A HREF="Chap09.htm">9: Run-time type identification</A><BR>
<UL>
<A HREF="Chap09.htm#Heading288">The &#8220;Shape&#8221; example</A><BR>
<A HREF="Chap09.htm#Heading289">What is RTTI?</A><BR>
<UL>
<A HREF="Chap09.htm#Heading290">Two syntaxes for RTTI</A><BR>
</UL>
<A HREF="Chap09.htm#Heading291">Syntax specifics</A><BR>
<UL>
<A HREF="Chap09.htm#Heading292">typeid(&#160;) with built-in types</A><BR>
<A HREF="Chap09.htm#Heading293">Producing the proper type name</A><BR>
<A HREF="Chap09.htm#Heading294">Nonpolymorphic types</A><BR>
<A HREF="Chap09.htm#Heading295">Casting to intermediate levels</A><BR>
<A HREF="Chap09.htm#Heading296">void pointers</A><BR>
<A HREF="Chap09.htm#Heading297">Using RTTI with templates</A><BR>
</UL>
<A HREF="Chap09.htm#Heading298">References</A><BR>
<UL>
<A HREF="Chap09.htm#Heading299">Exceptions</A><BR>
</UL>
<A HREF="Chap09.htm#Heading300">Multiple inheritance</A><BR>
<A HREF="Chap09.htm#Heading301">Sensible uses for RTTI</A><BR>
<UL>
<A HREF="Chap09.htm#Heading302">Revisiting the trash recycler</A><BR>
</UL>
<A HREF="Chap09.htm#Heading303">Mechanism &amp; overhead of RTTI</A><BR>
<A HREF="Chap09.htm#Heading304">Creating your own RTTI</A><BR>
<A HREF="Chap09.htm#Heading305">Explicit cast syntax</A><BR>
<A HREF="Chap09.htm#Heading306">Summary</A><BR>
<A HREF="Chap09.htm#Heading307">Exercises</A><BR>
</UL>
<A HREF="Chap10.htm">10: Multiple inheritance</A><BR>
<UL>
<A HREF="Chap10.htm#Heading309">Perspective</A><BR>
<A HREF="Chap10.htm#Heading310">Duplicate subobjects</A><BR>
<A HREF="Chap10.htm#Heading311">Ambiguous upcasting</A><BR>
<A HREF="Chap10.htm#Heading312">virtual base classes</A><BR>
<UL>
<A HREF="Chap10.htm#Heading313">The "most derived" class and virtual base initialization</A><BR>
<A HREF="Chap10.htm#Heading314">"Tying off" virtual bases with a default constructor</A><BR>
</UL>
<A HREF="Chap10.htm#Heading315">Overhead</A><BR>
<A HREF="Chap10.htm#Heading316">Upcasting</A><BR>
<UL>
<A HREF="Chap10.htm#Heading317">Persistence</A><BR>
<UL>
<A HREF="Chap10.htm#Heading318">MI-based persistence</A><BR>
<A HREF="Chap10.htm#Heading319">Improved persistence</A><BR>
</UL>
</UL>
<A HREF="Chap10.htm#Heading320">Avoiding MI</A><BR>
<A HREF="Chap10.htm#Heading321">Mixin types</A><BR>
<A HREF="Chap10.htm#Heading322">Repairing an interface</A><BR>
<A HREF="Chap10.htm#Heading323">Summary</A><BR>
<A HREF="Chap10.htm#Heading324">Exercises</A><BR>
</UL>
<A HREF="Chap11.htm">11: Design patterns</A><BR>
<UL>
<A HREF="Chap11.htm#Heading326">The pattern concept</A><BR>
<UL>
<A HREF="Chap11.htm#Heading327">The singleton</A><BR>
<UL>
<A HREF="Chap11.htm#Heading328">Variations on singleton</A><BR>
</UL>
</UL>
<A HREF="Chap11.htm#Heading329">Classifying patterns</A><BR>
<UL>
<A HREF="Chap11.htm#Heading330">Features, idioms, patterns</A><BR>
<A HREF="Chap11.htm#Heading331">Basic complexity hiding</A><BR>
</UL>
<A HREF="Chap11.htm#Heading332">Dynamic aggregation</A><BR>
<A HREF="Chap11.htm#Heading333">Factories: encapsulating object creation</A><BR>
<UL>
<A HREF="Chap11.htm#Heading334">Polymorphic factories</A><BR>
<A HREF="Chap11.htm#Heading335">Abstract factories</A><BR>
<A HREF="Chap11.htm#Heading336">Virtual constructorsBE</A><BR>
<UL>
<A HREF="Chap11.htm#Heading337">Destructor operation</A><BR>
</UL>
</UL>
<A HREF="Chap11.htm#Heading338">Callbacks</A><BR>
<UL>
<A HREF="Chap11.htm#Heading339">Functor/Command</A><BR>
<A HREF="Chap11.htm#Heading340">Strategy</A><BR>
<A HREF="Chap11.htm#Heading341">Observer</A><BR>
<UL>
<A HREF="Chap11.htm#Heading342">The &#8220;interface&#8221; idiom</A><BR>
<A HREF="Chap11.htm#Heading343">The &#8220;inner class&#8221; idiom</A><BR>
<A HREF="Chap11.htm#Heading344">The observer example</A><BR>
</UL>
</UL>
<A HREF="Chap11.htm#Heading345">Multiple dispatching</A><BR>
<UL>
<A HREF="Chap11.htm#Heading346">Visitor, a type of multiple dispatching</A><BR>
</UL>
<A HREF="Chap11.htm#Heading347">Proxy</A><BR>
<A HREF="Chap11.htm#Heading348">Efficiency</A><BR>
<UL>
<A HREF="Chap11.htm#Heading349">Reference counting</A><BR>
<A HREF="Chap11.htm#Heading350">Flyweight</A><BR>
</UL>
<A HREF="Chap11.htm#Heading351">The composite</A><BR>
<A HREF="Chap11.htm#Heading352">Evolving a design: the trash recycler</A><BR>
<A HREF="Chap11.htm#Heading353">Improving the design</A><BR>
<UL>
<A HREF="Chap11.htm#Heading354">&#8220;Make more objects&#8221;</A><BR>
<A HREF="Chap11.htm#Heading355">A pattern for prototyping creation</A><BR>
<UL>
<A HREF="Chap11.htm#Heading356">Trash subclasses</A><BR>
<A HREF="Chap11.htm#Heading357">Parsing Trash from an external file</A><BR>
<A HREF="Chap11.htm#Heading358">Recycling with prototyping</A><BR>
</UL>
</UL>
<A HREF="Chap11.htm#Heading359">Abstracting usage</A><BR>
<A HREF="Chap11.htm#Heading360">Applying double dispatching</A><BR>
<UL>
<A HREF="Chap11.htm#Heading361">Implementing the double dispatch</A><BR>
</UL>
<A HREF="Chap11.htm#Heading362">Applying the visitor pattern</A><BR>
<UL>
<A HREF="Chap11.htm#Heading363">More coupling?</A><BR>
</UL>
<A HREF="Chap11.htm#Heading364">RTTI considered harmful?</A><BR>
<A HREF="Chap11.htm#Heading365">Summary</A><BR>
<A HREF="Chap11.htm#Heading366">Exercises</A><BR>
</UL>
<A HREF="AppendA.htm">A: Recommended reading</A><BR>
<UL>
<A HREF="AppendA.htm#Heading368">C</A><BR>
<A HREF="AppendA.htm#Heading369">General C++</A><BR>
<UL>
<A HREF="AppendA.htm#Heading370">My own list of books </A><BR>
</UL>
<A HREF="AppendA.htm#Heading371">Depth &amp; dark corners</A><BR>
<A HREF="AppendA.htm#Heading372">The STL</A><BR>
<A HREF="AppendA.htm#Heading373">Design Patterns</A><BR>
</UL>
<A HREF="AppendB.htm">B: Etc</A><BR>
<A HREF="TicV218.htm">Index</A><BR>
</UL>
</BODY>
</HTML>

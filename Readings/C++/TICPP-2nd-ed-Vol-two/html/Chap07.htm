<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:C:\TEMP\TicV2\html\TicV2.rtf
Application Directory:C:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:08/19/2001
Translation Time:14:24:58
Translation Platform:Win32
Number of Output files:19
This File:C:\TEMP\TicV2\html\Chap07.htm
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html">
<TITLE>7: STL Containers &amp; Iterators</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF"><DIV ALIGN="CENTER">
  <a href="http://www.MindView.net">
  <img src="mindview.gif" alt="MindView Inc." BORDER = "0"></a>
  <CENTER>
    <FONT FACE="Verdana, Tahoma, Arial, Helvetica, Sans" size = "-1">
    [ <a href="README.txt">Viewing Hints</a> ]
    [ <a href="RevisionHistory.htm">Revision History</a> ]
    [ <a href="http://www.mindview.net/Books/TICPP/ThinkingInCPP2e.html">Book Home Page</a> ]
    [ <a href="http://www.mindview.net/Etc/MailingList.html">Free Newsletter</a> ] <br>
    [ <a href="http://www.mindview.net/Seminars">Seminars</a> ]
    [ <a href="http://www.mindview.net/CDs">Seminars on CD ROM</a> ]
    [ <a href="http://www.mindview.net/Services">Consulting</a> ]
    </FONT>
  <H2><FONT FACE="Verdana, Tahoma, Arial, Helvetica, Sans">
  Thinking in C++, 2nd edition, Volume 2<br>
  <small>Revision 4.0</small></FONT></H2>
  <H3><FONT FACE="Verdana, Tahoma, Arial, Helvetica, Sans">
  by Bruce Eckel &amp; Chuck Allison<br>&copy;2001 MindView, Inc.</FONT></H3>
  
    <FONT FACE="Verdana, Tahoma, Arial, Helvetica, Sans" size = "-1">
     [ <a href="Chap06.htm">Previous Chapter</a> ] 
    
    [ <a href="SimpCont.htm">Short TOC</a> ] 
    [ <a href="Contents.htm">Table of Contents</a> ] 
  
        [ <a href="DocIdx.htm">Index</a> ]
        
     [ <a href="Chap08.htm">Next Chapter</a> ] 
    </FONT>
    
  </CENTER>
  </P></DIV><A NAME="_Toc519042009"></A><A NAME="Heading188"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H1 ALIGN="LEFT">
7: STL Containers &amp; Iterators<A NAME="STLContainersChapter"></A></H1></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana" SIZE=4><a NAME="TIC2V2_CHAPTER7_I1"></a>
<I>Container
classes </I>are the solution to a specific kind of code reuse problem. They are
building blocks used to create object-oriented programs &#8211; they make the
internals of a program much easier to construct.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A container class describes an object
that holds other objects. Container classes are so important that they were
considered fundamental to early object-oriented languages. In Smalltalk, for
example, programmers think of the language as the program translator together
with the class library, and a critical part of that library is the container
classes. So it became natural that C++ compiler vendors also include a container
class library. You&#8217;ll note that the <B>vector</B> was so useful that it
was introduced in its simplest form very early in this
book.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I1">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I2"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Like many other early C++ libraries,
early container class libraries followed Smalltalk&#8217;s <I>object-based
hierarchy</I>, which worked well for Smalltalk, but turned out to be awkward and
difficult to use in C++. Another approach was
required.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I2">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I3"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This chapter attempts to slowly work you
into the concepts of the C++ <I>Standard Template Library </I>(STL), which is a
powerful library of containers (as well as <I>algorithms</I>, but these are
covered in the following chapter). In the past, I have taught that there is a
relatively small subset of elements and ideas that you need to understand in
order to get much of the usefulness from the STL. Although this can be true it
turns out that understanding the STL more deeply is important to gain the full
power of the library. This chapter and the next probe into the STL containers
and
algorithms.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I3">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I4"></a>
</FONT><A NAME="_Toc312374160"></A><A NAME="_Toc305593281"></A><A NAME="_Toc305628753"></A><A NAME="_Toc312374088"></A><A NAME="_Toc375545199"></A><A NAME="_Toc408018396"></A><A NAME="_Toc519042010"></A><BR></P></DIV>
<A NAME="Heading189"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Containers and iterators</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you don&#8217;t know how many objects
you&#8217;re going to need to solve a particular problem, or how long they will
last, you also don&#8217;t know how to store those objects. How can you know how
much space to create? You can&#8217;t, since that information isn&#8217;t known
until run time.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I4">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I5"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The solution to most problems in
object-oriented design seems flippant: you create another type of object. For
the storage problem, the new type of object holds other objects, or pointers to
objects. Of course, you can do the same thing with an array, but there&#8217;s
more. This new type of object, which is typically referred to in C++ as a
<I>container</I> (also called a <I>collection</I> in some languages), will
expand itself whenever necessary to accommodate everything you place inside it.
So you don&#8217;t need to know how many objects you&#8217;re going to hold in a
collection. You just create a collection object and let it take care of the
details.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I5">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I6"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Fortunately, a good OOP language comes
with a set of containers as part of the package. In C++, it&#8217;s the Standard
Template Library (STL). In some libraries, a generic container is considered
good enough for all needs, and in others (C++ in particular) the library has
different types of containers for different needs: a vector for consistent
access to all elements, and a linked list for consistent insertion at all
elements, for example, so you can choose the particular type that fits your
needs. These may include sets, queues, hash tables, trees, stacks,
etc.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I6">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I7"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All containers have some way to put
things in and get things out. The way that you place something into a container
is fairly obvious. There&#8217;s a function called &#8220;push&#8221; or
&#8220;add&#8221; or a similar name. Fetching things out of a container is not
always as apparent; if it&#8217;s an array-like entity such as a vector, you
might be able to use an indexing operator or function. But in many situations
this doesn&#8217;t make sense. Also, a single-selection function is restrictive.
What if you want to manipulate or compare a group of elements in the
container?
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I7">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I8"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The solution is an <I>iterator</I>, which
is an object whose job is to select the elements within a container and present
them to the user of the iterator. As a class, it also provides a level of
abstraction. This abstraction can be used to separate the details of the
container from the code that&#8217;s accessing that container. The container,
via the iterator, is abstracted to be simply a sequence. The iterator allows you
to traverse that sequence without worrying about the underlying structure
&#8211; that is, whether it&#8217;s a vector, a linked list, a stack or
something else. This gives you the flexibility to easily change the underlying
data structure without disturbing the code in your program.

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I8">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I9"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">From the design standpoint, all you
really want is a sequence that can be manipulated to solve your problem. If a
single type of sequence satisfied all of your needs, there&#8217;d be no reason
to have different kinds. There are two reasons that you need a choice of
containers. First, containers provide different types of interfaces and external
behavior. A stack has a different interface and behavior than that of a queue,
which is different than that of a set or a list. One of these might provide a
more flexible solution to your problem than the other. Second, different
containers have different efficiencies for certain operations. The best example
is a vector and a list. Both are simple sequences that can have identical
interfaces and external behaviors. But certain operations can have radically
different costs. Randomly accessing elements in a vector is a constant-time
operation; it takes the same amount of time regardless of the element you
select. However, in a linked list it is expensive to move through the list to
randomly select an element, and it takes longer to find an element if it is
further down the list. On the other hand, if you want to insert an element in
the middle of a sequence, it&#8217;s much cheaper in a list than in a vector.
These and other operations have different efficiencies depending upon the
underlying structure of the sequence. In the design phase, you might start with
a list and, when tuning for performance, change to a vector. Because of the
abstraction via iterators, you can change from one to the other with minimal
impact on your code.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I9">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I10"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the end, remember that a container is
only a storage cabinet to put objects in. If that cabinet solves all of your
needs, it doesn&#8217;t really matter <I>how</I> it is implemented (a basic
concept with most types of objects). If you&#8217;re working in a programming
environment that has built-in overhead due to other factors, then the cost
difference between a vector and a linked list might not matter. You might need
only one type of sequence. You can even imagine the &#8220;perfect&#8221;
container abstraction, which can automatically change its underlying
implementation according to the way it is
used.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I10">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I11"></a>
</FONT><A NAME="_Toc519042011"></A><BR></P></DIV>
<A NAME="Heading190"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
STL reference documentation</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You will notice that this chapter does
not contain exhaustive documentation describing each of the member functions in
each STL container. Although I describe the member functions that I use,
I&#8217;ve left the full descriptions to others: there are at least two very
good on-line sources of STL documentation in HTML format that you can keep
resident on your computer and view with a Web browser whenever you need to look
something up. The first is the Dinkumware library (which covers the entire
Standard C and C++ library) mentioned at the beginning of this book section
(page XXX). The second is the freely-downloadable SGI STL and documentation,
freely downloadable at http://www.sgi.com/Technology/STL/. These should provide
complete references when you&#8217;re writing code. In addition, the STL books
listed in Appendix XX will provide you with other
resources.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I11">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I12"></a>
</FONT><A NAME="_Toc519042012"></A><BR></P></DIV>
<A NAME="Heading191"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
The Standard Template Library
<BR><A NAME="Index491"></A><A NAME="Index492"></A><A NAME="Index493"></A><A NAME="Index494"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The C++
STL</FONT><A NAME="fnB19" HREF="#fn19">[19]</A><A NAME="Index495"></A><A NAME="Index496"></A><FONT FACE="Georgia">
is a powerful library intended to satisfy the vast bulk of your needs for
containers and algorithms, but in a completely portable fashion. This means that
not only are your programs easier to port to other platforms, but that your
knowledge itself does not depend on the libraries provided by a particular
compiler vendor (and the STL is likely to be more tested and scrutinized than a
particular vendor&#8217;s library). Thus, it will benefit you greatly to look
first to the STL for containers and algorithms, <I>before</I> looking at
vendor-specific
solutions.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I12">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I13"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A fundamental principle of software
design is that <I>all problems can be simplified by introducing an extra level
of indirection</I>. This simplicity is achieved in the STL using
<I>iterators</I> to perform operations on a data structure while knowing as
little as possible about that structure, thus producing data structure
independence. With the STL, this means that any operation that can be performed
on an array of objects can also be performed on an STL container of objects and
vice versa. The STL containers work just as easily with built-in types as they
do with user-defined types. If you learn the library, it will work on
everything.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I13">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I14"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The drawback to this independence is that
you&#8217;ll have to take a little time at first getting used to the way things
are done in the STL. However, the STL uses a consistent pattern, so once you fit
your mind around it, it doesn&#8217;t change from one STL tool to
another.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I14">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I15"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Consider an example using the STL
<B>set</B> <A NAME="Index497"></A><A NAME="Index498"></A>class. A set will allow
only one of each object value to be inserted into itself. Here is a simple
<B>set</B> created to work with <B>int</B>s by providing <B>int</B> as the
template argument to
<B>set</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I15">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I16"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:Intset.cpp</font>
<font color=#009900>// Simple use of STL set</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;set&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  set&lt;<font color=#0000ff>int</font>&gt; intset;
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 25; i++)
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; 10; j++)
        <font color=#009900>// Try to insert multiple copies:</font>
        intset.insert(j);
  <font color=#009900>// Print to output:</font>
  copy(intset.begin(), intset.end(),
    ostream_iterator&lt;<font color=#0000ff>int</font>&gt;(cout, <font color=#004488>"\n"</font>));
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>insert(&#160;)</B> member does all
the work: it tries putting the new element in and rejects it if it&#8217;s
already there. Very often the activities involved in using a set are simply
insertion and a test to see whether it contains the element. You can also form a
union, intersection, or difference of sets, and test to see if one set is a
subset of another.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I16">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I17"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In this example, the values 0 - 9 are
inserted into the set 25 times, and the results are printed out to show that
only one of each of the values is actually retained in the
set.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I17">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I18"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>copy(&#160;)</B> function is
actually the instantiation of an STL template function, of which there are many.
These template functions are generally referred to as &#8220;the STL
Algorithms&#8221; and will be the subject of the following chapter. However,
several of the algorithms are so useful that they will be introduced in this
chapter. Here, <B>copy(&#160;) </B>shows the use of iterators. The <B>set</B>
member functions <B>begin(&#160;)</B> and <B>end(&#160;)</B> produce iterators
as their return values. These are used by <B>copy(&#160;)</B> as beginning and
ending points for its operation, which is simply to move between the boundaries
established by the iterators and copy the elements to the third argument, which
is also an iterator, but in this case, a special type created for iostreams.
This places <B>int</B> objects on <B>cout</B> and separates them with a
newline.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I18">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I19"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because of its genericity,
<B>copy(&#160;)</B> is certainly not restricted to printing on a stream. It can
be used in virtually any situation: it needs only three iterators to talk to.
All of the algorithms follow the form of <B>copy(&#160;)</B> and simply
manipulate iterators (the use of iterators is the &#8220;extra level of
indirection&#8221;).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I19">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I20"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now consider taking the form of
<B>Intset.cpp</B> and reshaping it to display a list of the words used in a
document. The solution becomes remarkably
simple.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I20">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I21"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:WordSet.cpp</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;string&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;set&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>void</font> wordSet(<font color=#0000ff>char</font>* fileName) {
  ifstream source(fileName);
  assure(source, fileName);
  string word;
  set&lt;string&gt; words;
  <font color=#0000ff>while</font>(source &gt;&gt; word)
    words.insert(word);
  copy(words.begin(), words.end(),
    ostream_iterator&lt;string&gt;(cout, <font color=#004488>"\n"</font>));
  cout &lt;&lt; <font color=#004488>"Number of unique words:"</font> 
    &lt;&lt; words.size() &lt;&lt; endl;
}  

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  <font color=#0000ff>if</font>(argc &gt; 1)
    wordSet(argv[1]);
  <font color=#0000ff>else</font>
    wordSet(<font color=#004488>"WordSet.cpp"</font>);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The only substantive difference here is
that <B>string</B> is used instead of <B>int</B>. The words are pulled from a
file, but everything else is the same as in <B>Intset.cpp</B>. The
<B>operator&gt;&gt;</B> returns a whitespace-separated group of characters each
time it is called, until there&#8217;s no more input from the file. So it
approximately breaks an input stream up into words. Each <B>string</B> is placed
in the <B>set </B>using <B>insert(&#160;)</B>, and the <B>copy(&#160;)</B>
function is used to display the results. Because of the way <B>set</B> is
implemented (as a tree), the words are automatically
sorted.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I21">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I22"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Consider how much effort it would be to
accomplish the same task in C, or even in C++ without the
STL.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I22">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I23"></a>
</FONT><A NAME="_Toc519042013"></A><BR></P></DIV>
<A NAME="Heading192"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
The basic concepts</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The primary idea in the STL is the
<I>container</I> (also known as a <I>collection</I>), which is just what it
sounds like: a place to hold things. You need containers because objects are
constantly marching in and out of your program and there must be someplace to
put them while they&#8217;re around. You can&#8217;t make named local objects
because in a typical program you don&#8217;t know how many, or what type, or the
lifetime of the objects you&#8217;re working with. So you need a container that
will expand whenever necessary to fill your
needs.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I23">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I24"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All the containers in the STL hold
objects and expand themselves. In addition, they hold your objects in a
particular way. The difference between one container and another is the way the
objects are held and how the sequence is created. Let&#8217;s start by looking
at the simplest
containers.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I24">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I25"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>vector</B> is a linear sequence that
allows rapid random access to its elements. However, it&#8217;s expensive to
insert an element in the middle of the sequence, and is also expensive when it
allocates additional storage. A <B>deque</B> is also a linear sequence, and it
allows random access that&#8217;s nearly as fast as<B> vector</B>, but
it&#8217;s significantly faster when it needs to allocate new storage, and you
can easily add new elements at either end (<B>vector </B>only allows the
addition of elements at its tail). A <B>list</B> the third type of basic linear
sequence, but it&#8217;s expensive to move around randomly and cheap to insert
an element in the middle. Thus <B>list</B>, <B>deque</B> and <B>vector</B> are
very similar in their basic functionality (they all hold linear sequences), but
different in the cost of their activities. So for your first shot at a program,
you could choose any one, and only experiment with the others if you&#8217;re
tuning for efficiency.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I25">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I26"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Many of the problems you set out to solve
will only require a simple linear sequence like a <B>vector</B>, <B>deque</B> or
<B>list</B>. All three have a member function <B>push_back(&#160;)</B> which you
use to insert a new element at the back of the sequence (<B>deque</B> and
<B>list</B> also have
<B>push_front(&#160;)</B>).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I26">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I27"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">But now how do you retrieve those
elements? With a <B>vector</B> or <B>deque</B>, it is possible to use the
indexing <B>operator[ ]</B>, but that doesn&#8217;t work with <B>list</B>. Since
it would be nicest to learn a single interface, we&#8217;ll often use the one
defined for all STL containers: the
<I>iterator</I>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I27">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I28"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An iterator is a class that abstracts the
process of moving through a sequence. It allows you to select each element of a
sequence <I>without knowing the underlying structure of that sequence</I>. This
is a powerful feature, partly because it allows us to learn a single interface
that works with all containers, and partly because it allows containers to be
used interchangeably.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I28">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I29"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One more observation and you&#8217;re
ready for another example. Even though the STL containers hold objects by value
(that is, they hold the whole object inside themselves) that&#8217;s probably
not the way you&#8217;ll generally use them if you&#8217;re doing
object-oriented programming. That&#8217;s because in OOP, most of the time
you&#8217;ll create objects on the heap with <B>new</B> and then <I>upcast</I>
the address to the base-class type, later manipulating it as a pointer to the
base class. The beauty of this is that you don&#8217;t worry about the specific
type of object you&#8217;re dealing with, which greatly reduces the complexity
of your code and increases the maintainability of your program. This process of
upcasting is what you try to do in OOP with polymorphism, so you&#8217;ll
usually be using containers of
pointers.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I29">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I30"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Consider the classic &#8220;shape&#8221;
example where shapes have a set of common operations, and you have different
types of shapes. Here&#8217;s what it looks like using the STL <B>vector</B> to
hold pointers to various types of <B>Shape</B> created on the
heap:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I30">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I31"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:Stlshape.cpp</font>
<font color=#009900>// Simple shapes w/ STL</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;vector&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Shape {
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> draw() = 0;
  <font color=#0000ff>virtual</font> ~Shape() {};
};

<font color=#0000ff>class</font> Circle : <font color=#0000ff>public</font> Shape {
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> draw() { cout &lt;&lt; <font color=#004488>"Circle::draw\n"</font>; }
  ~Circle() { cout &lt;&lt; <font color=#004488>"~Circle\n"</font>; }
};

<font color=#0000ff>class</font> Triangle : <font color=#0000ff>public</font> Shape {
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> draw() { cout &lt;&lt; <font color=#004488>"Triangle::draw\n"</font>; }
  ~Triangle() { cout &lt;&lt; <font color=#004488>"~Triangle\n"</font>; }
};

<font color=#0000ff>class</font> Square : <font color=#0000ff>public</font> Shape {
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> draw() { cout &lt;&lt; <font color=#004488>"Square::draw\n"</font>; }
  ~Square() { cout &lt;&lt; <font color=#004488>"~Square\n"</font>; }
};

<font color=#0000ff>typedef</font> std::vector&lt;Shape*&gt; Container;
<font color=#0000ff>typedef</font> Container::iterator Iter;

<font color=#0000ff>int</font> main() {
  Container shapes;
  shapes.push_back(<font color=#0000ff>new</font> Circle);
  shapes.push_back(<font color=#0000ff>new</font> Square);
  shapes.push_back(<font color=#0000ff>new</font> Triangle);
  <font color=#0000ff>for</font>(Iter i = shapes.begin();
      i != shapes.end(); i++)
    (*i)-&gt;draw();
  <font color=#009900>// ... Sometime later:</font>
  <font color=#0000ff>for</font>(Iter j = shapes.begin();
      j != shapes.end(); j++)
    <font color=#0000ff>delete</font> *j;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The creation of <B>Shape</B>,
<B>Circle</B>, <B>Square</B> and <B>Triangle</B> should be fairly familiar.
<B>Shape</B> is a pure abstract base class (because of the <I>pure specifier</I>
<B>=0</B>) that defines the interface for all types of <B>shapes</B>. The
derived classes redefine the <B>virtual</B> function <B>draw(&#160;)</B> to
perform the appropriate operation. Now we&#8217;d like to create a bunch of
different types of <B>Shape</B> object, but where to put them? In an STL
container, of course. For convenience, this
<B>typedef</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I31">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I32"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>typedef</font> std::vector&lt;Shape*&gt; Container;</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">creates
an alias for a <B>vector</B> of <B>Shape*</B>, and this
<B>typedef</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I32">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I33"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>typedef</font> Container::iterator Iter;</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">uses
that alias to create another one, for <B>vector&lt;Shape*&gt;::iterator</B>.
Notice that the <B>container</B> type name must be used to produce the
appropriate iterator, which is defined as a nested class. Although there are
different types of iterators (forward, bidirectional, reverse, etc., which will
be explained later) they all have the same basic interface: you can increment
them with <B>++</B>, you can dereference them to produce the object
they&#8217;re currently selecting, and you can test them to see if they&#8217;re
at the end of the sequence. That&#8217;s what you&#8217;ll want to do 90% of the
time. And that&#8217;s what is done in the above example: after creating a
container, it&#8217;s filled with different types of <B>Shape*</B>. Notice that
the upcast happens as the <B>Circle</B>, <B>Square</B> or <B>Rectangle</B>
pointer is added to the <B>shapes</B> container, which doesn&#8217;t know about
those specific types but instead holds only <B>Shape*</B>. So as soon as the
pointer is added to the container it loses its specific identity and becomes an
anonymous <B>Shape*</B>. This is exactly what we want: toss them all in and let
polymorphism sort it out.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I33">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I34"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first <B>for</B> loop creates an
iterator and sets it to the beginning of the sequence by calling the
<B>begin(&#160;)</B> member function for the container. All containers have
<B>begin(&#160;)</B> and <B>end(&#160;)</B> member functions that produce an
iterator selecting, respectively, the beginning of the sequence and one past the
end of the sequence. To test to see if you&#8217;re done, you make sure
you&#8217;re <B>!=</B> to the iterator produced by <B>end(&#160;)</B>. Not
<B>&lt;</B> or <B>&lt;=</B>. The only test that works is <B>!=</B>. So
it&#8217;s very common to write a loop
like:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I34">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I35"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>for</font>(Iter i = shapes.begin(); i != shapes.end(); i++)</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This says: &#8220;take me through every
element in the
sequence.&#8221;
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I35">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I36"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What do you do with the iterator to
produce the element it&#8217;s selecting? You dereference it using (what else)
the &#8216;<B>*</B>&#8217; (which is actually an overloaded operator). What you
get back is whatever the container is holding. This container holds
<B>Shape*</B>, so that&#8217;s what <B>*i</B> produces. If you want to send a
message to the <B>Shape</B>, you must select that message with <B>-&gt;</B>, so
you write the line:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I36">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I37"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>(*i)-&gt;draw();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This calls the <B>draw(&#160;)</B>
function for the <B>Shape*</B> the iterator is currently selecting. The
parentheses are ugly but necessary to produce the proper order of evaluation. As
an alternative, <B>operator-&gt;</B> is defined so that you can
say:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I37">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I38"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>i-&gt;draw();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As they are destroyed or in other cases
where the pointers are removed, the STL containers <I>do not</I> call
<B>delete</B> for the pointers they contain. If you create an object on the heap
with <B>new</B> and place its pointer in a container, the container can&#8217;t
tell if that pointer is also placed inside another container. So the STL just
doesn&#8217;t do anything about it, and puts the responsibility squarely in your
lap. The last lines in the program move through and delete every object in the
container so proper cleanup
occurs.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I38">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I39"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s very interesting to note that
you can change the type of container that this program uses with two lines.
Instead of including <B>&lt;vector&gt;</B>, you include <B>&lt;list&gt;</B>, and
in the first <B>typedef</B> you
say:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I39">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I40"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>typedef</font> std::list&lt;Shape*&gt; Container;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">instead of using a <B>vector</B>.
Everything else goes untouched. This is possible not because of an interface
enforced by inheritance (there isn&#8217;t any inheritance in the STL, which
comes as a surprise when you first see it), but because the interface is
enforced by a convention adopted by the designers of the STL, precisely so you
could perform this kind of interchange. Now you can easily switch between
<B>vector</B> and <B>list</B> and see which one works fastest for your
needs.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I40">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I41"></a>
</FONT><A NAME="_Toc519042014"></A><BR></P></DIV>
<A NAME="Heading193"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Containers of strings</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the prior example, at the end of
<B>main(&#160;)</B>, it was necessary to move through the whole list and
<B>delete</B> all the <B>Shape</B> pointers.

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I41">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I42"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>for</font>(Iter j = shapes.begin();
      j != shapes.end(); j++)
    <font color=#0000ff>delete</font> *j;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This highlights what could be seen as a
flaw in the STL: there&#8217;s no facility in any of the STL containers to
automatically <B>delete</B> the pointers they contain, so you must do it by
hand. It&#8217;s as if the assumption of the STL designers was that containers
of pointers weren&#8217;t an interesting problem, although I assert that it is
one of the more common things you&#8217;ll want to
do.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I42">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I43"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Automatically deleting a pointer turns
out to be a rather aggressive thing to do because of the <I>multiple
membership</I> problem. If a container holds a pointer to an object, it&#8217;s
not unlikely that pointer could also be in another container. A pointer to an
<B>Aluminum</B> object in a list of <B>Trash</B> pointers could also reside in a
list of <B>Aluminum</B> pointers. If that happens, which list is responsible for
cleaning up that object &#8211; that is, which list &#8220;owns&#8221; the
object?
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I43">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I44"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This question is virtually eliminated if
the object rather than a pointer resides in the list. Then it seems clear that
when the list is destroyed, the objects it contains must also be destroyed.
Here, the STL shines, as you can see when creating a container of <B>string</B>
objects. The following example stores each incoming line as a <B>string</B> in a
<B>vector&lt;string&gt;</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I44">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I45"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:StringVector.cpp</font>
<font color=#009900>// A vector of strings</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;sstream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  <font color=#0000ff>char</font>* fname = <font color=#004488>"StringVector.cpp"</font>;
  <font color=#0000ff>if</font>(argc &gt; 1) fname = argv[1];
  ifstream in(fname);
  assure(in, fname);
  vector&lt;string&gt; strings;
  string line;
  <font color=#0000ff>while</font>(getline(in, line))
    strings.push_back(line);
  <font color=#009900>// Do something to the strings...</font>
  <font color=#0000ff>int</font> i = 1;
  vector&lt;string&gt;::iterator w;
  <font color=#0000ff>for</font>(w = strings.begin();
      w != strings.end(); w++) {
    ostringstream ss;
    ss &lt;&lt; i++;
    *w = ss.str() + <font color=#004488>": "</font> + *w;
  }
  <font color=#009900>// Now send them out:</font>
  copy(strings.begin(), strings.end(),
    ostream_iterator&lt;string&gt;(cout, <font color=#004488>"\n"</font>));
  <font color=#009900>// Since they aren't pointers, string </font>
  <font color=#009900>// objects clean themselves up! </font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once the <B>vector&lt;string&gt;
</B>called <B>strings</B> is created, each line in the file is read into a
<B>string</B> and put in the
<B>vector</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I45">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I46"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>  <font color=#0000ff>while</font>(getline(in, line))
    strings.push_back(line);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The operation that&#8217;s being
performed on this file is to add line numbers. A <B>stringstream</B> provides
easy conversion from an <B>int</B> to a <B>string</B> of characters representing
that <B>int</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I46">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I47"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Assembling <B>string</B> objects is quite
easy, since <B>operator+</B> is overloaded. Sensibly enough, the iterator
<B>w</B> can be dereferenced to produce a string that can be used as both an
rvalue <I>and</I> an
lvalue:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I47">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I48"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>*w = ss.str() + <font color=#004488>": "</font> + *w;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The fact that you can assign back into
the container via the iterator may seem a bit surprising at first, but
it&#8217;s a tribute to the careful design of the
STL.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I48">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I49"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because the <B>vector&lt;string&gt;</B>
contains the objects themselves, a number of interesting things take place.
First, no cleanup is necessary. Even if you were to put addresses of the
<B>string</B> objects as pointers into <I>other</I> containers, it&#8217;s clear
that <B>strings</B> is the &#8220;master list&#8221; and maintains ownership of
the objects.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I49">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I50"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Second, you are effectively using dynamic
object creation, and yet you never use <B>new</B> or <B>delete</B>! That&#8217;s
because, somehow, it&#8217;s all taken care of for you by the <B>vector</B>
(this is non-trivial. You can try to figure it out by looking at the header
files for the STL &#8211; all the code is there &#8211; but it&#8217;s quite an
exercise). Thus your coding is significantly cleaned
up.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I50">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I51"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The limitation of holding objects instead
of pointers inside containers is quite severe: you can&#8217;t upcast from
derived types, thus you can&#8217;t use polymorphism. The problem with upcasting
objects by value is that they get sliced and converted until their type is
completely changed into the base type, and there&#8217;s no remnant of the
derived type left. It&#8217;s pretty safe to say that you <I>never</I> want to
do
this.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I51">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I52"></a>
</FONT><A NAME="_Toc519042015"></A><BR></P></DIV>
<A NAME="Heading194"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Inheriting from STL containers</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The power of instantly creating a
sequence of elements is amazing, and it makes you realize how much time
you&#8217;ve spent (or rather, wasted) in the past solving this particular
problem. For example, many utility programs involve reading a file into memory,
modifying the file and writing it back out to disk. One might as well take the
functionality in <B>StringVector.cpp</B> and package it into a class for later
reuse.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I52">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I53"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now the question is: do you create a
member object of type <B>vector</B>, or do you inherit? A general guideline is
to always prefer composition (member objects) over inheritance, but with the STL
this is often not true, because there are so many existing algorithms that work
with the STL types that you may want your new type to <I>be</I> an STL type. So
the list of <B>string</B>s<B> </B>should also <I>be</I> a <B>vector</B>, thus
inheritance is desired.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I53">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I54"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:FileEditor.h</font>
<font color=#009900>// File editor tool</font>
#ifndef FILEEDITOR_H
#define FILEEDITOR_H
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

<font color=#0000ff>class</font> FileEditor : 
<font color=#0000ff>public</font> std::vector&lt;std::string&gt; {
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> open(<font color=#0000ff>char</font>* filename);
  FileEditor(<font color=#0000ff>char</font>* filename) {
    open(filename);
  }
  FileEditor() {};
  <font color=#0000ff>void</font> write(std::ostream&amp; out = std::cout);
};
#endif <font color=#009900>// FILEEDITOR_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note the careful avoidance of a global
<B>using namespace std</B> statement here, to prevent the opening of the
<B>std</B> namespace to every file that includes this
header.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I54">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I55"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The constructor opens the file and reads
it into the <B>FileEditor</B>, and <B>write(&#160;)</B> puts the <B>vector</B>
of <B>string</B> onto any <B>ostream</B>. Notice in <B>write(&#160;) </B>that
you can have a default argument for a
reference.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I55">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I56"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The implementation is quite
simple:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I56">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I57"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:FileEditor.cpp {O}</font>
#include <font color=#004488>"FileEditor.h"</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;fstream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>void</font> FileEditor::open(<font color=#0000ff>char</font>* filename) {
  ifstream in(filename);
  assure(in, filename);
  string line;
  <font color=#0000ff>while</font>(getline(in, line))
    push_back(line);
}

<font color=#009900>// Could also use copy() here:</font>
<font color=#0000ff>void</font> FileEditor::write(ostream&amp; out) {
  <font color=#0000ff>for</font>(iterator w = begin();  w != end(); w++)
    out &lt;&lt; *w &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The functions from
<B>StringVector.cpp</B> are simply repackaged. Often this is the way classes
evolve &#8211; you start by creating a program to solve a particular
application, then discover some commonly-used functionality within the program
that can be turned into a
class.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I57">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I58"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The line numbering program can now be
rewritten using
<B>FileEditor</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I58">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I59"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:FEditTest.cpp</font>
<font color=#009900>//{L} FileEditor ../TestSuite/Test</font>
<font color=#009900>// Test the FileEditor tool</font>
#include <font color=#004488>"FileEditor.h"</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;sstream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  FileEditor file;
  <font color=#0000ff>if</font>(argc &gt; 1) {
    file.open(argv[1]);
  } <font color=#0000ff>else</font> {
    file.open(<font color=#004488>"FEditTest.cpp"</font>);
  }
  <font color=#009900>// Do something to the lines...</font>
  <font color=#0000ff>int</font> i = 1;
  FileEditor::iterator w = file.begin();
  <font color=#0000ff>while</font>(w != file.end()) {
    ostringstream ss;
    ss &lt;&lt; i++;
    *w = ss.str() + <font color=#004488>": "</font> + *w;
    w++;
  }
  <font color=#009900>// Now send them to cout:</font>
  file.write();
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now the operation of reading
the file is in the
constructor:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I59">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I60"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>FileEditor file(argv[1]);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">(or in the <B>open( ) </B>method) and
writing happens in the single line (which defaults to sending the output to
<B>cout</B>):
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I60">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I61"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>file.write();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The bulk of the program is involved with
actually modifying the file in
memory.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I61">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I62"></a>
</FONT><A NAME="_Toc519042016"></A><BR></P></DIV>
<A NAME="Heading195"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
A plethora of iterators</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As mentioned earlier, the iterator is the
abstraction that allows a piece of code to be <I>generic</I>, and to work with
different types of containers without knowing the underlying structure of those
containers.<I> </I>Every container produces iterators. You must always be able
to say:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I62">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I63"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>ContainerType::iterator
ContainerType::const_iterator</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">to produce the types of the iterators
produced by that container. Every container has a <B>begin(&#160;)</B> method
that produces an iterator indicating the beginning of the elements in the
container, and an <B>end(&#160;)</B> method that produces an iterator which is
the as the <I>past-the-end value</I> of the container. If the container is
<B>const</B>&#184; <B>begin(&#160;)</B> and <B>end(&#160;)</B> produce
<B>const</B> iterators.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I63">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I64"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Every iterator can be moved forward to
the next element using the <B>operator++</B> (an iterator may be able to do more
than this, as you shall see, but it must at least support forward movement with
<B>operator++</B>).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I64">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I65"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The basic iterator is only guaranteed to
be able to perform <B>==</B> and <B>!=</B> comparisons. Thus, to move an
iterator <B>it</B> forward without running it off the end you say something
like:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I65">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I66"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>while</font>(it != pastEnd) {
  <font color=#009900>// Do something</font>
  it++;
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Where <B>pastEnd</B> is the past-the-end
value produced by the container&#8217;s <B>end(&#160;)</B> member
function.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I66">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I67"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An iterator can be used to produce the
element that it is currently selecting within a container by dereferencing the
iterator. This can take two forms. If <B>it </B>is an iterator and <B>f(&#160;)
</B>is a member function of the objects held in the container that the iterator
is pointing within, then you can say
either:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I67">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I68"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>(*it).f();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">or

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I68">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I69"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>it-&gt;f();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Knowing this, you can create a template
that works with any container. Here, the <B>apply(&#160;)</B> function template
calls a member function for every object in the container, using a pointer to
member that is passed as an
argument:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I69">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I70"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:Apply.cpp</font>
<font color=#009900>// Using basic iterators</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-g++3}</font>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iterator&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> Cont, <font color=#0000ff>class</font> PtrMemFun&gt;
<font color=#0000ff>void</font> apply(Cont&amp; c, PtrMemFun f) {
  <font color=#0000ff>typename</font> Cont::iterator it = c.begin();
  <font color=#0000ff>while</font>(it != c.end()) {
    (it-&gt;*f)(); <font color=#009900>// Compact form</font>
    ((*it).*f)(); <font color=#009900>// Alternate form</font>
    it++;
  }
}

<font color=#0000ff>class</font> Z {
  <font color=#0000ff>int</font> i;
<font color=#0000ff>public</font>:
  Z(<font color=#0000ff>int</font> ii) : i(ii) {}
  <font color=#0000ff>void</font> g() { i++; }
  <font color=#0000ff>friend</font> ostream&amp; 
  <font color=#0000ff>operator</font>&lt;&lt;(ostream&amp; os, <font color=#0000ff>const</font> Z&amp; z) {
    <font color=#0000ff>return</font> os &lt;&lt; z.i;
  }
};

<font color=#0000ff>int</font> main() {
  ostream_iterator&lt;Z&gt; out(cout, <font color=#004488>" "</font>);
  vector&lt;Z&gt; vz;
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
    vz.push_back(Z(i));
  copy(vz.begin(), vz.end(), out);
  cout &lt;&lt; endl;
  apply(vz, &amp;Z::g);
  copy(vz.begin(), vz.end(), out);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because <B>operator-&gt;</B> is defined
for STL iterators, it can be used for pointer-to-member dereferencing (in the
following chapter you&#8217;ll learn a more elegant way to handle the problem of
applying a member function or ordinary function to every object in a
container).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I70">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I71"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Much of the time, this is all you need to
know about iterators &#8211; that they are produced by <B>begin(&#160;)</B> and
<B>end(&#160;)</B>, and that you can use them to move through a container and
select elements. Many of the problems that you solve, and the STL algorithms
(covered in the next chapter) will allow you to just flail away with the basics
of iterators. However, things can at times become more subtle, and in those
cases you need to know more about iterators. The rest of this section gives you
the
details.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I71">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I72"></a>
</FONT><A NAME="_Toc519042017"></A><BR></P></DIV>
<A NAME="Heading196"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Iterators in reversible containers</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All containers must produce the basic
<B>iterator</B>. A container may also be <I>reversible</I>, which means that it
can produce iterators that move backwards from the end, as well as the iterators
that move forward from the
beginning.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I72">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I73"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A reversible container has the methods
<B>rbegin(&#160;)</B> (to produce a <B>reverse_iterator</B> selecting the end)
and <B>rend(&#160;)</B> (to produce a <B>reverse_iterator</B> indicating
&#8220;one past the beginning&#8221;). If the container is <B>const</B> then
<B>rbegin(&#160;)</B> and <B>rend(&#160;)</B> will produce
<B>const_reverse_iterator</B>s.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I73">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I74"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All the basic sequence containers
<B>vector</B>, <B>deque</B> and <B>list</B> are reversible containers. The
following example uses <B>vector</B>, but will work with <B>deque</B> and
<B>list</B> as well:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I74">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I75"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:Reversible.cpp</font>
<font color=#009900>// Using reversible containers</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  ifstream in(<font color=#004488>"Reversible.cpp"</font>);
  assure(in, <font color=#004488>"Reversible.cpp"</font>);
  string line;
  vector&lt;string&gt; lines;
  <font color=#0000ff>while</font>(getline(in, line))
    lines.push_back(line);
  vector&lt;string&gt;::reverse_iterator r;
  <font color=#0000ff>for</font>(r = lines.rbegin(); r != lines.rend(); r++)
    cout &lt;&lt; *r &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You move backward through the container
using the same syntax as moving forward through a container with an ordinary
iterator.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I75">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I76"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The associative containers <B>set</B>,
<B>multiset</B>, <B>map</B> and <B>multimap</B> are also reversible. Using
iterators with associative containers is a bit different, however, and will be
delayed until those containers are more fully
introduced.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I76">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I77"></a>
</FONT><A NAME="_Toc519042018"></A><BR></P></DIV>
<A NAME="Heading197"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Iterator categories</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The iterators are classified into
different &#8220;categories&#8221; which describe what they are capable of
doing. The order in which they are generally described moves from the categories
with the most restricted behavior to those with the most powerful
behavior.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I77">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I78"></a>
</FONT><BR></P></DIV>
<A NAME="Heading198"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Input: read-only, one pass</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The only predefined implementations of
input iterators are <B>istream_iterator</B> and <B>istreambuf_iterator</B>, to
read from an <B>istream</B>. As you can imagine, an input iterator can only be
dereferenced once for each element that&#8217;s selected, just as you can only
read a particular portion of an input stream once. They can only move forward.
There is a special constructor to define the past-the-end value. In summary, you
can dereference it for reading (once only for each value), and move it
forward.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I78">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I79"></a>
</FONT><BR></P></DIV>
<A NAME="Heading199"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Output: write-only, one pass</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is the complement of an input
iterator, but for writing rather than reading. The only predefined
implementations of output iterators are <B>ostream_iterator</B> and
<B>ostreambuf_iterator</B>, to write to an <B>ostream</B>, and the
less-commonly-used <B>raw_storage_iterator</B>. Again, these can only be
dereferenced once for each written value, and they can only move forward. There
is no concept of a terminal past-the-end value for an output iterator.
Summarizing, you can dereference it for writing (once only for each value) and
move it forward.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I79">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I80"></a>
</FONT><BR></P></DIV>
<A NAME="Heading200"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Forward: multiple read/write</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The forward iterator contains all the
functionality of both the input iterator and the output iterator, plus you can
dereference an iterator location multiple times, so you can read and write to a
value multiple times. As the name implies, you can only move forward. There are
no predefined iterators that are only forward
iterators.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I80">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I81"></a>
</FONT><BR></P></DIV>
<A NAME="Heading201"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Bidirectional: operator--</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The bidirectional iterator has all the
functionality of the forward iterator, and in addition it can be moved backwards
one location at a time using
<B>operator--</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I81">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I82"></a>
</FONT><BR></P></DIV>
<A NAME="Heading202"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Random-access: like a pointer</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Finally, the random-access iterator has
all the functionality of the bidirectional iterator plus all the functionality
of a pointer (a pointer <I>is</I> a random-access iterator). Basically, anything
you can do with a pointer you can do with a random-access iterator, including
indexing with <B>operator[ ]</B>, adding integral values to a pointer to move it
forward or backward by a number of locations, and comparing one iterator to
another with <B>&lt;</B>, <B>&gt;=</B>,<B>
</B>etc.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I82">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I83"></a>
</FONT><BR></P></DIV>
<A NAME="Heading203"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Is this really important?</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Why do you care about this
categorization? When you&#8217;re just using containers in a straightforward way
(for example, just hand-coding all the operations you want to perform on the
objects in the container) it usually doesn&#8217;t impact you too much. Things
either work or they don&#8217;t. The iterator categories become important
when:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I83">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I84"></a>
</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">You use some of the
fancier built-in iterator types that will be demonstrated shortly. Or you
graduate to creating your own iterators (this will also be demonstrated, later
in this
chapter).</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">You use
the STL algorithms (the subject of the next chapter). Each of the algorithms
have requirements that they place on the iterators that they work with.
Knowledge of the iterator categories is even more important when you create your
own reusable algorithm templates, because the iterator category that your
algorithm requires determines how flexible the algorithm will be. If you only
require the most primitive iterator category (input or output) then your
algorithm will work with <I>everything</I> (<B>copy(&#160;)</B> is an example of
this).</FONT><A NAME="_Toc519042019"></A></OL><A NAME="Heading204"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Predefined iterators</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The STL has a predefined set of iterator
classes that can be quite handy. For example, you&#8217;ve already seen
<B>reverse_iterator</B> (produced by calling <B>rbegin(&#160;)</B> and
<B>rend(&#160;)</B> for all the basic
containers).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I84">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I85"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <I>insertion iterators</I> are
necessary because some of the STL algorithms &#8211; <B>copy(&#160;)</B> for
example &#8211; use the assignment <B>operator=</B> in order to place objects in
the destination container. This is a problem when you&#8217;re using the
algorithm to <I>fill</I> the container rather than to overwrite items that are
already in the destination container. That is, when the space isn&#8217;t
already there. What the insert iterators do is change the implementation of the
<B>operator=</B> so that instead of doing an assignment, it calls a
&#8220;push&#8221; or &#8220;insert&#8221; function for that container, thus
causing it to allocate new space. The constructors for both
<B>back_insert_iterator</B> and <B>front_insert_iterator</B> take a basic
sequence container object (<B>vector</B>,<B> deque</B> or <B>list</B>) as their
argument and produce an iterator that calls <B>push_back(&#160;)</B> or
<B>push_front(&#160;)</B>, respectively, to perform assignment. The shorthand
functions <B>back_inserter(&#160;)</B> and <B>front_inserter(&#160;)</B> produce
the same objects with a little less typing. Since all the basic sequence
containers support <B>push_back(&#160;)</B>, you will probably find yourself
using <B>back_inserter(&#160;)</B> with some
regularity.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I85">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I86"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>insert_iterator</B> allows you to
insert elements in the middle of the sequence, again replacing the meaning of
<B>operator=</B>, but this time with <B>insert(&#160;)</B> instead of one of the
&#8220;push&#8221; functions. The <B>insert(&#160;)</B> member function requires
an iterator indicating the place to insert before, so the <B>insert_iterator</B>
requires this iterator in addition to the container object. The shorthand
function <B>inserter(&#160;)</B> produces the same
object.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I86">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I87"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example shows the use of
the different types of
inserters:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I87">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I88"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:Inserters.cpp</font>
<font color=#009900>// Different types of iterator inserters</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;list&gt;
#include &lt;iterator&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> a[] = { 1, 3, 5, 7, 11, 13, 17, 19, 23 };

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> Cont&gt;
<font color=#0000ff>void</font> frontInsertion(Cont&amp; ci) {
  copy(a, a + <font color=#0000ff>sizeof</font>(a)/<font color=#0000ff>sizeof</font>(<font color=#0000ff>int</font>), 
    front_inserter(ci));
  copy(ci.begin(), ci.end(),
    ostream_iterator&lt;<font color=#0000ff>int</font>&gt;(cout, <font color=#004488>" "</font>));
  cout &lt;&lt; endl;
}

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> Cont&gt;
<font color=#0000ff>void</font> backInsertion(Cont&amp; ci) {
  copy(a, a + <font color=#0000ff>sizeof</font>(a)/<font color=#0000ff>sizeof</font>(<font color=#0000ff>int</font>), 
    back_inserter(ci));
  copy(ci.begin(), ci.end(),
    ostream_iterator&lt;<font color=#0000ff>int</font>&gt;(cout, <font color=#004488>" "</font>));
  cout &lt;&lt; endl;
}

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> Cont&gt;
<font color=#0000ff>void</font> midInsertion(Cont&amp; ci) {
  <font color=#0000ff>typename</font> Cont::iterator it = ci.begin();
  it++; it++; it++;
  copy(a, a + <font color=#0000ff>sizeof</font>(a)/(<font color=#0000ff>sizeof</font>(<font color=#0000ff>int</font>) * 2),
    inserter(ci, it));
  copy(ci.begin(), ci.end(),
    ostream_iterator&lt;<font color=#0000ff>int</font>&gt;(cout, <font color=#004488>" "</font>));
  cout &lt;&lt; endl;
}

<font color=#0000ff>int</font> main() {
  deque&lt;<font color=#0000ff>int</font>&gt; di;
  list&lt;<font color=#0000ff>int</font>&gt;  li;
  vector&lt;<font color=#0000ff>int</font>&gt; vi;
  <font color=#009900>// Can't use a front_inserter() with vector</font>
  frontInsertion(di);
  frontInsertion(li);
  di.clear();
  li.clear();
  backInsertion(vi);
  backInsertion(di);
  backInsertion(li);
  midInsertion(vi);
  midInsertion(di);
  midInsertion(li);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since <B>vector</B> does not support
<B>push_front(&#160;)</B>, it cannot produce a <B>front_insertion_iterator</B>.
However, you can see that <B>vector</B> does support the other two types of
insertion (even though, as you shall see later, <B>insert(&#160;)</B> is not a
very efficient operation for
<B>vector</B>).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I88">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I89"></a>
</FONT><BR></P></DIV>
<A NAME="Heading205"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
IO stream iterators</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ve already seen some use of the
<B>ostream_iterator</B> (an output iterator) in conjunction with
<B>copy(&#160;)</B> to place the contents of a container on an output stream.
There is a corresponding <B>istream_iterator</B> (an input iterator) which
allows you to &#8220;iterate&#8221; a set of objects of a specified type from an
input stream. An important difference between <B>ostream_iterator</B> and
<B>istream_iterator</B> comes from the fact that an output stream doesn&#8217;t
have any concept of an &#8220;end,&#8221; since you can always just keep writing
more elements. However, an input stream eventually terminates (for example, when
you reach the end of a file) so there needs to be a way to represent that. An
<B>istream_iterator</B> has two constructors, one that takes an <B>istream</B>
and produces the iterator you actually read from, and the other which is the
default constructor and produces an object which is the past-the-end sentinel.
In the following program this object is named
<B>end</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I89">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I90"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:StreamIt.cpp</font>
<font color=#009900>// Iterators for istreams and ostreams</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-msc}</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  ifstream in(<font color=#004488>"StreamIt.cpp"</font>);
  assure(in, <font color=#004488>"StreamIt.cpp"</font>);
  istream_iterator&lt;string&gt; init(in), end;
  ostream_iterator&lt;string&gt; out(cout, <font color=#004488>"\n"</font>);
  vector&lt;string&gt; vs;
  copy(init, end, back_inserter(vs));
  copy(vs.begin(), vs.end(), out);
  *out++ = vs[0];
  *out++ = <font color=#004488>"That's all, folks!"</font>;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When <B>in</B> runs out of input (in this
case when the end of the file is reached) then <B>init</B> becomes equivalent to
<B>end</B> and the <B>copy(&#160;)</B>
terminates.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I90">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I91"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because <B>out</B> is an
<B>ostream_iterator&lt;string&gt;</B>, you can simply assign any <B>string</B>
object to the dereferenced iterator using <B>operator=</B> and that
<B>string</B> will be placed on the output stream, as seen in the two
assignments to <B>out</B>. Because <B>out</B> is defined with a newline as its
second argument, these assignments also cause a newline to be inserted along
with each assignment.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I91">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I92"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">While it is possible to create an
<B>istream_iterator&lt;char&gt;</B> and <B>ostream_iterator&lt;char&gt;</B>,
these actually <I>parse </I>the input and thus will for example automatically
eat whitespace (spaces, tabs and newlines), which is not desirable if you want
to manipulate an exact representation of an <B>istream</B>. Instead, you can use
the special iterators <B>istreambuf_iterator</B> and <B>ostreambuf_iterator</B>,
which are designed strictly to move
characters</FONT><A NAME="fnB20" HREF="#fn20">[20]</A><FONT FACE="Georgia">.
Although these are templates, the only template arguments they will accept are
either <B>char</B> or <B>wchar_t</B> (for wide characters). The following
example allows you to compare the behavior of the stream iterators vs. the
streambuf iterators:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I92">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I93"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:StreambufIterator.cpp</font>
<font color=#009900>// istreambuf_iterator &amp; ostreambuf_iterator</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-g++295} </font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  ifstream in(<font color=#004488>"StreambufIterator.cpp"</font>);
  assure(in, <font color=#004488>"StreambufIterator.cpp"</font>);
  <font color=#009900>// Exact representation of stream:</font>
  istreambuf_iterator&lt;<font color=#0000ff>char</font>&gt; isb(in), end;
  ostreambuf_iterator&lt;<font color=#0000ff>char</font>&gt; osb(cout);
  <font color=#0000ff>while</font>(isb != end)
    *osb++ = *isb++; <font color=#009900>// Copy 'in' to cout</font>
  cout &lt;&lt; endl;
  ifstream in2(<font color=#004488>"StreambufIterator.cpp"</font>);
  <font color=#009900>// Strips white space:</font>
  istream_iterator&lt;<font color=#0000ff>char</font>&gt; is(in2), end2;
  ostream_iterator&lt;<font color=#0000ff>char</font>&gt; os(cout);
  <font color=#0000ff>while</font>(is != end2)
    *os++ = *is++;
  cout &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The stream iterators use the parsing
defined by <B>istream::operator&gt;&gt;</B>, which is probably
not</FONT><BR><FONT FACE="Georgia">what you want if you are parsing characters
directly &#8211; it&#8217;s fairly rare that you would want all the whitespace
stripped out of your character stream. You&#8217;ll virtually always want to use
a streambuf iterator when using characters and streams, rather than a stream
iterator. In addition, <B>istream::operator&gt;&gt;</B> adds significant
overhead for each operation, so it is only appropriate for higher-level
operations such as parsing floating-point
numbers.</FONT><A NAME="fnB21" HREF="#fn21">[21]</A><FONT FACE="Georgia">
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I93">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I94"></a>
</FONT><BR></P></DIV>
<A NAME="Heading206"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
Manipulating raw storage</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is a little more esoteric and is
generally used in the implementation of other Standard Library functions, but it
is nonetheless interesting. The <B>raw_storage_iterator</B> is defined in
<B>&lt;algorithm&gt;</B> and is an output iterator. It is provided to enable
algorithms to store their results into uninitialized memory. The interface is
quite simple: the constructor takes an output iterator that is pointing to the
raw memory (thus it is typically a pointer) and the <B>operator=</B> assigns an
object into that raw memory. The template parameters are the type of the output
iterator pointing to the raw storage, and the type of object that will be
stored. Here&#8217;s an example which creates <B>Noisy</B> objects (you&#8217;ll
be introduced to the <B>Noisy</B> class shortly; it&#8217;s not necessary to
know its details for this
example):
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I94">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I95"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:RawStorageIterator.cpp</font>
<font color=#009900>// Demonstrate the raw_storage_iterator</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-g++295} </font>
#include <font color=#004488>"Noisy.h"</font>
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> quantity = 10;
  <font color=#009900>// Create raw storage and cast to desired type:</font>
  Noisy* np = 
    (Noisy*)<font color=#0000ff>new</font> <font color=#0000ff>char</font>[quantity * <font color=#0000ff>sizeof</font>(Noisy)];
  raw_storage_iterator&lt;Noisy*, Noisy&gt; rsi(np);
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; quantity; i++)
    *rsi++ = Noisy(); <font color=#009900>// Place objects in storage</font>
  cout &lt;&lt; endl;
  copy(np, np + quantity,
    ostream_iterator&lt;Noisy&gt;(cout, <font color=#004488>" "</font>));
  cout &lt;&lt; endl;
  <font color=#009900>// Explicit destructor call for cleanup:</font>
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; quantity; j++)
    (&amp;np[j])-&gt;~Noisy();
  <font color=#009900>// Release raw storage:</font>
  <font color=#0000ff>delete</font> (<font color=#0000ff>char</font>*)np;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To make the <B>raw_storage_iterator
</B>template happy, the raw storage must be of the same type as the objects
you&#8217;re creating. That&#8217;s why the pointer from the new array of
<B>char</B> is cast to a <B>Noisy*</B>. The assignment operator forces the
objects into the raw storage using the copy-constructor. Note that the explicit
destructor call must be made for proper cleanup, and this also allows the
objects to be deleted one at a time during container
manipulation.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I95">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I96"></a>
</FONT><A NAME="_Toc519042020"></A><BR></P></DIV>
<A NAME="Heading207"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Basic sequences: <BR>vector, list &amp; deque</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you take a step back from the STL
containers you&#8217;ll see that there are really only two types of container:
<I>sequences</I> (including <B>vector</B>, <B>list</B>, <B>deque</B>,
<B>stack</B>, <B>queue</B>, and <B>priority_queue</B>)<B> </B>and
<I>associations</I> (including <B>set</B>, <B>multiset</B>, <B>map</B> and
<B>multimap</B>). The sequences keep the objects in whatever sequence that you
establish (either by pushing the objects on the end or inserting them in the
middle).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I96">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I97"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since all the sequence containers have
the same basic goal (to maintain your order) they seem relatively
interchangeable. However, they differ in the efficiency of their operations, so
if you are going to manipulate a sequence in a particular fashion you can choose
the appropriate container for those types of manipulations. The
&#8220;basic&#8221; sequence containers are <B>vector</B>, <B>list</B> and
<B>deque</B> &#8211; these actually have fleshed-out implementations, while
<B>stack</B>, <B>queue</B> and <B>priority_queue</B> are built on top of the
basic sequences, and represent more specialized uses rather than differences in
underlying structure (<B>stack</B>, for example, can be implemented using a
<B>deque</B>, <B>vector</B> or
<B>list</B>).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I97">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I98"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So far in this book I have been using
<B>vector</B> as a catch-all container. This was acceptable because I&#8217;ve
only used the simplest and safest operations, primarily <B>push_back(&#160;)</B>
and <B>operator[ ]</B>. However, when you start making more sophisticated uses
of containers it becomes important to know more about their underlying
implementations and behavior, so you can make the right choices (and, as
you&#8217;ll see, stay out of
trouble).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I98">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I99"></a>
</FONT><A NAME="_Toc519042021"></A><BR></P></DIV>
<A NAME="Heading208"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Basic sequence operations</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Using a template, the following example
shows the operations that all the basic sequences (<B>vector</B>, <B>deque</B>
or <B>list</B>) support. As you shall learn in the sections on the specific
sequence containers, not all of these operations make sense for each basic
sequence, but they are supported.

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I99">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I100"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:BasicSequenceOperations.cpp</font>
<font color=#009900>// The operations available for all the </font>
<font color=#009900>// basic sequence Containers.</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-msc}</font>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;list&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>template</font>&lt;<font color=#0000ff>typename</font> Container&gt;
<font color=#0000ff>void</font> print(Container&amp; c, <font color=#0000ff>char</font>* s = <font color=#004488>""</font>) {
  cout &lt;&lt; s &lt;&lt; <font color=#004488>":"</font> &lt;&lt; endl;
  <font color=#0000ff>if</font>(c.empty()) {
    cout &lt;&lt; <font color=#004488>"(empty)"</font> &lt;&lt; endl;
    <font color=#0000ff>return</font>;
  }
  <font color=#0000ff>typename</font> Container::iterator it;
  <font color=#0000ff>for</font>(it = c.begin(); it != c.end(); it++)
    cout &lt;&lt; *it &lt;&lt; <font color=#004488>" "</font>;
  cout &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"size() "</font> &lt;&lt; c.size() 
    &lt;&lt; <font color=#004488>" max_size() "</font>&lt;&lt; c.max_size() 
    &lt;&lt; <font color=#004488>" front() "</font> &lt;&lt; c.front()
    &lt;&lt; <font color=#004488>" back() "</font> &lt;&lt; c.back() &lt;&lt; endl;
}
  
<font color=#0000ff>template</font>&lt;<font color=#0000ff>typename</font> ContainerOfInt&gt;
<font color=#0000ff>void</font> basicOps(<font color=#0000ff>char</font>* s) {
  cout &lt;&lt; <font color=#004488>"------- "</font> &lt;&lt; s &lt;&lt; <font color=#004488>" -------"</font> &lt;&lt; endl;
  <font color=#0000ff>typedef</font> ContainerOfInt Ci;
  Ci c;
  print(c, <font color=#004488>"c after default constructor"</font>);
  Ci c2(10, 1); <font color=#009900>// 10 elements, values all 1</font>
  print(c2, <font color=#004488>"c2 after constructor(10,1)"</font>);
  <font color=#0000ff>int</font> ia[] = { 1, 3, 5, 7, 9 };
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> iasz = <font color=#0000ff>sizeof</font>(ia)/<font color=#0000ff>sizeof</font>(*ia);
  <font color=#009900>// Initialize with begin &amp; end iterators:</font>
  Ci c3(ia, ia + iasz);
  print(c3, <font color=#004488>"c3 after constructor(iter,iter)"</font>);
  Ci c4(c2); <font color=#009900>// Copy-constructor</font>
  print(c4, <font color=#004488>"c4 after copy-constructor(c2)"</font>);
  c = c2; <font color=#009900>// Assignment operator</font>
  print(c, <font color=#004488>"c after operator=c2"</font>);
  c.assign(10, 2); <font color=#009900>// 10 elements, values all 2</font>
  print(c, <font color=#004488>"c after assign(10, 2)"</font>);
  <font color=#009900>// Assign with begin &amp; end iterators:</font>
  c.assign(ia, ia + iasz);
  print(c, <font color=#004488>"c after assign(iter, iter)"</font>);
  cout &lt;&lt; <font color=#004488>"c using reverse iterators:"</font> &lt;&lt; endl;
  <font color=#0000ff>typename</font> Ci::reverse_iterator rit = c.rbegin();
  <font color=#0000ff>while</font>(rit != c.rend())
    cout &lt;&lt; *rit++ &lt;&lt; <font color=#004488>" "</font>;
  cout &lt;&lt; endl;
  c.resize(4);
  print(c, <font color=#004488>"c after resize(4)"</font>);
  c.push_back(47);
  print(c, <font color=#004488>"c after push_back(47)"</font>);
  c.pop_back();
  print(c, <font color=#004488>"c after pop_back()"</font>);
  <font color=#0000ff>typename</font> Ci::iterator it = c.begin();
  it++; it++;
  c.insert(it, 74);
  print(c, <font color=#004488>"c after insert(it, 74)"</font>);
  it = c.begin();
  it++;
  c.insert(it, 3, 96);
  print(c, <font color=#004488>"c after insert(it, 3, 96)"</font>);
  it = c.begin();
  it++;
  c.insert(it, c3.begin(), c3.end());
  print(c, <font color=#004488>"c after insert("</font>
    <font color=#004488>"it, c3.begin(), c3.end())"</font>);
  it = c.begin();
  it++;
  c.erase(it);
  print(c, <font color=#004488>"c after erase(it)"</font>);
  <font color=#0000ff>typename</font> Ci::iterator it2 = it = c.begin();
  it++;
  it2++; it2++; it2++; it2++; it2++;
  c.erase(it, it2);
  print(c, <font color=#004488>"c after erase(it, it2)"</font>);
  c.swap(c2);
  print(c, <font color=#004488>"c after swap(c2)"</font>);
  c.clear();
  print(c, <font color=#004488>"c after clear()"</font>);
}

<font color=#0000ff>int</font> main() {
  basicOps&lt;vector&lt;<font color=#0000ff>int</font>&gt; &gt;(<font color=#004488>"vector"</font>);
  basicOps&lt;deque&lt;<font color=#0000ff>int</font>&gt; &gt;(<font color=#004488>"deque"</font>);
  basicOps&lt;list&lt;<font color=#0000ff>int</font>&gt; &gt;(<font color=#004488>"list"</font>);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first function template,
<B>print(&#160;)</B>, demonstrates the basic information you can get from any
sequence container: whether it&#8217;s empty, its current size, the size of the
largest possible container, the element at the beginning and the element at the
end. You can also see that every container has <B>begin(&#160;)</B> and
<B>end(&#160;)</B> methods that return
iterators.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I100">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I101"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>basicOps(&#160;)</B> function
tests everything else (and in turn calls <B>print(&#160;)</B>), including a
variety of constructors: default, copy-constructor, quantity and initial value,
and beginning and ending iterators. There&#8217;s an assignment <B>operator=</B>
and two kinds of <B>assign(&#160;)</B> member functions, one which takes a
quantity and initial value and the other which take a beginning and ending
iterator.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I101">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I102"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All the basic sequence containers are
reversible containers, as shown by the use of the <B>rbegin(&#160;)</B> and
<B>rend(&#160;)</B> member functions. A sequence container can be resized, and
the entire contents of the container can be removed with
<B>clear(&#160;)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I102">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I103"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Using an iterator to indicate where you
want to start inserting into any sequence container, you can
<B>insert(&#160;)</B> a single element, a number of elements that all have the
same value, and a group of elements from another container using the beginning
and ending iterators of that group.

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I103">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I104"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To <B>erase(&#160;)</B> a single element
from the middle, use an iterator; to <B>erase(&#160;)</B> a range of elements,
use a pair of iterators. Notice that since a <B>list</B> only supports
bidirectional iterators, all the iterator motion must be performed with
increments and decrements (if the containers were limited to <B>vector </B>and
<B>deque</B>, which produce random-access iterators, then <B>operator+</B> and
<B>operator-</B> could have been used to move the iterators in big
jumps).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I104">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I105"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although both <B>list</B> and
<B>deque</B> support <B>push_front(&#160;)</B> and <B>pop_front(&#160;)</B>,
<B>vector</B> does not, so the only member functions that work with all three
are <B>push_back(&#160;)</B> and
<B>pop_back(&#160;)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I105">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I106"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The naming of the member function
<B>swap(&#160;)</B> is a little confusing, since there&#8217;s also a non-member
<B>swap(&#160;)</B> algorithm that switches two elements of a container. The
member <B>swap(&#160;)</B>, however, swaps <I>everything</I> in one container
for another (if the containers hold the same type), effectively swapping the
containers themselves. There&#8217;s also a non-member version of this
function.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I106">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I107"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following sections on the sequence
containers discuss the particulars of each type of
container.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I107">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I108"></a>
</FONT><A NAME="_Toc519042022"></A><BR></P></DIV>
<A NAME="Heading209"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
vector</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>vector</B> is intentionally made
to look like a souped-up array, since it has array-style indexing but also can
expand dynamically. <B>vector</B> is so fundamentally useful that it was
introduced in a very primitive way early in this book, and used quite regularly
in previous examples. This section will give a more in-depth look at
<B>vector</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I108">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I109"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To achieve maximally-fast indexing and
iteration, the <B>vector</B> maintains its storage as a single contiguous array
of objects. This is a critical point to observe in understanding the behavior of
<B>vector</B>. It means that indexing and iteration are lighting-fast, being
basically the same as indexing and iterating over an array of objects. But it
also means that inserting an object anywhere but at the end (that is, appending)
is not really an acceptable operation for a <B>vector</B>. It also means that
when a <B>vector</B> runs out of pre-allocated storage, in order to maintain its
contiguous array it must allocate a whole new (larger) chunk of storage
elsewhere and copy the objects to the new storage. This has a number of
unpleasant side
effects.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I109">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I110"></a>
</FONT><A NAME="_Toc519042023"></A><BR></P></DIV>
<A NAME="Heading210"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Cost of overflowing allocated storage</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>vector </B>starts by grabbing a
block of storage, as if it&#8217;s taking a guess at how many objects you plan
to put in it. As long as you don&#8217;t try to put in more objects than can be
held in the initial block of storage, everything is very rapid and efficient
(note that if you <I>do </I>know how many objects to expect, you can
pre-allocate storage using <B>reserve(&#160;)</B>). But eventually you will put
in one too many objects and, unbeknownst to you, the <B>vector </B>responds
by:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I110">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I111"></a>
</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Allocating a new, bigger
piece of
storage</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Copying all
the objects from the old storage to the new (using the
copy-constructor)</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Destroying
all the old objects (the destructor is called for each
one)</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Releasing the
old memory</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For complex
objects, this copy-construction and destruction can end up being very expensive
if you overfill your vector a lot. To see what happens when you&#8217;re filling
a <B>vector</B>, here is a class that prints out information about its
creations, destructions, assignments and
copy-constructions:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I111">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I112"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:Noisy.h</font>
<font color=#009900>// A class to track various object activities</font>
#ifndef NOISY_H
#define NOISY_H
#include &lt;iostream&gt;

<font color=#0000ff>class</font> Noisy {
  <font color=#0000ff>static</font> <font color=#0000ff>long</font> create, assign, copycons, destroy;
  <font color=#0000ff>long</font> id;
<font color=#0000ff>public</font>:
  Noisy() : id(create++) { 
    std::cout &lt;&lt; <font color=#004488>"d["</font> &lt;&lt; id &lt;&lt; <font color=#004488>"]"</font>; 
  }
  Noisy(<font color=#0000ff>const</font> Noisy&amp; rv) : id(rv.id) {
    std::cout &lt;&lt; <font color=#004488>"c["</font> &lt;&lt; id &lt;&lt; <font color=#004488>"]"</font>;
    copycons++;
  }
  Noisy&amp; <font color=#0000ff>operator</font>=(<font color=#0000ff>const</font> Noisy&amp; rv) {
    std::cout &lt;&lt; <font color=#004488>"("</font> &lt;&lt; id &lt;&lt; <font color=#004488>")=["</font> &lt;&lt;
      rv.id &lt;&lt; <font color=#004488>"]"</font>;
    id = rv.id;
    assign++;
    <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
  }
  <font color=#0000ff>friend</font> <font color=#0000ff>bool</font> 
  <font color=#0000ff>operator</font>&lt;(<font color=#0000ff>const</font> Noisy&amp; lv, <font color=#0000ff>const</font> Noisy&amp; rv) {
    <font color=#0000ff>return</font> lv.id &lt; rv.id;
  }
  <font color=#0000ff>friend</font> <font color=#0000ff>bool</font> 
  <font color=#0000ff>operator</font>==(<font color=#0000ff>const</font> Noisy&amp; lv, <font color=#0000ff>const</font> Noisy&amp; rv) {
    <font color=#0000ff>return</font> lv.id == rv.id;
  }
  ~Noisy() {
    std::cout &lt;&lt; <font color=#004488>"~["</font> &lt;&lt; id &lt;&lt; <font color=#004488>"]"</font>;
    destroy++;
  }
  <font color=#0000ff>friend</font> std::ostream&amp; 
  <font color=#0000ff>operator</font>&lt;&lt;(std::ostream&amp; os, <font color=#0000ff>const</font> Noisy&amp; n) {
    <font color=#0000ff>return</font> os &lt;&lt; n.id;
  }
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> NoisyReport;
};

<font color=#0000ff>struct</font> NoisyGen {
  Noisy <font color=#0000ff>operator</font>()() { <font color=#0000ff>return</font> Noisy(); }
};

<font color=#009900>// A singleton. Will automatically report the</font>
<font color=#009900>// statistics as the program terminates:</font>
<font color=#0000ff>class</font> NoisyReport {
  <font color=#0000ff>static</font> NoisyReport nr;
  NoisyReport() {} <font color=#009900>// Private constructor</font>
<font color=#0000ff>public</font>:
  ~NoisyReport() {
    std::cout &lt;&lt; <font color=#004488>"\n-------------------\n"</font>
      &lt;&lt; <font color=#004488>"Noisy creations: "</font> &lt;&lt; Noisy::create
      &lt;&lt; <font color=#004488>"\nCopy-Constructions: "</font> 
      &lt;&lt; Noisy::copycons
      &lt;&lt; <font color=#004488>"\nAssignments: "</font> &lt;&lt; Noisy::assign
      &lt;&lt; <font color=#004488>"\nDestructions: "</font> &lt;&lt; Noisy::destroy
      &lt;&lt; std::endl;
  }
};

<font color=#009900>// Because of these this file can only be used</font>
<font color=#009900>// in simple test situations. Move them to a </font>
<font color=#009900>// .cpp file for more complex programs:</font>
<font color=#0000ff>long</font> Noisy::create = 0, Noisy::assign = 0,
  Noisy::copycons = 0, Noisy::destroy = 0;
NoisyReport NoisyReport::nr;
#endif <font color=#009900>// NOISY_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each <B>Noisy</B> object has its own
identifier, and there are <B>static</B> variables to keep track of all the
creations, assignments (using <B>operator=</B>), copy-constructions and
destructions. The <B>id</B> is initialized using the <B>create</B> counter
inside the default constructor; the copy-constructor and assignment operator
take their <B>id</B> values from the rvalue. Of course, with <B>operator=</B>
the lvalue is already an initialized object so the old value of <B>id</B> is
printed before it is overwritten with the <B>id</B> from the
rvalue.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I112">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I113"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In order to support certain operations
like sorting and searching (which are used implicitly by some of the
containers), <B>Noisy</B> must have an <B>operator&lt;</B> and
<B>operator==</B>. These simply compare the <B>id</B> values. The
<B>operator&lt;&lt;</B> for <B>ostream</B> follows the standard form and simply
prints the <B>id</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I113">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I114"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>NoisyGen</B> produces a function
object (since it has an <B>operator(&#160;)</B>) that is used to automatically
generate <B>Noisy</B> objects during
testing.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I114">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I115"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>NoisyReport</B> is a type of class
called a <I>singleton</I>, which is a &#8220;design pattern&#8221; (these are
covered more fully in Chapter XX). Here, the goal is to make sure there is one
and only one <B>NoisyReport</B> object, because it is responsible for printing
out the results at program termination. It has a <B>private</B> constructor so
no one else can make a <B>NoisyReport</B> object, and a single static instance
of <B>NoisyReport</B> called <B>nr</B>. The only executable statements are in
the destructor, which is called as the program exits and the static destructors
are called; this destructor prints out the statistics captured by the
<B>static</B> variables in
<B>Noisy</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I115">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I116"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The one snag to this header file is the
inclusion of the definitions for the <B>static</B>s at the end. If you include
this header in more than one place in your project, you&#8217;ll get
multiple-definition errors at link time. Of course, you can put the
<B>static</B> definitions in a separate<B> cpp</B> file and link it in, but that
is less convenient, and since <B>Noisy</B> is just intended for quick-and-dirty
experiments the header file should be reasonable for most
situations.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I116">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I117"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Using <B>Noisy.h</B>, the following
program will show the behaviors that occur when a <B>vector</B> overflows its
currently allocated
storage:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I117">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I118"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:VectorOverflow.cpp</font>
<font color=#009900>// Shows the copy-construction and destruction</font>
<font color=#009900>// That occurs when a vector must reallocate</font>
<font color=#009900>// (It maintains a linear array of elements)</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"Noisy.h"</font>
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  <font color=#0000ff>int</font> size = 1000;
  <font color=#0000ff>if</font>(argc &gt;= 2) size = atoi(argv[1]);
  vector&lt;Noisy&gt; vn;
  Noisy n;
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; size; i++)
    vn.push_back(n);
  cout &lt;&lt; <font color=#004488>"\n cleaning up \n"</font>;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can either use the default value of
1000, or use your own value by putting it on the
command-line.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I118">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I119"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you run this program, you&#8217;ll
see a single default constructor call (for <B>n</B>), then a lot of
copy-constructor calls, then some destructor calls, then some more
copy-constructor calls, and so on. When the vector runs out of space in the
linear array of bytes it has allocated, it must (to maintain all the objects in
a linear array, which is an essential part of its job) get a bigger piece of
storage and move everything over, copying first and then destroying the old
objects. You can imagine that if you store a lot of large and complex objects,
this process could rapidly become
prohibitive.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I119">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I120"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are two solutions to this problem.
The nicest one requires that you know beforehand how many objects you&#8217;re
going to make. In that case you can use <B>reserve(&#160;)</B> to tell the
vector how much storage to pre-allocate, thus eliminating all the copies and
destructions and making everything very fast (especially random access to the
objects with <B>operator[ ]</B>). Note that the use of <B>reserve(&#160;)</B> is
different from using the <B>vector</B> constructor with an integral first
argument; the latter initializes each element using the default
copy-constructor.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I120">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I121"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">However, in the more general case you
won&#8217;t know how many objects you&#8217;ll need. If <B>vector</B>
reallocations are slowing things down, you can change sequence containers. You
could use a <B>list</B>, but<B> </B>as you&#8217;ll see, the <B>deque</B> allows
speedy insertions at either end of the sequence, and never needs to copy or
destroy objects as it expands its storage. The <B>deque</B> also allows random
access with <B>operator[ ]</B>, but it&#8217;s not quite as fast as
<B>vector</B>&#8217;s <B>operator[</B> <B>]</B>. So in the case where
you&#8217;re creating all your objects in one part of the program and randomly
accessing them in another, you may find yourself filling a <B>deque</B>, then
creating a <B>vector</B> from the <B>deque</B> and using the <B>vector</B> for
rapid indexing. Of course, you don&#8217;t want to program this way habitually,
just be aware of these issues (avoid premature
optimization).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I121">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I122"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There is a darker side to
<B>vector</B>&#8217;s reallocation of memory, however. Because <B>vector</B>
keeps its objects in a nice, neat array (allowing, for one thing, maximally-fast
random access), the iterators used by <B>vector</B> are generally just pointers.
This is a good thing &#8211; of all the sequence containers, these pointers
allow the fastest selection and manipulation. However, consider what happens
when you&#8217;re holding onto an iterator (i.e. a pointer) and then you add the
one additional object that causes the <B>vector</B> to reallocate storage and
move it elsewhere. Your pointer is now pointing off into
nowhere:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I122">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I123"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:VectorCoreDump.cpp</font>
<font color=#009900>// How to break a program using a vector</font>
<font color=#009900>//{-msc}</font>
<font color=#009900>//{-bor}</font>
<font color=#009900>//{-g++3}</font>
#include &lt;vector&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  vector&lt;<font color=#0000ff>int</font>&gt; vi(10, 0);
  ostream_iterator&lt;<font color=#0000ff>int</font>&gt; out(cout, <font color=#004488>" "</font>);
  copy(vi.begin(), vi.end(), out);
  vector&lt;<font color=#0000ff>int</font>&gt;::iterator i = vi.begin();
  cout &lt;&lt; <font color=#004488>"\n i: "</font> &lt;&lt; <font color=#0000ff>long</font>(i) &lt;&lt; endl;
  *i = 47;
  copy(vi.begin(), vi.end(), out);
  <font color=#009900>// Force it to move memory (could also just add</font>
  <font color=#009900>// enough objects):</font>
  vi.resize(vi.capacity() + 1);
  <font color=#009900>// Now i points to wrong memory:</font>
  cout &lt;&lt; <font color=#004488>"\n i: "</font> &lt;&lt; <font color=#0000ff>long</font>(i) &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"vi.begin(): "</font> &lt;&lt; <font color=#0000ff>long</font>(vi.begin());
  *i = 48;  <font color=#009900>// Access violation</font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If your program is breaking mysteriously,
look for places where you hold onto an iterator while adding more objects to a
<B>vector</B>. You&#8217;ll need to get a new iterator after adding elements, or
use <B>operator[ ] </B>instead for element selections. If you combine the above
observation with the awareness of the potential expense of adding new objects to
a <B>vector</B>, you may conclude that the safest way to use one is to fill it
up all at once (ideally, knowing first how many objects you&#8217;ll need) and
then just use it (without adding more objects) elsewhere in the program. This is
the way <B>vector</B> has been used in the book up to this
point.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I123">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I124"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You may observe that using <B>vector
</B>as the &#8220;basic&#8221; container in the earlier chapters of this book
may not be the best choice in all cases. This is a fundamental issue in
containers, and in data structures in general: the &#8220;best&#8221; choice
varies according to the way the container is used. The reason <B>vector</B> has
been the &#8220;best&#8221; choice up until now is that it looks a lot like an
array, and was thus familiar and easy for you to adopt. But from now on
it&#8217;s also worth thinking about other issues when choosing
containers.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I124">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I125"></a>
</FONT><A NAME="_Toc519042024"></A><BR></P></DIV>
<A NAME="Heading211"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Inserting and erasing elements</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>vector</B> is most efficient
if:</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">You <B>reserve(&#160;)</B>
the correct amount of storage at the beginning so the <B>vector</B> never has to
reallocate.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">You only
add and remove elements from the back
end.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It is possible to insert
and erase elements from the middle of a <B>vector</B> using an iterator, but the
following program demonstrates what a bad idea it
is:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I125">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I126"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:VectorInsertAndErase.cpp</font>
<font color=#009900>// Erasing an element from a vector</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"Noisy.h"</font>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  vector&lt;Noisy&gt; v;
  v.reserve(11);
  cout &lt;&lt; <font color=#004488>"11 spaces have been reserved"</font> &lt;&lt; endl;
  generate_n(back_inserter(v), 10, NoisyGen());
  ostream_iterator&lt;Noisy&gt; out(cout, <font color=#004488>" "</font>);
  cout &lt;&lt; endl;
  copy(v.begin(), v.end(), out);
  cout &lt;&lt; <font color=#004488>"Inserting an element:"</font> &lt;&lt; endl;
  vector&lt;Noisy&gt;::iterator it = 
    v.begin() + v.size() / 2; <font color=#009900>// Middle</font>
  v.insert(it, Noisy());
  cout &lt;&lt; endl;
  copy(v.begin(), v.end(), out);
  cout &lt;&lt; <font color=#004488>"\nErasing an element:"</font> &lt;&lt; endl;
  <font color=#009900>// Cannot use the previous value of it:</font>
  it = v.begin() + v.size() / 2;
  v.erase(it);
  cout &lt;&lt; endl;
  copy(v.begin(), v.end(), out);
  cout &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you run the program you&#8217;ll see
that the call to <B>reserve(&#160;)</B> really does only allocate storage
&#8211; no constructors are called. The <B>generate_n(&#160;)</B> call is pretty
busy: each call to <B>NoisyGen::operator(&#160;)</B> results in a construction,
a copy-construction (into the <B>vector</B>) and a destruction of the temporary.
But when an object is inserted into the <B>vector</B> in the middle, it must
shove everything down to maintain the linear array and &#8211; since there is
enough space &#8211; it does this with the assignment operator (if the argument
of <B>reserve(&#160;)</B> is 10 instead of eleven then it would have to
reallocate storage). When an object is erased from the <B>vector</B>, the
assignment operator is once again used to move everything up to cover the place
that is being erased (notice that this requires that the assignment operator
properly cleans up the lvalue). Lastly, the object on the end of the array is
deleted.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I126">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I127"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can imagine how enormous the overhead
can become if objects are inserted and removed from the middle of a
<B>vector</B> if the number of elements is large and the objects are
complicated. It&#8217;s obviously a practice to
avoid.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I127">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I128"></a>
</FONT><A NAME="_Toc519042025"></A><BR></P></DIV>
<A NAME="Heading212"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
deque</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>deque</B> (double-ended-queue,
pronounced &#8220;deck&#8221;) is the basic sequence container optimized for
adding and removing elements from either end. It also allows for reasonably fast
random access &#8211; it has an <B>operator[ ]</B> like <B>vector</B>. However,
it does not have <B>vector</B>&#8217;s constraint of keeping everything in a
single sequential block of memory. Instead, <B>deque</B> uses multiple blocks of
sequential storage (keeping track of all the blocks and their order in a mapping
structure). For this reason the overhead for a <B>deque</B> to add or remove
elements at either end is very low. In addition, it never needs to copy and
destroy contained objects during a new storage allocation (like <B>vector</B>
does) so it is far more efficient than <B>vector</B> if you are adding an
unknown quantity of objects. This means that <B>vector</B> is the best choice
only if you have a pretty good idea of how many objects you need. In addition,
many of the programs shown earlier in this book that use <B>vector</B> and
<B>push_back(&#160;)</B> might be more efficient with a <B>deque</B>. The
interface to <B>deque</B> is only slightly different from a <B>vector</B> (deque
has a <B>push_front(&#160;)</B> and <B>pop_front(&#160;)</B> while <B>vector</B>
does not, for example) so converting code from using <B>vector</B> to using
<B>deque</B> is almost trivial. Consider <B>StringVector.cpp</B>, which can be
changed to use <B>deque</B> by replacing the word &#8220;vector&#8221; with
&#8220;deque&#8221; everywhere. The following program adds parallel <B>deque</B>
operations to the <B>vector</B> operations in <B>StringVector.cpp</B>, and
performs timing
comparisons:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I128">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I129"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:StringDeque.cpp</font>
<font color=#009900>// Converted from StringVector.cpp</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;string&gt;
#include &lt;deque&gt;
#include &lt;vector&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;sstream&gt;
#include &lt;ctime&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  <font color=#0000ff>char</font>* fname = <font color=#004488>"StringDeque.cpp"</font>;
  <font color=#0000ff>if</font>(argc &gt; 1) fname = argv[1];
  ifstream in(fname);
  assure(in, fname);
  vector&lt;string&gt; vstrings;
  deque&lt;string&gt; dstrings;
  string line;
  <font color=#009900>// Time reading into vector:</font>
  clock_t ticks = clock();
  <font color=#0000ff>while</font>(getline(in, line))
    vstrings.push_back(line);
  ticks = clock() - ticks;
  cout &lt;&lt; <font color=#004488>"Read into vector: "</font> &lt;&lt; ticks &lt;&lt; endl;
  <font color=#009900>// Repeat for deque:</font>
  ifstream in2(fname);
  assure(in2, fname);
  ticks = clock();
  <font color=#0000ff>while</font>(getline(in2, line))
    dstrings.push_back(line);
  ticks = clock() - ticks;
  cout &lt;&lt; <font color=#004488>"Read into deque: "</font> &lt;&lt; ticks &lt;&lt; endl;
  <font color=#009900>// Now compare indexing:</font>
  ticks = clock();
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; vstrings.size(); i++) {
    ostringstream ss;
    ss &lt;&lt; i;
    vstrings[i] = ss.str() + <font color=#004488>": "</font> + vstrings[i];
  }
  ticks = clock() - ticks;
  cout &lt;&lt; <font color=#004488>"Indexing vector: "</font> &lt;&lt; ticks &lt;&lt; endl;
  ticks = clock();
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; dstrings.size(); j++) {
    ostringstream ss;
    ss &lt;&lt; j;
    dstrings[j] = ss.str() + <font color=#004488>": "</font> + dstrings[j];
  }
  ticks = clock() - ticks;
  cout &lt;&lt; <font color=#004488>"Indexing deqeue: "</font> &lt;&lt; ticks &lt;&lt; endl;
  <font color=#009900>// Compare iteration</font>
  ofstream tmp1(<font color=#004488>"tmp1.tmp"</font>), tmp2(<font color=#004488>"tmp2.tmp"</font>);
  ticks = clock();
  copy(vstrings.begin(), vstrings.end(),
    ostream_iterator&lt;string&gt;(tmp1, <font color=#004488>"\n"</font>));
  ticks = clock() - ticks;
  cout &lt;&lt; <font color=#004488>"Iterating vector: "</font> &lt;&lt; ticks &lt;&lt; endl;
  ticks = clock();
  copy(dstrings.begin(), dstrings.end(),
    ostream_iterator&lt;string&gt;(tmp2, <font color=#004488>"\n"</font>));
  ticks = clock() - ticks;
  cout &lt;&lt; <font color=#004488>"Iterating deqeue: "</font> &lt;&lt; ticks &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Knowing now what you do about the
inefficiency of adding things to <B>vector</B> because of storage reallocation,
you may expect dramatic differences between the two. However, on a 1.7 Megabyte
text file one compiler&#8217;s program produced the following (measured in
platform/compiler specific clock ticks, not
seconds):
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I129">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I130"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Read into vector: 8350
Read into deque: 7690
Indexing vector: 2360
Indexing deqeue: 2480
Iterating vector: 2470
Iterating deqeue: 2410</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A different compiler and platform roughly
agreed with this. It&#8217;s not so dramatic, is it? This points out some
important issues:</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">We (programmers) are
typically very bad at guessing where inefficiencies occur in our
programs.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Efficiency
comes from a combination of effects &#8211; here, reading the lines in and
converting them to strings may dominate over the cost of the <B>vector</B> vs.
<B>deque</B>.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">The
<B>string</B> class is probably fairly well-designed in terms of
efficiency.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, this
doesn&#8217;t mean you shouldn&#8217;t use a <B>deque</B> rather than a
<B>vector</B> when you know that an uncertain number of objects will be pushed
onto the end of the container. On the contrary, you should &#8211; when
you&#8217;re tuning for performance. But you should also be aware that
performance issues are usually not where you think they are, and the only way to
know for sure where your bottlenecks are is by testing. Later in this chapter
there will be a more &#8220;pure&#8221; comparison of performance between
<B>vector</B>, <B>deque</B> and
<B>list</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I130">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I131"></a>
</FONT><A NAME="_Toc519042026"></A><BR></P></DIV>
<A NAME="Heading213"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Converting between sequences</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Sometimes you need the behavior or
efficiency of one kind of container for one part of your program, and a
different container&#8217;s behavior or efficiency in another part of the
program. For example, you may need the efficiency of a <B>deque</B> when adding
objects to the container but the efficiency of a <B>vector</B> when indexing
them. Each of the basic sequence containers (<B>vector</B>, <B>deque</B> and
<B>list</B>) has a two-iterator constructor (indicating the beginning and ending
of the sequence to read from when creating a new object) and an
<B>assign(&#160;)</B> member function to read into an existing container, so you
can easily move objects from one sequence container to
another.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I131">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I132"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example reads objects into
a <B>deque</B> and then converts to a
<B>vector</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I132">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I133"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:DequeConversion.cpp</font>
<font color=#009900>// Reading into a Deque, converting to a vector</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-msc}</font>
#include <font color=#004488>"Noisy.h"</font>
#include &lt;deque&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  <font color=#0000ff>int</font> size = 25;
  <font color=#0000ff>if</font>(argc &gt;= 2) size = atoi(argv[1]);
  deque&lt;Noisy&gt; d;
  generate_n(back_inserter(d), size, NoisyGen());
  cout &lt;&lt; <font color=#004488>"\n Converting to a vector(1)"</font> &lt;&lt; endl;
  vector&lt;Noisy&gt; v1(d.begin(), d.end());
  cout &lt;&lt; <font color=#004488>"\n Converting to a vector(2)"</font> &lt;&lt; endl;
  vector&lt;Noisy&gt; v2;
  v2.reserve(d.size());
  v2.assign(d.begin(), d.end());
  cout &lt;&lt; <font color=#004488>"\n Cleanup"</font> &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can try various sizes, but you should
see that it makes no difference &#8211; the objects are simply copy-constructed
into the new <B>vector</B>s. What&#8217;s interesting is that <B>v1</B> does not
cause multiple allocations while building the <B>vector</B>, no matter how many
elements you use. You might initially think that you must follow the process
used for <B>v2</B> and preallocate the storage to prevent messy reallocations,
but the constructor used for <B>v1</B> determines the memory need ahead of time
so this is
unnecessary.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I133">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I134"></a>
</FONT><A NAME="_Toc519042027"></A><BR></P></DIV>
<A NAME="Heading214"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Cost of overflowing allocated storage</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s illuminating to see what
happens with a <B>deque</B> when it overflows a block of storage, in contrast
with
<B>VectorOverflow.cpp</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I134">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I135"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:DequeOverflow.cpp</font>
<font color=#009900>// A deque is much more efficient than a vector</font>
<font color=#009900>// when pushing back a lot of elements, since it</font>
<font color=#009900>// doesn't require copying and destroying.</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"Noisy.h"</font>
#include &lt;deque&gt;
#include &lt;cstdlib&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  <font color=#0000ff>int</font> size = 1000;
  <font color=#0000ff>if</font>(argc &gt;= 2) size = atoi(argv[1]);
  deque&lt;Noisy&gt; dn;
  Noisy n;
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; size; i++)
    dn.push_back(n);
  cout &lt;&lt; <font color=#004488>"\n cleaning up \n"</font>;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here you will never see any destructors
before the words &#8220;cleaning up&#8221; appear. Since the <B>deque</B>
allocates all its storage in blocks instead of a contiguous array like
<B>vector</B>, it never needs to move existing storage (thus no additional
copy-constructions and destructions occur). It simply allocates a new block. For
the same reason, the <B>deque</B> can just as efficiently add elements to the
<I>beginning</I> of the sequence, since if it runs out of storage it (again)
just allocates a new block for the beginning. Insertions in the middle of a
<B>deque</B>, however, could be even messier than for <B>vector</B> (but not as
costly).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I135">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I136"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because a <B>deque </B>never moves its
storage, a held iterator never becomes invalid when you add new things to either
end of a deque, as it was demonstrated to do with <B>vector</B> (in
<B>VectorCoreDump.cpp</B>). However, it&#8217;s still possible (albeit harder)
to do bad things:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I136">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I137"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:DequeCoreDump.cpp</font>
<font color=#009900>// How to break a program using a deque</font>
#include &lt;queue&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  deque&lt;<font color=#0000ff>int</font>&gt; di(100, 0);
  <font color=#009900>// No problem iterating from beginning to end,</font>
  <font color=#009900>// even though it spans multiple blocks:</font>
  copy(di.begin(), di.end(), 
    ostream_iterator&lt;<font color=#0000ff>int</font>&gt;(cout, <font color=#004488>" "</font>));
  deque&lt;<font color=#0000ff>int</font>&gt;::iterator i = <font color=#009900>// In the middle:</font>
    di.begin() + di.size() / 2;;
  <font color=#009900>// Walk the iterator forward as you perform </font>
  <font color=#009900>// a lot of insertions in the middle:</font>
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; 1000; j++) {
    cout &lt;&lt; j &lt;&lt; endl;
    di.insert(i++, 1); <font color=#009900>// Eventually breaks</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, there are two things here that
you wouldn&#8217;t normally do with a <B>deque</B>: first, elements are inserted
in the middle, which <B>deque</B> allows but isn&#8217;t designed for. Second,
calling <B>insert(&#160;)</B> repeatedly with the same iterator would not
ordinarily cause an access violation, but the iterator is walked forward after
each insertion. I&#8217;m guessing it eventually walks off the end of a block,
but I&#8217;m not sure what actually causes the
problem.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I137">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I138"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you stick to what <B>deque</B> is best
at &#8211; insertions and removals from either end, reasonably rapid traversals
and fairly fast random-access using <B>operator[ ]</B> &#8211; you&#8217;ll be
in good
shape.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I138">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I139"></a>
</FONT><A NAME="_Toc519042028"></A><BR></P></DIV>
<A NAME="Heading215"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Checked random-access</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Both <B>vector </B>and <B>deque</B>
provide two ways to perform random access of their elements: the <B>operator[
]</B>, which you&#8217;ve seen already, and <B>at(&#160;)</B>, which checks the
boundaries of the container that&#8217;s being indexed and throws an exception
if you go out of bounds. It does cost more to use
<B>at(&#160;)</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I139">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I140"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:IndexingVsAt.cpp</font>
<font color=#009900>// Comparing "at()" to operator[]</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-g++295} </font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;iostream&gt;
#include &lt;ctime&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  <font color=#0000ff>long</font> count = 1000;
  <font color=#0000ff>int</font> sz = 1000;
  <font color=#0000ff>if</font>(argc &gt;= 2) count = atoi(argv[1]);
  <font color=#0000ff>if</font>(argc &gt;= 3) sz = atoi(argv[2]);
  vector&lt;<font color=#0000ff>int</font>&gt; vi(sz);
  clock_t ticks = clock();
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i1 = 0; i1 &lt; count; i1++)
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; sz; j++)
      vi[j];
  cout &lt;&lt; <font color=#004488>"vector[] "</font> &lt;&lt; clock() - ticks &lt;&lt; endl;
  ticks = clock();
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i2 = 0; i2 &lt; count; i2++)
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; sz; j++)
      vi.at(j);
  cout &lt;&lt; <font color=#004488>"vector::at() "</font> &lt;&lt; clock()-ticks &lt;&lt;endl;
  deque&lt;<font color=#0000ff>int</font>&gt; di(sz);
  ticks = clock();
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i3 = 0; i3 &lt; count; i3++)
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; sz; j++)
      di[j];
  cout &lt;&lt; <font color=#004488>"deque[] "</font> &lt;&lt; clock() - ticks &lt;&lt; endl;
  ticks = clock();
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i4 = 0; i4 &lt; count; i4++)
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; sz; j++)
      di.at(j);
  cout &lt;&lt; <font color=#004488>"deque::at() "</font> &lt;&lt; clock()-ticks &lt;&lt;endl;
  <font color=#009900>// Demonstrate at() when you go out of bounds:</font>
  <font color=#0000ff>try</font> {
    di.at(vi.size() + 1);
  } <font color=#0000ff>catch</font>(...) {
    cerr &lt;&lt; <font color=#004488>"Exception thrown"</font> &lt;&lt; endl;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As you&#8217;ll learn in the
exception-handling chapter, different systems may handle the uncaught exception
in different ways, but you&#8217;ll know one way or another that something went
wrong with the program when using <B>at(&#160;)</B>, whereas it&#8217;s possible
to go blundering ahead using <B>operator[
]</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I140">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I141"></a>
</FONT><A NAME="_Toc519042029"></A><BR></P></DIV>
<A NAME="Heading216"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
list</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>list</B> is implemented as a
doubly-linked list and is thus designed for rapid insertion and removal of
elements in the middle of the sequence (whereas for <B>vector</B> and <B>deque
</B>this is a much more costly operation). A list is so slow when randomly
accessing elements that it does not have an <B>operator[ ]</B>. It&#8217;s best
used when you&#8217;re traversing a sequence, in order, from beginning to end
(or end to beginning) rather than choosing elements randomly from the middle.
Even then the traversal is significantly slower than either a <B>vector </B>or a
<B>deque</B>, but if you aren&#8217;t doing a lot of traversals that won&#8217;t
be your bottleneck.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I141">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I142"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Another thing to be aware of with a
<B>list</B> is the memory overhead of each link, which requires a forward and
backward pointer on top of the storage for the actual object. Thus a <B>list</B>
is a better choice when you have larger objects that you&#8217;ll be inserting
and removing from the middle of the <B>list</B>. It&#8217;s better not to use a
<B>list </B>if you think you might be traversing it a lot, looking for objects,
since the amount of time it takes to get from the beginning of the <B>list</B>
&#8211; which is the only place you can start unless you&#8217;ve already got an
iterator to somewhere you know is closer to your destination &#8211; to the
object of interest is proportional to the number of objects between the
beginning and that
object.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I142">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I143"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The objects in a <B>list </B>never move
after they are created; &#8220;moving&#8221; a list element means changing the
links, but never copying or assigning the actual objects. This means that a held
iterator never moves when you add new things to a list as it was demonstrated to
do in <B>vector</B>. Here&#8217;s an example using the <B>Noisy</B>
class:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I143">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I144"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:ListStability.cpp</font>
<font color=#009900>// Things don't move around in lists</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"Noisy.h"</font>
#include &lt;list&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  list&lt;Noisy&gt; l;
  ostream_iterator&lt;Noisy&gt; out(cout, <font color=#004488>" "</font>);
  generate_n(back_inserter(l), 25, NoisyGen());
  cout &lt;&lt; <font color=#004488>"\n Printing the list:"</font> &lt;&lt; endl;
  copy(l.begin(), l.end(), out);
  cout &lt;&lt; <font color=#004488>"\n Reversing the list:"</font> &lt;&lt; endl;
  l.reverse();
  copy(l.begin(), l.end(), out);
  cout &lt;&lt; <font color=#004488>"\n Sorting the list:"</font> &lt;&lt; endl;
  l.sort();
  copy(l.begin(), l.end(), out);
  cout &lt;&lt; <font color=#004488>"\n Swapping two elements:"</font> &lt;&lt; endl;
  list&lt;Noisy&gt;::iterator it1, it2;
  it1 = it2 = l.begin();
  it2++;
  swap(*it1, *it2);
  cout &lt;&lt; endl;
  copy(l.begin(), l.end(), out);
  cout &lt;&lt; <font color=#004488>"\n Using generic reverse(): "</font> &lt;&lt; endl;
  reverse(l.begin(), l.end());
  cout &lt;&lt; endl;
  copy(l.begin(), l.end(), out);
  cout &lt;&lt; <font color=#004488>"\n Cleanup"</font> &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Operations as seemingly radical as
reversing and sorting the list require no copying of objects, because instead of
moving the objects, the links are simply changed. However, notice that
<B>sort(&#160;)</B> and <B>reverse(&#160;)</B> are member functions of
<B>list</B>, so they have special knowledge of the internals of <B>list</B> and
can perform the pointer movement instead of copying. On the other hand, the
<B>swap(&#160;)</B> function is a generic algorithm, and doesn&#8217;t know
about <B>list</B> in particular and so it uses the copying approach for swapping
two elements. There are also generic algorithms for <B>sort(&#160;)</B> and
<B>reverse(&#160;)</B>, but if you try to use these you&#8217;ll discover that
the generic <B>reverse(&#160;)</B> performs lots of copying and destruction (so
you should never use it with a <B>list</B>) and the generic <B>sort(&#160;)</B>
simply doesn&#8217;t work because it requires random-access iterators that
<B>list</B> doesn&#8217;t provide (a definite benefit, since this would
certainly be an expensive way to sort compared to <B>list</B>&#8217;s own<B>
sort(&#160;)</B>). The generic <B>sort(&#160;)</B> and <B>reverse(&#160;)</B>
should only be used with arrays, <B>vector</B>s and
<B>deque</B>s.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I144">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I145"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you have large and complex objects you
may want to choose a <B>list</B> first, especially if construction, destruction,
copy-construction and assignment are expensive and if you are doing things like
sorting the objects or otherwise reordering them a
lot.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I145">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I146"></a>
</FONT><A NAME="_Toc519042030"></A><BR></P></DIV>
<A NAME="Heading217"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Special list operations</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>list</B> has some special
operations that are built-in to make the best use of the structure of the
<B>list</B>. You&#8217;ve already seen <B>reverse(&#160;)</B> and
<B>sort(&#160;)</B>, and here are some of the others in
use:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I146">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I147"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:ListSpecialFunctions.cpp</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"Noisy.h"</font>
#include &lt;list&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;
ostream_iterator&lt;Noisy&gt; out(cout, <font color=#004488>" "</font>);

<font color=#0000ff>void</font> print(list&lt;Noisy&gt;&amp; ln, <font color=#0000ff>char</font>* comment = <font color=#004488>""</font>) {
  cout &lt;&lt; <font color=#004488>"\n"</font> &lt;&lt; comment &lt;&lt; <font color=#004488>":\n"</font>;
  copy(ln.begin(), ln.end(), out);
  cout &lt;&lt; endl;
}

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>typedef</font> list&lt;Noisy&gt; LN;
  LN l1, l2, l3, l4;
  generate_n(back_inserter(l1), 6, NoisyGen());
  generate_n(back_inserter(l2), 6, NoisyGen());
  generate_n(back_inserter(l3), 6, NoisyGen());
  generate_n(back_inserter(l4), 6, NoisyGen());
  print(l1, <font color=#004488>"l1"</font>); print(l2, <font color=#004488>"l2"</font>);
  print(l3, <font color=#004488>"l3"</font>); print(l4, <font color=#004488>"l4"</font>);
  LN::iterator it1 = l1.begin();
  it1++; it1++; it1++;
  l1.splice(it1, l2);
  print(l1, <font color=#004488>"l1 after splice(it1, l2)"</font>);
  print(l2, <font color=#004488>"l2 after splice(it1, l2)"</font>);
  LN::iterator it2 = l3.begin();
  it2++; it2++; it2++;
  l1.splice(it1, l3, it2);
  print(l1, <font color=#004488>"l1 after splice(it1, l3, it2)"</font>);
  LN::iterator it3 = l4.begin(), it4 = l4.end();
  it3++; it4--;
  l1.splice(it1, l4, it3, it4);
  print(l1, <font color=#004488>"l1 after splice(it1,l4,it3,it4)"</font>);
  Noisy n;
  LN l5(3, n);
  generate_n(back_inserter(l5), 4, NoisyGen());
  l5.push_back(n);
  print(l5, <font color=#004488>"l5 before remove()"</font>);
  l5.remove(l5.front());
  print(l5, <font color=#004488>"l5 after remove()"</font>);
  l1.sort(); l5.sort();
  l5.merge(l1);
  print(l5, <font color=#004488>"l5 after l5.merge(l1)"</font>);
  cout &lt;&lt; <font color=#004488>"\n Cleanup"</font> &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>print(&#160;)</B> function is used
to display results. After filling four <B>list</B>s with <B>Noisy</B> objects,
one list is spliced into another in three different ways. In the first, the
entire list <B>l2</B> is spliced into <B>l1</B> at the iterator <B>it1</B>.
Notice that after the splice, <B>l2</B> is empty &#8211; splicing means removing
the elements from the source list. The second splice inserts elements from <B>l3
</B>starting at <B>it2</B> into <B>l1 </B>starting at <B>it1</B>. The third
splice starts at <B>it1</B> and uses elements from <B>l4</B> starting at
<B>it3</B> and ending at <B>it4</B> (the seemingly-redundant mention of the
source list is because the elements must be erased from the source list as part
of the transfer to the destination
list)<B>.</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I147">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I148"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The output from the code that
demonstrates <B>remove(&#160;)</B> shows that the list does not have to be
sorted in order for all the elements of a particular value to be
removed.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I148">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I149"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Finally, if you <B>merge(&#160;)</B> one
list with another, the merge only works sensibly if the lists have been sorted.
What you end up with in that case is a sorted list containing all the elements
from both lists (the source list is erased &#8211; that is, the elements are
<I>moved</I> to the destination
list).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I149">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I150"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s also a
<B>unique(&#160;)</B> member function that removes all duplicates, but only if
the <B>list</B> has been sorted
first:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I150">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I151"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:UniqueList.cpp</font>
<font color=#009900>// Testing list's unique() function</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;list&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> a[] = { 1, 3, 1, 4, 1, 5, 1, 6, 1 };
<font color=#0000ff>const</font> <font color=#0000ff>int</font> asz = <font color=#0000ff>sizeof</font> a / <font color=#0000ff>sizeof</font> *a;

<font color=#0000ff>int</font> main() {
  <font color=#009900>// For output:</font>
  ostream_iterator&lt;<font color=#0000ff>int</font>&gt; out(cout, <font color=#004488>" "</font>);
  list&lt;<font color=#0000ff>int</font>&gt; li(a, a + asz);
  li.unique();
  <font color=#009900>// Oops! No duplicates removed:</font>
  copy(li.begin(), li.end(), out);
  cout &lt;&lt; endl;
  <font color=#009900>// Must sort it first:</font>
  li.sort();
  copy(li.begin(), li.end(), out);
  cout &lt;&lt; endl;
  <font color=#009900>// Now unique() will have an effect:</font>
  li.unique();
  copy(li.begin(), li.end(), out);
  cout &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>list</B> constructor used here
takes the starting and past-the-end iterator from another container, and it
copies all the elements from that container into itself (a similar constructor
is available for all the containers). Here, the &#8220;container&#8221; is just
an array, and the &#8220;iterators&#8221; are pointers into that array, but
because of the design of the STL it works with arrays just as easily as any
other container.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I151">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I152"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you run this program, you&#8217;ll see
that <B>unique(&#160;)</B> will only remove <I>adjacent</I> duplicate elements,
and thus sorting is necessary before calling
<B>unique(&#160;)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I152">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I153"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are four additional <B>list
</B>member functions that are not demonstrated here: a <B>remove_if(&#160;)</B>
that takes a predicate which is used to decide whether an object should be
removed, a <B>unique(&#160;)</B> that takes a binary predicate to perform
uniqueness comparisons, a <B>merge(&#160;)</B> that takes an additional argument
which performs comparisons, and a <B>sort(&#160;)</B> that takes a comparator
(to provide a comparison or override the existing
one).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I153">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I154"></a>
</FONT><BR></P></DIV>
<A NAME="Heading218"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
list vs. set</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Looking at the previous example you may
note that if you want a sorted list with no duplicates, a <B>set</B> can give
you that, right? <B> </B>It&#8217;s interesting to compare the performance of
the two containers:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I154">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I155"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:ListVsSet.cpp</font>
<font color=#009900>// Comparing list and set performance</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Obj {
  <font color=#0000ff>int</font> a[20]; <font color=#009900>// To take up extra space</font>
  <font color=#0000ff>int</font> val;
<font color=#0000ff>public</font>:
  Obj() : val(rand() % 500) {}
  <font color=#0000ff>friend</font> <font color=#0000ff>bool</font> 
  <font color=#0000ff>operator</font>&lt;(<font color=#0000ff>const</font> Obj&amp; a, <font color=#0000ff>const</font> Obj&amp; b) {
    <font color=#0000ff>return</font> a.val &lt; b.val;
  }
  <font color=#0000ff>friend</font> <font color=#0000ff>bool</font> 
  <font color=#0000ff>operator</font>==(<font color=#0000ff>const</font> Obj&amp; a, <font color=#0000ff>const</font> Obj&amp; b) {
    <font color=#0000ff>return</font> a.val == b.val;
  }
  <font color=#0000ff>friend</font> ostream&amp; 
  <font color=#0000ff>operator</font>&lt;&lt;(ostream&amp; os, <font color=#0000ff>const</font> Obj&amp; a) {
    <font color=#0000ff>return</font> os &lt;&lt; a.val;
  }
};

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> Container&gt;
<font color=#0000ff>void</font> print(Container&amp; c) {
  <font color=#0000ff>typename</font> Container::iterator it;
  <font color=#0000ff>for</font>(it = c.begin(); it != c.end(); it++)
    cout &lt;&lt; *it &lt;&lt; <font color=#004488>" "</font>;
  cout &lt;&lt; endl;
}

<font color=#0000ff>struct</font> ObjGen {
  Obj <font color=#0000ff>operator</font>()() { <font color=#0000ff>return</font> Obj(); }
};

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> sz = 5000;
  srand(time(0));
  list&lt;Obj&gt; lo;
  clock_t ticks = clock();
  generate_n(back_inserter(lo), sz, ObjGen());
  lo.sort();
  lo.unique();
  cout &lt;&lt; <font color=#004488>"list:"</font> &lt;&lt; clock() - ticks &lt;&lt; endl;
  set&lt;Obj&gt; so;
  ticks = clock();
  generate_n(inserter(so, so.begin()), 
    sz, ObjGen());
  cout &lt;&lt; <font color=#004488>"set:"</font> &lt;&lt; clock() - ticks &lt;&lt; endl;
  print(lo);
  print(so);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you run the program, you should
discover that <B>set</B> is much faster than <B>list</B>. This is reassuring
&#8211; after all, it <I>is</I> <B>set</B>&#8217;s primary job
description!
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I155">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I156"></a>
</FONT><A NAME="_Toc519042031"></A><BR></P></DIV>
<A NAME="Heading219"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Swapping all basic sequences</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It turns out that all basic sequences
have a member function <B>swap(&#160;)</B> that&#8217;s designed to switch one
sequence with another (however, this <B>swap(&#160;)</B> is only defined for
sequences of the same type). The member <B>swap(&#160;)</B> makes use of its
knowledge of the internal structure of the particular container in order to be
efficient:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I156">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I157"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:Swapping.cpp</font>
<font color=#009900>// All basic sequence containers can be swapped</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"Noisy.h"</font>
#include &lt;list&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;
ostream_iterator&lt;Noisy&gt; out(cout, <font color=#004488>" "</font>);

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> Cont&gt;
<font color=#0000ff>void</font> print(Cont&amp; c, <font color=#0000ff>char</font>* comment = <font color=#004488>""</font>) {
  cout &lt;&lt; <font color=#004488>"\n"</font> &lt;&lt; comment &lt;&lt; <font color=#004488>": "</font>;
  copy(c.begin(), c.end(), out);
  cout &lt;&lt; endl;
}

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> Cont&gt;
<font color=#0000ff>void</font> testSwap(<font color=#0000ff>char</font>* cname) {
  Cont c1, c2;
  generate_n(back_inserter(c1), 10, NoisyGen());
  generate_n(back_inserter(c2), 5, NoisyGen());
  cout &lt;&lt; <font color=#004488>"\n"</font> &lt;&lt; cname &lt;&lt; <font color=#004488>":"</font> &lt;&lt; endl;
  print(c1, <font color=#004488>"c1"</font>); print(c2, <font color=#004488>"c2"</font>);
  cout &lt;&lt; <font color=#004488>"\n Swapping the "</font> &lt;&lt; cname 
    &lt;&lt; <font color=#004488>":"</font> &lt;&lt; endl;
  c1.swap(c2);
  print(c1, <font color=#004488>"c1"</font>); print(c2, <font color=#004488>"c2"</font>);
}  

<font color=#0000ff>int</font> main() {
  testSwap&lt;vector&lt;Noisy&gt; &gt;(<font color=#004488>"vector"</font>);
  testSwap&lt;deque&lt;Noisy&gt; &gt;(<font color=#004488>"deque"</font>);
  testSwap&lt;list&lt;Noisy&gt; &gt;(<font color=#004488>"list"</font>);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you run this, you&#8217;ll discover
that each type of sequence container is able to swap one sequence for another
without any copying or assignments, even if the sequences are of different
sizes. In effect, you&#8217;re completely swapping the memory of one object for
another.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I157">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I158"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The STL algorithms also contain a
<B>swap(&#160;)</B>, and when this function is applied to two containers of the
same type, it will use the member <B>swap(&#160;)</B> to achieve fast
performance. Consequently, if you apply the <B>sort(&#160;)</B> algorithm to a
container of containers, you will find that the performance is very fast &#8211;
it turns out that fast sorting of a container of containers was a design goal of
the
STL.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I158">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I159"></a>
</FONT><A NAME="_Toc519042032"></A><BR></P></DIV>
<A NAME="Heading220"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Robustness of lists</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To break a <B>list</B>, you have to work
pretty hard:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I159">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I160"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:ListRobustness.cpp</font>
<font color=#009900>// lists are harder to break</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;list&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  list&lt;<font color=#0000ff>int</font>&gt; li(100, 0);
  list&lt;<font color=#0000ff>int</font>&gt;::iterator i = li.begin();
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; li.size() / 2; j++)
    i++;
  <font color=#009900>// Walk the iterator forward as you perform </font>
  <font color=#009900>// a lot of insertions in the middle:</font>
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> k = 0; k &lt; 1000; k++)
    li.insert(i++, 1); <font color=#009900>// No problem</font>
  li.erase(i);
  i++;
  <font color=#009900>//! *i = 2; // Oops! It's invalid</font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When the link that the iterator <B>i</B>
was pointing to was erased, it was unlinked from the list and thus became
invalid. Trying to move forward to the &#8220;next link&#8221; from an invalid
link is poorly-formed code. Notice that the operation that broke <B>deque</B> in
<B>DequeCoreDump.cpp</B> is perfectly fine with a
<B>list</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I160">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I161"></a>
</FONT><A NAME="_Toc519042033"></A><BR></P></DIV>
<A NAME="Heading221"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Performance comparison</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To get a better feel for the differences
between the sequence containers, it&#8217;s illuminating to race them against
each other while performing various operations.

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I161">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I162"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:SequencePerformance.cpp</font>
<font color=#009900>// Comparing the performance of the basic</font>
<font color=#009900>// sequence containers for various operations</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;list&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;typeinfo&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> FixedSize {
  <font color=#0000ff>int</font> x[20];
  <font color=#009900>// Automatic generation of default constructor,</font>
  <font color=#009900>// copy-constructor and operator=</font>
} fs;

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> Cont&gt;
<font color=#0000ff>struct</font> InsertBack {
  <font color=#0000ff>void</font> <font color=#0000ff>operator</font>()(Cont&amp; c, <font color=#0000ff>long</font> count) {
    <font color=#0000ff>for</font>(<font color=#0000ff>long</font> i = 0; i &lt; count; i++)
      c.push_back(fs);
  }
  <font color=#0000ff>char</font>* testName() { <font color=#0000ff>return</font> <font color=#004488>"InsertBack"</font>; }
};

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> Cont&gt;
<font color=#0000ff>struct</font> InsertFront {
  <font color=#0000ff>void</font> <font color=#0000ff>operator</font>()(Cont&amp; c, <font color=#0000ff>long</font> count) {
    <font color=#0000ff>long</font> cnt = count * 10;
    <font color=#0000ff>for</font>(<font color=#0000ff>long</font> i = 0; i &lt; cnt; i++)
      c.push_front(fs);
  }  
  <font color=#0000ff>char</font>* testName() { <font color=#0000ff>return</font> <font color=#004488>"InsertFront"</font>; }
};

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> Cont&gt;
<font color=#0000ff>struct</font> InsertMiddle {
  <font color=#0000ff>void</font> <font color=#0000ff>operator</font>()(Cont&amp; c, <font color=#0000ff>long</font> count) {
    <font color=#0000ff>typename</font> Cont::iterator it;
    <font color=#0000ff>long</font> cnt = count / 10;
    <font color=#0000ff>for</font>(<font color=#0000ff>long</font> i = 0; i &lt; cnt; i++) {
      <font color=#009900>// Must get the iterator every time to keep</font>
      <font color=#009900>// from causing an access violation with</font>
      <font color=#009900>// vector. Increment it to put it in the</font>
      <font color=#009900>// middle of the container:</font>
      it = c.begin();
      it++;
      c.insert(it, fs);
    }
  }
  <font color=#0000ff>char</font>* testName() { <font color=#0000ff>return</font> <font color=#004488>"InsertMiddle"</font>; }
};

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> Cont&gt;
<font color=#0000ff>struct</font> RandomAccess { <font color=#009900>// Not for list</font>
  <font color=#0000ff>void</font> <font color=#0000ff>operator</font>()(Cont&amp; c, <font color=#0000ff>long</font> count) {
    <font color=#0000ff>int</font> sz = c.size();
    <font color=#0000ff>long</font> cnt = count * 100;
    <font color=#0000ff>for</font>(<font color=#0000ff>long</font> i = 0; i &lt; cnt; i++)
      c[rand() % sz];
  }
  <font color=#0000ff>char</font>* testName() { <font color=#0000ff>return</font> <font color=#004488>"RandomAccess"</font>; }
};

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> Cont&gt;
<font color=#0000ff>struct</font> Traversal {
  <font color=#0000ff>void</font> <font color=#0000ff>operator</font>()(Cont&amp; c, <font color=#0000ff>long</font> count) {
    <font color=#0000ff>long</font> cnt = count / 100;
    <font color=#0000ff>for</font>(<font color=#0000ff>long</font> i = 0; i &lt; cnt; i++) {
      <font color=#0000ff>typename</font> Cont::iterator it = c.begin(),
        end = c.end();
      <font color=#0000ff>while</font>(it != end) it++;
    }
  }
  <font color=#0000ff>char</font>* testName() { <font color=#0000ff>return</font> <font color=#004488>"Traversal"</font>; }
};

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> Cont&gt;
<font color=#0000ff>struct</font> Swap {
  <font color=#0000ff>void</font> <font color=#0000ff>operator</font>()(Cont&amp; c, <font color=#0000ff>long</font> count) {
    <font color=#0000ff>int</font> middle = c.size() / 2;
    <font color=#0000ff>typename</font> Cont::iterator it = c.begin(), 
      mid = c.begin();
    it++; <font color=#009900>// Put it in the middle</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> x = 0; x &lt; middle + 1; x++)
      mid++;
    <font color=#0000ff>long</font> cnt = count * 10;
    <font color=#0000ff>for</font>(<font color=#0000ff>long</font> i = 0; i &lt; cnt; i++)
      swap(*it, *mid);
  }
  <font color=#0000ff>char</font>* testName() { <font color=#0000ff>return</font> <font color=#004488>"Swap"</font>; }
};

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> Cont&gt;
<font color=#0000ff>struct</font> RemoveMiddle {
  <font color=#0000ff>void</font> <font color=#0000ff>operator</font>()(Cont&amp; c, <font color=#0000ff>long</font> count) {
    <font color=#0000ff>long</font> cnt = count / 10;
    <font color=#0000ff>if</font>(cnt &gt; c.size()) {
      cout &lt;&lt; <font color=#004488>"RemoveMiddle: not enough elements"</font>
        &lt;&lt; endl;
      <font color=#0000ff>return</font>;
    }
    <font color=#0000ff>for</font>(<font color=#0000ff>long</font> i = 0; i &lt; cnt; i++) {
      <font color=#0000ff>typename</font> Cont::iterator it = c.begin();
      it++;
      c.erase(it);
    }
  }
  <font color=#0000ff>char</font>* testName() { <font color=#0000ff>return</font> <font color=#004488>"RemoveMiddle"</font>; }
};

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> Cont&gt;
<font color=#0000ff>struct</font> RemoveBack {
  <font color=#0000ff>void</font> <font color=#0000ff>operator</font>()(Cont&amp; c, <font color=#0000ff>long</font> count) {
    <font color=#0000ff>long</font> cnt = count * 10;
    <font color=#0000ff>if</font>(cnt &gt; c.size()) {
      cout &lt;&lt; <font color=#004488>"RemoveBack: not enough elements"</font>
        &lt;&lt; endl;
      <font color=#0000ff>return</font>;
    }
    <font color=#0000ff>for</font>(<font color=#0000ff>long</font> i = 0; i &lt; cnt; i++)
      c.pop_back();
  }
  <font color=#0000ff>char</font>* testName() { <font color=#0000ff>return</font> <font color=#004488>"RemoveBack"</font>; }
};

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> Op, <font color=#0000ff>class</font> Container&gt;
<font color=#0000ff>void</font> measureTime(Op f, Container&amp; c, <font color=#0000ff>long</font> count){
  string id(<font color=#0000ff>typeid</font>(f).name());
  <font color=#0000ff>bool</font> Deque = id.find(<font color=#004488>"deque"</font>) != string::npos;
  <font color=#0000ff>bool</font> List = id.find(<font color=#004488>"list"</font>) != string::npos;
  <font color=#0000ff>bool</font> Vector = id.find(<font color=#004488>"vector"</font>) !=string::npos;
  string cont = Deque ? <font color=#004488>"deque"</font> : List ? <font color=#004488>"list"</font> 
    : Vector? <font color=#004488>"vector"</font> : <font color=#004488>"unknown"</font>;
  cout &lt;&lt; f.testName() &lt;&lt; <font color=#004488>" for "</font> &lt;&lt; cont &lt;&lt; <font color=#004488>": "</font>;
  <font color=#009900>// Standard C library CPU ticks:</font>
  clock_t ticks = clock();
  f(c, count); <font color=#009900>// Run the test</font>
  ticks = clock() - ticks;
  cout &lt;&lt; ticks &lt;&lt; endl;
}

<font color=#0000ff>typedef</font> deque&lt;FixedSize&gt; DF;
<font color=#0000ff>typedef</font> list&lt;FixedSize&gt; LF;
<font color=#0000ff>typedef</font> vector&lt;FixedSize&gt; VF;

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  srand(time(0));
  <font color=#0000ff>long</font> count = 1000;
  <font color=#0000ff>if</font>(argc &gt;= 2) count = atoi(argv[1]);
  DF deq;
  LF lst;
  VF vec, vecres;
  vecres.reserve(count); <font color=#009900>// Preallocate storage</font>
  measureTime(InsertBack&lt;VF&gt;(), vec, count);
  measureTime(InsertBack&lt;VF&gt;(), vecres, count);
  measureTime(InsertBack&lt;DF&gt;(), deq, count);
  measureTime(InsertBack&lt;LF&gt;(), lst, count);
  <font color=#009900>// Can't push_front() with a vector:</font>
<font color=#009900>//! measureTime(InsertFront&lt;VF&gt;(), vec, count);</font>
  measureTime(InsertFront&lt;DF&gt;(), deq, count);
  measureTime(InsertFront&lt;LF&gt;(), lst, count);
  measureTime(InsertMiddle&lt;VF&gt;(), vec, count);
  measureTime(InsertMiddle&lt;DF&gt;(), deq, count);
  measureTime(InsertMiddle&lt;LF&gt;(), lst, count);
  measureTime(RandomAccess&lt;VF&gt;(), vec, count);
  measureTime(RandomAccess&lt;DF&gt;(), deq, count);
  <font color=#009900>// Can't operator[] with a list:</font>
<font color=#009900>//! measureTime(RandomAccess&lt;LF&gt;(), lst, count);</font>
  measureTime(Traversal&lt;VF&gt;(), vec, count);
  measureTime(Traversal&lt;DF&gt;(), deq, count);
  measureTime(Traversal&lt;LF&gt;(), lst, count);
  measureTime(Swap&lt;VF&gt;(), vec, count);
  measureTime(Swap&lt;DF&gt;(), deq, count);
  measureTime(Swap&lt;LF&gt;(), lst, count);
  measureTime(RemoveMiddle&lt;VF&gt;(), vec, count);
  measureTime(RemoveMiddle&lt;DF&gt;(), deq, count);
  measureTime(RemoveMiddle&lt;LF&gt;(), lst, count);
  vec.resize(vec.size() * 10); <font color=#009900>// Make it bigger</font>
  measureTime(RemoveBack&lt;VF&gt;(), vec, count);
  measureTime(RemoveBack&lt;DF&gt;(), deq, count);
  measureTime(RemoveBack&lt;LF&gt;(), lst, count);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example makes heavy use of templates
to eliminate redundancy, save space, guarantee identical code and improve
clarity. Each test is represented by a class that is templatized on the
container it will operate on. The test itself is inside the
<B>operator(&#160;)</B> which, in each case, takes a reference to the container
and a repeat count &#8211; this count is not always used exactly as it is, but
sometimes increased or decreased to prevent the test from being too short or too
long. The repeat count is just a factor, and all tests are compared using the
same value.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I162">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I163"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each test class also has a member
function that returns its name, so that it can easily be printed. You might
think that this should be accomplished using run-time type identification, but
since the actual name of the class involves a template expansion, this turns out
to be the more direct
approach.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I163">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I164"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>measureTime(&#160;)</B> function
template takes as its first template argument the operation that it&#8217;s
going to test &#8211; which is itself a class template selected from the group
defined previously in the listing. The template argument <B>Op</B> will not only
contain the name of the class, but also (decorated into it) the type of the
container it&#8217;s working with. The RTTI <B>typeid(&#160;)</B> operation
allows the name of the class to be extracted as a <B>char*</B>, which can then
be used to create a <B>string</B> called <B>id</B>. This <B>string</B> can be
searched using <B>string::find(&#160;)</B> to look for <B>deque</B>, <B>list</B>
or <B>vector</B>. The <B>bool</B> variable that corresponds to the matching
<B>string</B> becomes <B>true</B>, and this is used to properly initialize the
<B>string</B> <B>cont</B> so the container name can be accurately printed, along
with the test name.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I164">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I165"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once the type of test and the container
being tested has been printed out, the actual test is quite simple. The Standard
C library function <B>clock(&#160;)</B> is used to capture the starting and
ending CPU ticks (this is typically more fine-grained than trying to measure
seconds). Since <B>f</B> is an object of type <B>Op</B>, which is a class that
has an <B>operator(&#160;)</B>, the
line:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I165">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I166"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>f(c, count);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">is actually calling the
<B>operator(&#160;)</B> for the object
<B>f</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I166">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I167"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>main(&#160;)</B>, you can see that
each different type of test is run on each type of container, except for the
containers that don&#8217;t support the particular operation being tested (these
are commented out).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I167">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I168"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you run the program, you&#8217;ll
get comparative performance numbers for your particular compiler and your
particular operating system and platform. Although this is only intended to give
you a feel for the various performance features relative to the other sequences,
it is not a bad way to get a quick-and-dirty idea of the behavior of your
library, and also to compare one library with
another.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I168">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I169"></a>
</FONT><A NAME="_Toc519042034"></A><BR></P></DIV>
<A NAME="Heading222"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
set</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>set</B> produces a container that
will accept only one of each thing you place in it; it also sorts the elements
(sorting isn&#8217;t intrinsic to the conceptual definition of a set, but the
STL <B>set</B> stores its elements in a balanced binary tree to provide rapid
lookups, thus producing sorted results when you traverse it). The first two
examples in this chapter used
<B>set</B>s.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I169">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I170"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Consider the problem of creating an index
for a book. You might like to start with all the words in the book, but you only
want one instance of each word and you want them sorted. Of course, a <B>set</B>
is perfect for this, and solves the problem effortlessly. However, there&#8217;s
also the problem of punctuation and any other non-alpha characters, which must
be stripped off to generate proper words. One solution to this problem is to use
the Standard C library function <B>strtok(&#160;)</B>, which produces tokens (in
our case, words) given a set of delimiters to strip
out:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I170">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I171"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:WordList.cpp</font>
<font color=#009900>// Display a list of words used in a document</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;set&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>const</font> <font color=#0000ff>char</font>* delimiters =
  <font color=#004488>" \t;()\"</font>&lt;&gt;:{}[]+-=&amp;*#.,/\\~";

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  <font color=#0000ff>char</font>* fname = <font color=#004488>"WordList.cpp"</font>;
  <font color=#0000ff>if</font>(argc &gt; 1) fname = argv[1];
  ifstream in(fname);
  assure(in, fname);
  set&lt;string&gt; wordlist;
  string line;
  <font color=#0000ff>while</font>(getline(in, line)) {
    <font color=#009900>// Capture individual words:</font>
    <font color=#0000ff>char</font>* s = <font color=#009900>// Cast probably won&#8217;t crash:</font>
      strtok((<font color=#0000ff>char</font>*)line.c_str(), delimiters);
    <font color=#0000ff>while</font>(s) {
      <font color=#009900>// Automatic type conversion:</font>
      wordlist.insert(s); 
      s = strtok(0, delimiters);
    }
  }
  <font color=#009900>// Output results:</font>
  copy(wordlist.begin(), wordlist.end(),
       ostream_iterator&lt;string&gt;(cout, <font color=#004488>"\n"</font>));
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>strtok(&#160;)
<A NAME="Index499"></A><A NAME="Index500"></A></B>takes the starting address of
a character buffer (the first argument) and looks for delimiters (the second
argument). It replaces the delimiter with a zero, and returns the address of the
beginning of the token. If you call it subsequent times with a first argument of
zero it will continue extracting tokens from the rest of the string until it
finds the end. In this case, the delimiters are those that delimit the keywords
and identifiers of C++, so it extracts these keywords and identifiers. Each word
is turned into a <B>string</B> and placed into the <B>wordlist</B> vector, which
eventually contains the whole file, broken up into
words.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I171">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I172"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You don&#8217;t have to use a <B>set</B>
just to get a sorted sequence. You can use the <B>sort(&#160;)</B> function
(along with a multitude of other functions in the STL) on different STL
containers. However, it&#8217;s likely that <B>set</B> will be
faster.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I172">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I173"></a>
</FONT><A NAME="_Toc519042035"></A><BR></P></DIV>
<A NAME="Heading223"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Eliminating strtok(&#160;)</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Some programmers consider
<B>strtok(&#160;)</B> to be the poorest design in the Standard C library because
it uses a <B>static</B> buffer to hold its data between function calls. This
means:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I173">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I174"></a>
</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">You can&#8217;t use
<B>strtok(&#160;) </B>in two places at the same
time.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">You
can&#8217;t use <B>strtok(&#160;) </B>in a multithreaded
program.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">You
can&#8217;t use <B>strtok(&#160;)</B> in a library that might be used in a
multithreaded
program.</FONT><LI><FONT FACE="Verdana"><B>	</B></FONT><FONT FACE="Georgia"><B>strtok(&#160;)</B>
modifies the input sequence, which can produce unexpected side
effects.</FONT><LI><FONT FACE="Verdana"><B>	</B></FONT><FONT FACE="Georgia"><B>strtok(&#160;)</B>
depends on reading in &#8220;lines&#8221;, which means you need a buffer big
enough for the longest line. This produces both wastefully-sized buffers, and
lines longer than the &#8220;longest&#8221; line. This can also introduce
security holes. (Notice that the buffer size problem was eliminated in
<B>WordList.cpp</B> by using <B>string</B> input, but this required a cast so
that <B>strtok(&#160;)</B> could modify the data in the string &#8211; a
dangerous approach for general-purpose
programming).</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For all these
reasons it seems like a good idea to find an alternative for
<B>strtok(&#160;)</B>. The following example will use an
<B>istreambuf_iterator</B> (introduced earlier) to move the characters from one
place (which happens to be an <B>istream</B>) to another (which happens to be a
<B>string</B>), depending on whether the Standard C library function
<B>isalpha(&#160;)</B> is
true:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I174">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I175"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:WordList2.cpp</font>
<font color=#009900>// Eliminating strtok() from Wordlist.cpp</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-g++295} </font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;set&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;iterator&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  <font color=#0000ff>char</font>* fname = <font color=#004488>"WordList2.cpp"</font>;
  <font color=#0000ff>if</font>(argc &gt; 1) fname = argv[1];
  ifstream in(fname);
  assure(in, fname);
  istreambuf_iterator&lt;<font color=#0000ff>char</font>&gt; p(in), end;
  set&lt;string&gt; wordlist;
  <font color=#0000ff>while</font> (p != end) {
    string word;
    insert_iterator&lt;string&gt; 
      ii(word, word.begin());
    <font color=#009900>// Find the first alpha character:</font>
    <font color=#0000ff>while</font>(!isalpha(*p) &amp;&amp; p != end)
      p++;
    <font color=#009900>// Copy until the first non-alpha character:</font>
    <font color=#0000ff>while</font> (isalpha(*p) &amp;&amp; p != end)
      *ii++ = *p++;
    <font color=#0000ff>if</font> (word.size() != 0)
      wordlist.insert(word);
  } 
  <font color=#009900>// Output results:</font>
  copy(wordlist.begin(), wordlist.end(),
    ostream_iterator&lt;string&gt;(cout, <font color=#004488>"\n"</font>));
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example was suggested by Nathan
Myers, who invented the <B>istreambuf_iterator</B> and its relatives. This
iterator extracts information character-by-character from a stream. Although the
<B>istreambuf_iterator </B>template argument might suggest to you that you could
extract, for example, <B>int</B>s instead of <B>char</B>, that&#8217;s not the
case. The argument must be of some character type &#8211; a regular <B>char</B>
or a wide character.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I175">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I176"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">After the file is open, an
<B>istreambuf_iterator</B> called <B>p</B> is attached to the <B>istream</B> so
characters can be extracted from it. The <B>set&lt;string&gt;</B> called
<B>wordlist</B> will be used to hold the resulting
words.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I176">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I177"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>while</B> loop reads words until
the end of the input stream is found. This is detected using the default
constructor for <B>istreambuf_iterator</B> which produces the past-the-end
iterator object <B>end</B>. Thus, if you want to test to make sure you&#8217;re
not at the end of the stream, you simply say <B>p !=
end</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I177">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I178"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second type of iterator that&#8217;s
used here is the <B>insert_iterator</B>, which creates an iterator that knows
how to insert objects into a container. Here, the &#8220;container&#8221; is the
<B>string</B> called <B>word</B> which, for the purposes of
<B>insert_iterator</B>, behaves like a container. The constructor for
<B>insert_iterator</B> requires the container and an iterator indicating where
it should start inserting the characters. You could also use a
<B>back_insert_iterator</B>, which requires that the container have a
<B>push_back(&#160;)</B> (<B>string</B>
does).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I178">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I179"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">After the <B>while</B> loop sets
everything up, it begins by looking for the first alpha character, incrementing
<B>start</B> until that character is found. Then it copies characters from one
iterator to the other, stopping when a non-alpha character is found. Each
<B>word</B>, assuming it is non-empty, is added to
<B>wordlist</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I179">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I180"></a>
</FONT><A NAME="_Toc519042036"></A><BR></P></DIV>
<A NAME="Heading224"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
StreamTokenizer: <BR>a more flexible solution</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The above program parses its input into
strings of words containing only alpha characters, but that&#8217;s still a
special case compared to the generality of <B>strtok(&#160;)</B>. What
we&#8217;d like now is an actual replacement for <B>strtok(&#160;)</B> so
we&#8217;re never tempted to use it. <B>WordList2.cpp</B> can be modified to
create a class called <B>StreamTokenizer</B> that delivers a new token as a
<B>string</B> whenever you call <B>next(&#160;)</B>, according to the delimiters
you give it upon construction (very similar to
<B>strtok(&#160;)</B>):
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I180">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I181"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:StreamTokenizer.h</font>
<font color=#009900>// C++ Replacement for Standard C strtok()</font>
#ifndef STREAMTOKENIZER_H
#define STREAMTOKENIZER_H
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
  
<font color=#0000ff>class</font> StreamTokenizer {
  <font color=#0000ff>typedef</font> std::istreambuf_iterator&lt;<font color=#0000ff>char</font>&gt; It;
  It p, end;
  std::string delimiters;
  <font color=#0000ff>bool</font> isDelimiter(<font color=#0000ff>char</font> c) {
    <font color=#0000ff>return</font> 
      delimiters.find(c) != std::string::npos;
  }
<font color=#0000ff>public</font>:
  StreamTokenizer(std::istream&amp; is, 
    std::string delim = <font color=#004488>" \t\n;()\"</font>&lt;&gt;:{}[]+-=&amp;*#"
    <font color=#004488>".,</font><font color=#004488>/\\~!0123456789"</font>) : p(is), end(It()),
    delimiters(delim) {}
  std::string next(); <font color=#009900>// Get next token</font>
};
#endif STREAMTOKENIZER_H <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The default delimiters for the
<B>StreamTokenizer</B> constructor extract words with only alpha characters, as
before, but now you can choose different delimiters to parse different tokens.
The implementation of <B>next(&#160;)</B> looks similar to
<B>Wordlist2.cpp</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I181">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I182"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:StreamTokenizer.cpp {O}</font>
<font color=#009900>//{-g++295} </font>
#include <font color=#004488>"StreamTokenizer.h"</font>
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

string StreamTokenizer::next() {
  string result;
  <font color=#0000ff>if</font>(p != end) {
    insert_iterator&lt;string&gt;
      ii(result, result.begin());
    <font color=#0000ff>while</font>(isDelimiter(*p) &amp;&amp; p != end)
      p++;
    <font color=#0000ff>while</font> (!isDelimiter(*p) &amp;&amp; p != end)
      *ii++ = *p++;
  }
  <font color=#0000ff>return</font> result;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first non-delimiter is found, then
characters are copied until a delimiter is found, and the resulting
<B>string</B> is returned. Here&#8217;s a
test:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I182">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I183"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:TokenizeTest.cpp</font>
<font color=#009900>// Test StreamTokenizer</font>
<font color=#009900>//{L} StreamTokenizer ../TestSuite/Test</font>
<font color=#009900>//{-g++295} </font>
#include <font color=#004488>"StreamTokenizer.h"</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;set&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  <font color=#0000ff>char</font>* fname = <font color=#004488>"TokenizeTest.cpp"</font>;
  <font color=#0000ff>if</font>(argc &gt; 1) fname = argv[1];
  ifstream in(fname);
  assure(in, fname);
  StreamTokenizer words(in);
  set&lt;string&gt; wordlist;
  string word;
  <font color=#0000ff>while</font>((word = words.next()).size() != 0)
    wordlist.insert(word);
  <font color=#009900>// Output results:</font>
  copy(wordlist.begin(), wordlist.end(),
    ostream_iterator&lt;string&gt;(cout, <font color=#004488>"\n"</font>));
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now the tool is more reusable than
before, but it&#8217;s still inflexible, because it can only work with an
<B>istream</B>. This isn&#8217;t as bad as it first seems, since a <B>string</B>
can be turned into an <B>istream</B> via an <B>istringstream</B>. But in the
next section we&#8217;ll come up with the most general, reusable tokenizing
tool, and this should give you a feeling of what &#8220;reusable&#8221; really
means, and the effort necessary to create truly reusable
code.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I183">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I184"></a>
</FONT><A NAME="_Toc519042037"></A><BR></P></DIV>
<A NAME="Heading225"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
A completely reusable tokenizer</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since the STL containers and algorithms
all revolve around iterators, the most flexible solution will itself be an
iterator. You could think of the <B>TokenIterator</B> as an iterator that wraps
itself around any other iterator that can produce characters. Because it is
designed as an input iterator (the most primitive type of iterator) it can be
used with any STL algorithm. Not only is it a useful tool in itself, the
<B>TokenIterator</B> is also a good example of how you can design your own
iterators.</FONT><A NAME="fnB22" HREF="#fn22">[22]</A><FONT FACE="Georgia">
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I184">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I185"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>TokenIterator</B> is doubly
flexible: first, you can choose the type of iterator that will produce the
<B>char</B> input. Second, instead of just saying what characters represent the
delimiters, <B>TokenIterator</B> will use a predicate which is a function object
whose <B>operator(&#160;)</B> takes a <B>char</B> and decides if it should be in
the token or not. Although the two examples given here have a static concept of
what characters belong in a token, you could easily design your own function
object to change its state as the characters are read, producing a more
sophisticated parser.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I185">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I186"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following header file contains the
two basic predicates <B>Isalpha</B> and <B>Delimiters</B>, along with the
template for
<B>TokenIterator</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I186">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I187"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:TokenIterator.h</font>
#ifndef TOKENITERATOR_H
#define TOKENITERATOR_H
#include &lt;string&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;cctype&gt;

<font color=#0000ff>struct</font> Isalpha { 
  <font color=#0000ff>bool</font> <font color=#0000ff>operator</font>()(<font color=#0000ff>char</font> c) { 
    <font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std; <font color=#009900>//[[For a compiler bug]]</font>
    <font color=#0000ff>return</font> isalpha(c); 
  }
};

<font color=#0000ff>class</font> Delimiters {
  std::string exclude;
<font color=#0000ff>public</font>:
  Delimiters() {}
  Delimiters(<font color=#0000ff>const</font> std::string&amp; excl) 
    : exclude(excl) {}
  <font color=#0000ff>bool</font> <font color=#0000ff>operator</font>()(<font color=#0000ff>char</font> c) {
    <font color=#0000ff>return</font> exclude.find(c) == std::string::npos;
  }
};

<font color=#0000ff>template</font> &lt;<font color=#0000ff>class</font> InputIter, <font color=#0000ff>class</font> Pred = Isalpha&gt;
<font color=#0000ff>class</font> TokenIterator: <font color=#0000ff>public</font> std::iterator&lt;
  std::input_iterator_tag,std::string,ptrdiff_t&gt;{
  InputIter first;
  InputIter last;
  std::string word;
  Pred predicate;
<font color=#0000ff>public</font>:
  TokenIterator(InputIter begin, InputIter end, 
    Pred pred = Pred()) 
    : first(begin), last(end), predicate(pred) {
      ++*<font color=#0000ff>this</font>; 
  }
  TokenIterator() {} <font color=#009900>// End sentinel</font>
  <font color=#009900>// Prefix increment:</font>
  TokenIterator&amp; <font color=#0000ff>operator</font>++() {
    word.resize(0);
    first = std::find_if(first, last, predicate);
    <font color=#0000ff>while</font> (first != last &amp;&amp; predicate(*first))
      word += *first++;
    <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
  }
  <font color=#009900>// Postfix increment</font>
  <font color=#0000ff>class</font> Proxy { 
    std::string word;
  <font color=#0000ff>public</font>:
    Proxy(<font color=#0000ff>const</font> std::string&amp; w) : word(w) {}
    std::string <font color=#0000ff>operator</font>*() { <font color=#0000ff>return</font> word; } 
  };
  Proxy <font color=#0000ff>operator</font>++(<font color=#0000ff>int</font>) { 
    Proxy d(word);
    ++*<font color=#0000ff>this</font>; 
    <font color=#0000ff>return</font> d; 
  }
  <font color=#009900>// Produce the actual value:</font>
  std::string <font color=#0000ff>operator</font>*() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> word; }
  std::string* <font color=#0000ff>operator</font>-&gt;() <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> &amp;(<font color=#0000ff>operator</font>*()); 
  }
  <font color=#009900>// Compare iterators:</font>
  <font color=#0000ff>bool</font> <font color=#0000ff>operator</font>==(<font color=#0000ff>const</font> TokenIterator&amp;) { 
    <font color=#0000ff>return</font> word.size() == 0 &amp;&amp; first == last; 
  }
  <font color=#0000ff>bool</font> <font color=#0000ff>operator</font>!=(<font color=#0000ff>const</font> TokenIterator&amp; rv) { 
    <font color=#0000ff>return</font> !(*<font color=#0000ff>this</font> == rv);
  }
};
#endif <font color=#009900>// TOKENITERATOR_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>TokenIterator</B> is inherited from
the <B>std::iterator</B> template. It might appear that there&#8217;s some kind
of functionality that comes with <B>std::iterator</B>, but it is purely a way of
tagging an iterator so that a container that uses it knows what it&#8217;s
capable of. Here, you can see <B>input_iterator_tag</B> as a template argument
&#8211; this tells anyone who asks that a <B>TokenIterator</B> only has the
capabilities of an input iterator, and cannot be used with algorithms requiring
more sophisticated iterators. Apart from the tagging, <B>std::iterator</B>
doesn&#8217;t do anything else, which means you must design all the other
functionality in
yourself.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I187">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I188"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>TokenIterator</B> may look a little
strange at first, because the first constructor requires both a
&#8220;begin&#8221; and &#8220;end&#8221; iterator as arguments, along with the
predicate. Remember that this is a &#8220;wrapper&#8221; iterator that has no
idea of how to tell whether it&#8217;s at the end of its input source, so the
ending iterator is necessary in the first constructor. The reason for the second
(default) constructor is that the STL algorithms (and any algorithms you write)
need a <B>TokenIterator </B>sentinel to be the past-the-end value. Since all the
information necessary to see if the <B>TokenIterator</B> has reached the end of
its input is collected in the first constructor, this second constructor creates
a <B>TokenIterator</B> that is merely used as a placeholder in
algorithms.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I188">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I189"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The core of the behavior happens in
<B>operator++</B>. This erases the current value of <B>word</B> using
<B>string::resize(&#160;)</B>, then finds the first character that satisfies the
predicate (thus discovering the beginning of the new token) using
<B>find_if(&#160;)</B> (from the STL algorithms, discussed in the following
chapter). The resulting iterator is assigned to <B>first</B>, thus moving
<B>first</B> forward to the beginning of the token. Then, as long as the end of
the input is not reached and the predicate is satisfied, characters are copied
into the word from the input. Finally, the TokenIterator object is returned, and
must be dereferenced to access the new
token.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I189">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I190"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The postfix increment requires a proxy
object to hold the value before the increment, so it can be returned (see the
operator overloading chapter for more details of this). Producing the actual
value is a straightforward <B>operator*</B>. The only other functions that must
be defined for an output iterator are the <B>operator==</B> and
<B>operator!=</B> to indicate whether the <B>TokenIterator</B> has reached the
end of its input. You can see that the argument for <B>operator== </B>is ignored
&#8211; it only cares about whether it has reached its internal <B>last</B>
iterator. Notice that <B>operator!=</B> is defined in terms of
<B>operator==</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I190">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I191"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A good test of <B>TokenIterator</B>
includes a number of different sources of input characters including a
<B>streambuf_iterator</B>, a <B>char*</B>, and a
<B>deque&lt;char&gt;::iterator</B>. Finally, the original <B>Wordlist.cpp</B>
problem is solved:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I191">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I192"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:TokenIteratorTest.cpp</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-g++295}</font>
<font color=#009900>//{-g++3}</font>
#include <font color=#004488>"TokenIterator.h"</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;set&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  <font color=#0000ff>char</font>* fname = <font color=#004488>"TokenIteratorTest.cpp"</font>;
  <font color=#0000ff>if</font>(argc &gt; 1) fname = argv[1];
  ifstream in(fname);
  assure(in, fname);
  ostream_iterator&lt;string&gt; out(cout, <font color=#004488>"\n"</font>);
  <font color=#0000ff>typedef</font> istreambuf_iterator&lt;<font color=#0000ff>char</font>&gt; IsbIt;
  IsbIt begin(in), isbEnd;
  Delimiters 
    delimiters(<font color=#004488>" \t\n~;()\"</font>&lt;&gt;:{}[]+-=&amp;*#.,/\\");
  TokenIterator&lt;IsbIt, Delimiters&gt; 
    wordIter(begin, isbEnd, delimiters),
    end;
  vector&lt;string&gt; wordlist;
  copy(wordIter, end, back_inserter(wordlist));
  <font color=#009900>// Output results:</font>
  copy(wordlist.begin(), wordlist.end(), out);
  *out++ = <font color=#004488>"-----------------------------------"</font>;
  <font color=#009900>// Use a char array as the source:</font>
  <font color=#0000ff>char</font>* cp = 
    <font color=#004488>"typedef std::istreambuf_iterator&lt;char&gt; It"</font>;
  TokenIterator&lt;<font color=#0000ff>char</font>*, Delimiters&gt;
    charIter(cp, cp + strlen(cp), delimiters),
    end2;
  vector&lt;string&gt; wordlist2;
  copy(charIter, end2, back_inserter(wordlist2));
  copy(wordlist2.begin(), wordlist2.end(), out);
  *out++ = <font color=#004488>"-----------------------------------"</font>;
  <font color=#009900>// Use a deque&lt;char&gt; as the source:</font>
  ifstream in2(<font color=#004488>"TokenIteratorTest.cpp"</font>);
  deque&lt;<font color=#0000ff>char</font>&gt; dc;
  copy(IsbIt(in2), IsbIt(), back_inserter(dc));
  TokenIterator&lt;deque&lt;<font color=#0000ff>char</font>&gt;::iterator,Delimiters&gt;
    dcIter(dc.begin(), dc.end(), delimiters),
    end3;
  vector&lt;string&gt; wordlist3;
  copy(dcIter, end3, back_inserter(wordlist3));
  copy(wordlist3.begin(), wordlist3.end(), out);
  *out++ = <font color=#004488>"-----------------------------------"</font>;
  <font color=#009900>// Reproduce the Wordlist.cpp example:</font>
  ifstream in3(<font color=#004488>"TokenIteratorTest.cpp"</font>);
  TokenIterator&lt;IsbIt, Delimiters&gt;
    wordIter2(IsbIt(in3), isbEnd, delimiters);
  set&lt;string&gt; wordlist4;
  <font color=#0000ff>while</font>(wordIter2 != end)
    wordlist4.insert(*wordIter2++);
  copy(wordlist4.begin(), wordlist4.end(), out);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When using an <B>istreambuf_iterator</B>,
you create one to attach to the <B>istream</B> object, and one with the default
constructor as the past-the-end marker. Both of these are used to create the
<B>TokenIterator</B> that will actually produce the tokens; the default
constructor produces the faux <B>TokenIterator</B> past-the-end sentinel (this
is just a placeholder, and as mentioned previously is actually ignored). The<B>
TokenIterator</B> produces <B>string</B>s that are inserted into a container
which must, naturally, be a container of <B>string</B> &#8211; here a
<B>vector&lt;string&gt;</B> is used in all cases except the last (you could also
concatenate the results onto a <B>string</B>). Other than that, a
<B>TokenIterator</B> works like any other input
iterator.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I192">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I193"></a>
</FONT><A NAME="_Toc519042038"></A><BR></P></DIV>
<A NAME="Heading226"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
stack</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>stack</B>, along with the
<B>queue</B> and <B>priority_queue</B>, are classified as <I>adapters</I>, which
means they are implemented using one of the basic sequence containers:
<B>vector</B>, <B>list</B> or <B>deque</B>. This, in my opinion, is an
unfortunate case of confusing what something does with the details of its
underlying implementation &#8211; the fact that these are called
&#8220;adapters&#8221; is of primary value only to the creator of the library.
When you use them, you generally don&#8217;t care that they&#8217;re adapters,
but instead that they solve your problem. Admittedly there are times when
it&#8217;s useful to know that you can choose an alternate implementation or
build an adapter from an existing container object, but that&#8217;s generally
one level removed from the adapter&#8217;s behavior. So, while you may see it
emphasized elsewhere that a particular container is an adapter, I shall only
point out that fact when it&#8217;s useful. Note that each type of adapter has a
default container that it&#8217;s built upon, and this default is the most
sensible implementation, so in most cases you won&#8217;t need to concern
yourself with the underlying
implementation.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I193">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I194"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example shows
<B>stack&lt;string&gt;</B> implemented in the three possible ways: the default
(which uses <B>deque</B>), with a <B>vector</B> and with a
<B>list</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I194">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I195"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:Stack1.cpp</font>
<font color=#009900>// Demonstrates the STL stack</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;stack&gt;
#include &lt;list&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#009900>// Default: deque&lt;string&gt;:</font>
<font color=#0000ff>typedef</font> stack&lt;string&gt; Stack1;
<font color=#009900>// Use a vector&lt;string&gt;:</font>
<font color=#0000ff>typedef</font> stack&lt;string, vector&lt;string&gt; &gt; Stack2;
<font color=#009900>// Use a list&lt;string&gt;:</font>
<font color=#0000ff>typedef</font> stack&lt;string, list&lt;string&gt; &gt; Stack3;

<font color=#0000ff>int</font> main() {
  ifstream in(<font color=#004488>"Stack1.cpp"</font>);
  Stack1 textlines; <font color=#009900>// Try the different versions</font>
  <font color=#009900>// Read file and store lines in the stack:</font>
  string line;
  <font color=#0000ff>while</font>(getline(in, line)) 
    textlines.push(line + <font color=#004488>"\n"</font>);
  <font color=#009900>// Print lines from the stack and pop them:</font>
  <font color=#0000ff>while</font>(!textlines.empty()) {
    cout &lt;&lt; textlines.top();
    textlines.pop();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>top(&#160;)</B> and
<B>pop(&#160;)</B> operations will probably seem non-intuitive if you&#8217;ve
used other <B>stack</B> classes. When you call <B>pop(&#160;)</B> it returns
void rather than the top element that you might have expected. If you want the
top element, you get a reference to it with <B>top(&#160;)</B>. It turns out
this is more efficient, since a traditional <B>pop(&#160;)</B> would have to
return a value rather than a reference, and thus invoke the copy-constructor.
When you&#8217;re using a <B>stack</B> (or a <B>priority_queue</B>, described
later) you can efficiently refer to <B>top(&#160;)</B> as many times as you
want, then discard the top element explicitly using <B>pop(&#160;)</B> (perhaps
if some other term than the familiar &#8220;pop&#8221; had been used, this would
have been a bit
clearer).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I195">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I196"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>stack</B> template has a very
simple interface, essentially the member functions you see above. It
doesn&#8217;t have sophisticated forms of initialization or access, but if you
need that you can use the underlying container that the <B>stack</B> is
implemented upon. For example, suppose you have a function that expects a
<B>stack</B> interface but in the rest of your program you need the objects
stored in a <B>list</B>. The following program stores each line of a file along
with the leading number of spaces in that line (you might imagine it as a
starting point for performing some kinds of source-code
reformatting):
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I196">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I197"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:Stack2.cpp</font>
<font color=#009900>// Converting a list to a stack</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-msc}</font>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;stack&gt;
#include &lt;list&gt;
#include &lt;string&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#009900>// Expects a stack:</font>
<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> Stk&gt;
<font color=#0000ff>void</font> stackOut(Stk&amp; s, ostream&amp; os = cout) {
  <font color=#0000ff>while</font>(!s.empty()) {
    os &lt;&lt; s.top() &lt;&lt; <font color=#004488>"\n"</font>;
    s.pop();
  }
}

<font color=#0000ff>class</font> Line {
  string line; <font color=#009900>// Without leading spaces</font>
  <font color=#0000ff>int</font> lspaces; <font color=#009900>// Number of leading spaces</font>
<font color=#0000ff>public</font>:
  Line(string s) : line(s) {
    lspaces = line.find_first_not_of(' ');
    <font color=#0000ff>if</font>(lspaces == string::npos)
      lspaces = 0;
    line = line.substr(lspaces);
  }
  <font color=#0000ff>friend</font> ostream&amp; 
  <font color=#0000ff>operator</font>&lt;&lt;(ostream&amp; os, <font color=#0000ff>const</font> Line&amp; l) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; l.lspaces; i++)
      os &lt;&lt; ' ';
    <font color=#0000ff>return</font> os &lt;&lt; l.line;
  }
  <font color=#009900>// Other functions here...</font>
};

<font color=#0000ff>int</font> main() {
  ifstream in(<font color=#004488>"Stack2.cpp"</font>);
  list&lt;Line&gt; lines;
  <font color=#009900>// Read file and store lines in the list:</font>
  string s;
  <font color=#0000ff>while</font>(getline(in, s)) 
    lines.push_front(s);
  <font color=#009900>// Turn the list into a stack for printing:</font>
  stack&lt;Line, list&lt;Line&gt; &gt; stk(lines);
  stackOut(stk);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The function that requires the
<B>stack</B> interface just sends each <B>top(&#160;)</B> object to an
<B>ostream</B> and then removes it by calling <B>pop(&#160;)</B>. The
<B>Line</B> class determines the number of leading spaces, then stores the
contents of the line <I>without</I> the leading spaces. The <B>ostream</B>
<B>operator&lt;&lt;</B> re-inserts the leading spaces so the line prints
properly, but you can easily change the number of spaces by changing the value
of <B>lspaces</B> (the member functions to do this are not shown
here).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I197">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I198"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>main(&#160;)</B>, the input file is
read into a <B>list&lt;Line&gt;</B>, then a <B>stack</B> is wrapped around this
list so it can be sent to
<B>stackOut(&#160;)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I198">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I199"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You cannot iterate through a
<B>stack</B>; this emphasizes that you only want to perform <B>stack</B>
operations when you create a <B>stack</B>. You can get equivalent
&#8220;stack&#8221; functionality using a <B>vector</B> and its
<B>back(&#160;)</B>, <B>push_back(&#160;)</B> and <B>pop_back(&#160;)</B>
methods, and then you have all the additional functionality of the
<B>vector</B>. <B>Stack1.cpp</B> can be rewritten to show
this:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I199">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I200"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:Stack3.cpp</font>
<font color=#009900>// Using a vector as a stack; modified Stack1.cpp</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  ifstream in(<font color=#004488>"Stack3.cpp"</font>);
  vector&lt;string&gt; textlines;
  string line;
  <font color=#0000ff>while</font>(getline(in, line)) 
    textlines.push_back(line + <font color=#004488>"\n"</font>);
  <font color=#0000ff>while</font>(!textlines.empty()) {
    cout &lt;&lt; textlines.back();
    textlines.pop_back();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll see this produces the same
output as <B>Stack1.cpp</B>, but you can now perform <B>vector</B> operations as
well. Of course, <B>list</B> has the additional ability to push things at the
front, but it&#8217;s generally less efficient than using
<B>push_back(&#160;)</B> with <B>vector</B>. (In addition, <B>deque</B> is
usually more efficient than <B>list</B> for pushing things at the
front).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I200">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I201"></a>
</FONT><A NAME="_Toc519042039"></A><BR></P></DIV>
<A NAME="Heading227"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
queue</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>queue</B> is a restricted form of
a <B>deque</B> &#8211; you can only enter elements at one end, and pull them off
the other end. Functionally, you could use a <B>deque</B> anywhere you need a
<B>queue</B>, and you would then also have the additional functionality of the
<B>deque</B>. The only reason you need to use a <B>queue</B> rather than a
<B>deque</B>, then, is if you want to emphasize that you will only be performing
queue-like behavior.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I201">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I202"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>queue</B> is an adapter class like
<B>stack</B>, in that it is built on top of another sequence container. As you
might guess, the ideal implementation for a <B>queue</B> is a <B>deque</B>, and
that is the default template argument for the <B>queue</B>; you&#8217;ll rarely
need a different
implementation.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I202">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I203"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Queues are often used when modeling
systems where some elements of the system are waiting to be served by other
elements in the system. A classic example of this is the &#8220;bank-teller
problem,&#8221; where you have customers arriving at random intervals, getting
into a line, and then being served by a set of tellers. Since the customers
arrive randomly and each take a random amount of time to be served,
there&#8217;s no way to deterministically know how long the line will be at any
time. However, it&#8217;s possible to simulate the situation and see what
happens.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I203">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I204"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A problem in performing this simulation
is the fact that, in effect, each customer and teller should be run by a
separate process. What we&#8217;d like is a multithreaded environment, then each
customer or teller would have their own thread. However, Standard C++ has no
model for multithreading so there is no standard solution to this problem. On
the other hand, with a little adjustment to the code it&#8217;s possible to
simulate enough multithreading to provide a satisfactory solution to our
problem.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I204">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I205"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Multithreading means you have multiple
threads of control running at once, in the same address space (this differs from
<I>multitasking</I>, where you have different processes each running in their
own address space). The trick is that you have fewer CPUs than you do threads
(and very often only one CPU) so to give the illusion that each thread has its
own CPU there is a <I>time-slicing</I> mechanism that says &#8220;OK, current
thread &#8211; you&#8217;ve had enough time. I&#8217;m going to stop you and go
give time to some other thread.&#8221; This automatic stopping and starting of
threads is called <I>pre-emptive </I>and it means you don&#8217;t need to manage
the threading process at
all.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I205">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I206"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An alternative approach is for each
thread to voluntarily yield the CPU to the scheduler, which then goes and finds
another thread that needs running. This is easier to synthesize, but it still
requires a method of &#8220;swapping&#8221; out one thread and swapping in
another (this usually involves saving the stack frame and using the standard C
library functions <B>setjmp(&#160;)</B> and <B>longjmp(&#160;)</B>; see my
article in the (XX) issue of Computer Language magazine for an example). So
instead, we&#8217;ll build the time-slicing into the classes in the system. In
this case, it will be the tellers that represent the &#8220;threads,&#8221; (the
customers will be passive) so each teller will have an infinite-looping
<B>run(&#160;)</B> method that will execute for a certain number of &#8220;time
units,&#8221; and then simply return. By using the ordinary return mechanism, we
eliminate the need for any swapping. The resulting program, although small,
provides a remarkably reasonable
simulation:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I206">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I207"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:BankTeller.cpp</font>
<font color=#009900>// Using a queue and simulated multithreading</font>
<font color=#009900>// To model a bank teller system</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;list&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Customer {
  <font color=#0000ff>int</font> serviceTime;
<font color=#0000ff>public</font>:
  Customer() : serviceTime(0) {}
  Customer(<font color=#0000ff>int</font> tm) : serviceTime(tm) {}
  <font color=#0000ff>int</font> getTime() { <font color=#0000ff>return</font> serviceTime; }
  <font color=#0000ff>void</font> setTime(<font color=#0000ff>int</font> newtime) {
    serviceTime = newtime;
  }
  <font color=#0000ff>friend</font> ostream&amp; 
  <font color=#0000ff>operator</font>&lt;&lt;(ostream&amp; os, <font color=#0000ff>const</font> Customer&amp; c) {
    <font color=#0000ff>return</font> os &lt;&lt; '[' &lt;&lt; c.serviceTime &lt;&lt; ']';
  }
};

<font color=#0000ff>class</font> Teller {
  queue&lt;Customer&gt;&amp; customers;
  Customer current;
  <font color=#0000ff>enum</font> { slice = 5 };
  <font color=#0000ff>int</font> ttime; <font color=#009900>// Time left in slice</font>
  <font color=#0000ff>bool</font> busy; <font color=#009900>// Is teller serving a customer?</font>
<font color=#0000ff>public</font>:
  Teller(queue&lt;Customer&gt;&amp; cq) 
    : customers(cq), ttime(0), busy(<font color=#0000ff>false</font>) {}
  Teller&amp; <font color=#0000ff>operator</font>=(<font color=#0000ff>const</font> Teller&amp; rv) {
    customers = rv.customers;
    current = rv.current;
    ttime = rv.ttime;
    busy = rv.busy;
    <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
  }
  <font color=#0000ff>bool</font> isBusy() { <font color=#0000ff>return</font> busy; }
  <font color=#0000ff>void</font> run(<font color=#0000ff>bool</font> recursion = <font color=#0000ff>false</font>) {
    <font color=#0000ff>if</font>(!recursion)
      ttime = slice;
    <font color=#0000ff>int</font> servtime = current.getTime();
    <font color=#0000ff>if</font>(servtime &gt; ttime) {
      servtime -= ttime;
      current.setTime(servtime);
      busy = <font color=#0000ff>true</font>; <font color=#009900>// Still working on current</font>
      <font color=#0000ff>return</font>;
    }
    <font color=#0000ff>if</font>(servtime &lt; ttime) {
      ttime -= servtime;
      <font color=#0000ff>if</font>(!customers.empty()) {
        current = customers.front();
        customers.pop(); <font color=#009900>// Remove it</font>
        busy = <font color=#0000ff>true</font>;
        run(<font color=#0000ff>true</font>); <font color=#009900>// Recurse</font>
      }
      <font color=#0000ff>return</font>;
    }
    <font color=#0000ff>if</font>(servtime == ttime) {
      <font color=#009900>// Done with current, set to empty:</font>
      current = Customer(0);
      busy = <font color=#0000ff>false</font>;
      <font color=#0000ff>return</font>; <font color=#009900>// No more time in this slice</font>
    }
  }
};

<font color=#009900>// Inherit to access protected implementation:</font>
<font color=#0000ff>class</font> CustomerQ : <font color=#0000ff>public</font> queue&lt;Customer&gt; {
<font color=#0000ff>public</font>:
  <font color=#0000ff>friend</font> ostream&amp; 
  <font color=#0000ff>operator</font>&lt;&lt;(ostream&amp; os, <font color=#0000ff>const</font> CustomerQ&amp; cd) {
    copy(cd.c.begin(), cd.c.end(), 
      ostream_iterator&lt;Customer&gt;(os, <font color=#004488>""</font>));
    <font color=#0000ff>return</font> os;
  }
};

<font color=#0000ff>int</font> main() {
  CustomerQ customers;
  list&lt;Teller&gt; tellers;
  <font color=#0000ff>typedef</font> list&lt;Teller&gt;::iterator TellIt;
  tellers.push_back(Teller(customers));
  srand(time(0)); <font color=#009900>// Seed random number generator</font>
  clock_t ticks = clock();
  <font color=#009900>// Run simulation for at least 5 seconds:</font>
  <font color=#0000ff>while</font>(clock() &lt; ticks + 5 * CLK_TCK) {
    <font color=#009900>// Add a random number of customers to the</font>
    <font color=#009900>// queue, with random service times:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; rand() % 5; i++)
      customers.push(Customer(rand() % 15 + 1));
    cout &lt;&lt; '{' &lt;&lt; tellers.size() &lt;&lt; '}' 
      &lt;&lt; customers &lt;&lt; endl;
    <font color=#009900>// Have the tellers service the queue:</font>
    <font color=#0000ff>for</font>(TellIt i = tellers.begin(); 
      i != tellers.end(); i++)
      (*i).run();
    cout &lt;&lt; '{' &lt;&lt; tellers.size() &lt;&lt; '}' 
      &lt;&lt; customers &lt;&lt; endl;
    <font color=#009900>// If line is too long, add another teller:</font>
    <font color=#0000ff>if</font>(customers.size() / tellers.size() &gt; 2)
      tellers.push_back(Teller(customers));
    <font color=#009900>// If line is short enough, remove a teller:</font>
    <font color=#0000ff>if</font>(tellers.size() &gt; 1 &amp;&amp; 
      customers.size() / tellers.size() &lt; 2)
      <font color=#0000ff>for</font>(TellIt i = tellers.begin();
        i != tellers.end(); i++)
        <font color=#0000ff>if</font>(!(*i).isBusy()) {
          tellers.erase(i);
          <font color=#0000ff>break</font>; <font color=#009900>// Out of for loop</font>
        }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each customer requires a certain amount
of service time, which is the number of time units that a teller must spend on
the customer in order to serve that customer&#8217;s needs. Of course, the
amount of service time will be different for each customer, and will be
determined randomly. In addition, you won&#8217;t know how many customers will
be arriving in each interval, so this will also be determined randomly.

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I207">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I208"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Customer </B>objects are kept in a
<B>queue&lt;Customer&gt;</B>, and each <B>Teller</B> object keeps a reference to
that queue.<B> </B>When a <B>Teller</B> object is finished with its current
<B>Customer</B> object, that <B>Teller</B> will get another <B>Customer</B> from
the queue and begin working on the new <B>Customer</B>, reducing the
<B>Customer</B>&#8217;s service time during each time slice that the
<B>Teller</B> is allotted. All this logic is in the <B>run(&#160;)</B> member
function, which is basically a three-way <B>if</B> statement based on whether
the amount of time necessary to serve the customer is less than, greater than or
equal to the amount of time left in the teller&#8217;s current time slice.
Notice that if the <B>Teller</B> has more time after finishing with a
<B>Customer</B>, it gets a new customer and recurses into
itself.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I208">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I209"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Just as with a <B>stack</B>, when you use
a <B>queue</B>, it&#8217;s only a <B>queue</B> and doesn&#8217;t have any of the
other functionality of the basic sequence containers. This includes the ability
to get an iterator in order to step through the <B>stack</B>. However, the
underlying sequence container (that the <B>queue</B> is built upon) is held as a
<B>protected</B> member inside the <B>queue</B>, and the identifier for this
member is specified in the C++ Standard as &#8216;<B>c</B>&#8217;, which means
that you can inherit from <B>queue</B> in order to access the underlying
implementation. The <B>CustomerQ</B> class does exactly that, for the sole
purpose of defining an <B>ostream</B> <B>operator&lt;&lt;</B> that can iterate
through the <B>queue</B> and print out its
members.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I209">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I210"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The driver for the simulation is the
<B>while</B> loop in <B>main(&#160;)</B>, which uses processor ticks (defined in
<B>&lt;ctime&gt;</B>) to determine if the simulation has run for at least 5
seconds. At the beginning of each pass through the loop, a random number of
customers are added, with random service times. Both the number of tellers and
the queue contents are displayed so you can see the state of the system. After
running each teller, the display is repeated. At this point, the system adapts
by comparing the number of customers and the number of tellers; if the line is
too long another teller is added and if it is short enough a teller can be
removed. It is in this adaptation section of the program that you can experiment
with policies regarding the optimal addition and removal of tellers. If this is
the only section that you&#8217;re modifying, you may want to encapsulate
policies inside of different
objects.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I210">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I211"></a>
</FONT><A NAME="_Toc519042040"></A><BR></P></DIV>
<A NAME="Heading228"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Priority queues</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you <B>push(&#160;)</B> an object
onto a <B>priority_queue</B>, that object is sorted into the queue according to
a function or function object (you can allow the default <B>less</B> template to
supply this, or provide one of your own). The <B>priority_queue</B> ensures that
when you look at the <B>top(&#160;)</B> element, it will be the one with the
highest priority. When you&#8217;re done with it, you call <B>pop(&#160;)</B> to
remove it and bring the next one into place. Thus, the <B>priority_queue</B> has
nearly the same interface as a <B>stack</B>, but it behaves
differently.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I211">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I212"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Like <B>stack</B> and <B>queue</B>,
<B>priority_queue</B> is an adapter which is built on top of one of the basic
sequences &#8211; the default is
<B>vector</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I212">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I213"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s trivial to make a
<B>priority_queue</B> that works with
<B>int</B>s:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I213">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I214"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:PriorityQueue1.cpp</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  priority_queue&lt;<font color=#0000ff>int</font>&gt; pqi;
  srand(time(0)); <font color=#009900>// Seed random number generator</font>
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 100; i++)
    pqi.push(rand() % 25);
  <font color=#0000ff>while</font>(!pqi.empty()) {
    cout &lt;&lt; pqi.top() &lt;&lt; ' ';
    pqi.pop();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This pushes into the <B>priority_queue
</B>100 random values from 0 to 24. When you run this program you&#8217;ll see
that duplicates are allowed, and the highest values appear first. To show how
you can change the ordering by providing your own function or function object,
the following program gives lower-valued numbers the highest
priority:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I214">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I215"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:PriorityQueue2.cpp</font>
<font color=#009900>// Changing the priority</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>struct</font> Reverse {
  <font color=#0000ff>bool</font> <font color=#0000ff>operator</font>()(<font color=#0000ff>int</font> x, <font color=#0000ff>int</font> y) {
    <font color=#0000ff>return</font> y &lt; x;
  }
};

<font color=#0000ff>int</font> main() {
  priority_queue&lt;<font color=#0000ff>int</font>, vector&lt;<font color=#0000ff>int</font>&gt;, Reverse&gt; pqi;
  <font color=#009900>// Could also say:</font>
  <font color=#009900>// priority_queue&lt;int, vector&lt;int&gt;, </font>
  <font color=#009900>//   greater&lt;int&gt; &gt; pqi;</font>
  srand(time(0));
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 100; i++)
    pqi.push(rand() % 25);
  <font color=#0000ff>while</font>(!pqi.empty()) {
    cout &lt;&lt; pqi.top() &lt;&lt; ' ';
    pqi.pop();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although you can easily use the Standard
Library <B>greater</B> template to produce the predicate, I went to the trouble
of creating <B>Reverse</B> so you could see how to do it in case you have a more
complex scheme for ordering your
objects.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I215">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I216"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you look at the description for
<B>priority_queue</B>, you see that the constructor can be handed a
&#8220;Compare&#8221; object, as shown above. If you don&#8217;t use your own
&#8220;Compare&#8221; object, the default template behavior is the <B>less
</B>template function. You might think (as I did) that it would make sense to
leave the template instantiation as <B>priority_queue&lt;int&gt;</B>, thus using
the default template arguments of <B>vector&lt;int&gt;</B> and
<B>less&lt;int&gt;</B>. Then you could inherit a new class from
<B>less&lt;int&gt;</B>, redefine <B>operator(&#160;)</B> and hand an object of
that type to the <B>priority_queue</B> constructor. I tried this, and got it to
compile, but the resulting program produced the same old <B>less&lt;int&gt;</B>
behavior. The answer lies in the <B>less&lt; &gt;
</B>template:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I216">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I217"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>template</font> &lt;<font color=#0000ff>class</font> T&gt;
<font color=#0000ff>struct</font> less : binary_function&lt;T, T, <font color=#0000ff>bool</font>&gt; {
  <font color=#009900>// Other stuff...</font>
  <font color=#0000ff>bool</font> <font color=#0000ff>operator</font>()(<font color=#0000ff>const</font> T&amp; x, <font color=#0000ff>const</font> T&amp; y) <font color=#0000ff>const</font> {
    <font color=#0000ff>return</font> x &lt; y;
  }
};</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>operator(&#160;)</B> is not
<B>virtual</B>, so even though the constructor takes your subclass of
<B>less&lt;int&gt;</B> by reference (thus it doesn&#8217;t slice it down to a
plain <B>less&lt;int&gt;</B>), when <B>operator(&#160;)</B> is called, it is the
base-class version that is used. While it is generally reasonable to expect
ordinary classes to behave polymorphically, you cannot make this assumption when
using the STL.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I217">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I218"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, a <B>priority_queue</B> of
<B>int</B> is trivial. A more interesting problem is a to-do list, where each
object contains a <B>string</B> and a primary and secondary priority
value:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I218">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I219"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:PriorityQueue3.cpp</font>
<font color=#009900>// A more complex use of priority_queue</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;string&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> ToDoItem {
  <font color=#0000ff>char</font> primary;
  <font color=#0000ff>int</font> secondary;
  string item;
<font color=#0000ff>public</font>:
  ToDoItem(string td, <font color=#0000ff>char</font> pri ='A', <font color=#0000ff>int</font> sec =1)
    : item(td), primary(pri), secondary(sec) {}
  <font color=#0000ff>friend</font> <font color=#0000ff>bool</font> <font color=#0000ff>operator</font>&lt;(
    <font color=#0000ff>const</font> ToDoItem&amp; x, <font color=#0000ff>const</font> ToDoItem&amp; y) {
    <font color=#0000ff>if</font>(x.primary &gt; y.primary) 
      <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
    <font color=#0000ff>if</font>(x.primary == y.primary)
      <font color=#0000ff>if</font>(x.secondary &gt; y.secondary) 
        <font color=#0000ff>return</font> <font color=#0000ff>true</font>;
    <font color=#0000ff>return</font> <font color=#0000ff>false</font>;
  }
  <font color=#0000ff>friend</font> ostream&amp; 
  <font color=#0000ff>operator</font>&lt;&lt;(ostream&amp; os, <font color=#0000ff>const</font> ToDoItem&amp; td) {
    <font color=#0000ff>return</font> os &lt;&lt; td.primary &lt;&lt; td.secondary 
      &lt;&lt; <font color=#004488>": "</font> &lt;&lt; td.item;
  }
};

<font color=#0000ff>int</font> main() {
  priority_queue&lt;ToDoItem&gt; toDoList;
  toDoList.push(ToDoItem(<font color=#004488>"Empty trash"</font>, 'C', 4));
  toDoList.push(ToDoItem(<font color=#004488>"Feed dog"</font>, 'A', 2));
  toDoList.push(ToDoItem(<font color=#004488>"Feed bird"</font>, 'B', 7));
  toDoList.push(ToDoItem(<font color=#004488>"Mow lawn"</font>, 'C', 3));
  toDoList.push(ToDoItem(<font color=#004488>"Water lawn"</font>, 'A', 1));
  toDoList.push(ToDoItem(<font color=#004488>"Feed cat"</font>, 'B', 1));
  <font color=#0000ff>while</font>(!toDoList.empty()) {
    cout &lt;&lt; toDoList.top() &lt;&lt; endl;
    toDoList.pop();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ToDoItem</B>&#8217;s
<B>operator&lt;</B> must be a non-member function for it to work with
<B>less&lt; &gt;</B>. Other than that, everything happens automatically. The
output is:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I219">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I220"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>A1: Water lawn
A2: Feed dog
B1: Feed cat
B7: Feed bird
C3: Mow lawn
C4: Empty trash</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that you cannot iterate through a
<B>priority_queue</B>. However, it is possible to emulate the behavior of a
<B>priority_queue</B> using a <B>vector</B>, thus allowing you access to that
<B>vector</B>. You can do this by looking at the implementation of
<B>priority_queue</B>, which uses <B>make_heap(&#160;)</B>,
<B>push_heap(&#160;)</B> and <B>pop_heap(&#160;)</B> (they are the soul of the
<B>priority_queue</B>; in fact you could say that the heap <I>is</I> the
priority queue and <B>priority_queue </B>is just a wrapper around it). This
turns out to be reasonably straightforward, but you might think that a shortcut
is possible. Since the container used by <B>priority_queue</B> is
<B>protected</B> (and has the identifier, according to the Standard C++
specification, named <B>c</B>) you can inherit a new class which provides access
to the underlying
implementation:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I220">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I221"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:PriorityQueue4.cpp</font>
<font color=#009900>// Manipulating the underlying implementation</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> PQI : <font color=#0000ff>public</font> priority_queue&lt;<font color=#0000ff>int</font>&gt; {
<font color=#0000ff>public</font>:
  vector&lt;<font color=#0000ff>int</font>&gt;&amp; impl() { <font color=#0000ff>return</font> c; }
};

<font color=#0000ff>int</font> main() {
  PQI pqi;
  srand(time(0));
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 100; i++)
    pqi.push(rand() % 25);
  copy(pqi.impl().begin(), pqi.impl().end(),
    ostream_iterator&lt;<font color=#0000ff>int</font>&gt;(cout, <font color=#004488>" "</font>));
  cout &lt;&lt; endl;
  <font color=#0000ff>while</font>(!pqi.empty()) {
    cout &lt;&lt; pqi.top() &lt;&lt; ' ';
    pqi.pop();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">However, if you run this program
you&#8217;ll discover that the <B>vector</B> doesn&#8217;t contain the items in
the descending order that you get when you call <B>pop(&#160;)</B>, the order
that you want from the priority queue. It would seem that if you want to create
a <B>vector</B> that is a priority queue, you have to do it by hand, like
this:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I221">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I222"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:PriorityQueue5.cpp</font>
<font color=#009900>// Building your own priority queue</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> T, <font color=#0000ff>class</font> Compare&gt;
<font color=#0000ff>class</font> PQV : <font color=#0000ff>public</font> vector&lt;T&gt; {
  Compare comp;
<font color=#0000ff>public</font>:
  PQV(Compare cmp = Compare()) : comp(cmp) {
    make_heap(begin(), end(), comp);
  }
  <font color=#0000ff>const</font> T&amp; top() { <font color=#0000ff>return</font> front(); }
  <font color=#0000ff>void</font> push(<font color=#0000ff>const</font> T&amp; x) {
    push_back(x);
    push_heap(begin(), end(), comp);
  }
  <font color=#0000ff>void</font> pop() {
    pop_heap(begin(), end(), comp);
    pop_back();
  }  
};

<font color=#0000ff>int</font> main() {
  PQV&lt;<font color=#0000ff>int</font>, less&lt;<font color=#0000ff>int</font>&gt; &gt; pqi;
  srand(time(0));
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 100; i++)
    pqi.push(rand() % 25);
  copy(pqi.begin(), pqi.end(),
    ostream_iterator&lt;<font color=#0000ff>int</font>&gt;(cout, <font color=#004488>" "</font>));
  cout &lt;&lt; endl;
  <font color=#0000ff>while</font>(!pqi.empty()) {
    cout &lt;&lt; pqi.top() &lt;&lt; ' ';
    pqi.pop();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">But this program behaves in the same way
as the previous one! What you are seeing in the underlying <B>vector</B> is
called a <I>heap</I>.<I> </I>This heap represents the tree of the priority queue
(stored in the linear structure of the <B>vector</B>), but when you iterate
through it you do not get a linear priority-queue order. You might think that
you can simply call <B>sort_heap(&#160;)</B>, but that only works once, and then
you don&#8217;t have a heap anymore, but instead a sorted list. This means that
to go back to using it as a heap the user must remember to call
<B>make_heap(&#160;) </B>first. This can be encapsulated into your custom
priority queue:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I222">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I223"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:PriorityQueue6.cpp</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> T, <font color=#0000ff>class</font> Compare&gt;
<font color=#0000ff>class</font> PQV : <font color=#0000ff>public</font> vector&lt;T&gt; {
  Compare comp;
  <font color=#0000ff>bool</font> sorted;
  <font color=#0000ff>void</font> assureHeap() {
    <font color=#0000ff>if</font>(sorted) {
      <font color=#009900>// Turn it back into a heap:</font>
      make_heap(begin(), end(), comp);
      sorted = <font color=#0000ff>false</font>;
    }
  }    
<font color=#0000ff>public</font>:
  PQV(Compare cmp = Compare()) : comp(cmp) {
    make_heap(begin(), end(), comp);
    sorted = <font color=#0000ff>false</font>;
  }
  <font color=#0000ff>const</font> T&amp; top() {
    assureHeap();
    <font color=#0000ff>return</font> front(); 
  }
  <font color=#0000ff>void</font> push(<font color=#0000ff>const</font> T&amp; x) {
    assureHeap();
    <font color=#009900>// Put it at the end:</font>
    push_back(x);
    <font color=#009900>// Re-adjust the heap:</font>
    push_heap(begin(), end(), comp);
  }
  <font color=#0000ff>void</font> pop() {
    assureHeap();
    <font color=#009900>// Move the top element to the last position:</font>
    pop_heap(begin(), end(), comp);
    <font color=#009900>// Remove that element:</font>
    pop_back();
  }
  <font color=#0000ff>void</font> sort() {
    <font color=#0000ff>if</font>(!sorted) {
      sort_heap(begin(), end(), comp);
      reverse(begin(), end());
      sorted = <font color=#0000ff>true</font>;
    }
  }
};

<font color=#0000ff>int</font> main() {
  PQV&lt;<font color=#0000ff>int</font>, less&lt;<font color=#0000ff>int</font>&gt; &gt; pqi;
  srand(time(0));
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 100; i++) {
    pqi.push(rand() % 25);
    copy(pqi.begin(), pqi.end(),
      ostream_iterator&lt;<font color=#0000ff>int</font>&gt;(cout, <font color=#004488>" "</font>));
    cout &lt;&lt; <font color=#004488>"\n-----\n"</font>;
  }
  pqi.sort();
  copy(pqi.begin(), pqi.end(),
    ostream_iterator&lt;<font color=#0000ff>int</font>&gt;(cout, <font color=#004488>" "</font>));
  cout &lt;&lt; <font color=#004488>"\n-----\n"</font>;
  <font color=#0000ff>while</font>(!pqi.empty()) {
    cout &lt;&lt; pqi.top() &lt;&lt; ' ';
    pqi.pop();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If <B>sorted</B> is true, then the
<B>vector</B> is not organized as a heap, but instead as a sorted sequence.
<B>assureHeap(&#160;)</B> guarantees that it&#8217;s put back into heap form
before performing any heap operations on
it.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I223">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I224"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first <B>for</B> loop in
<B>main(&#160;)</B> now has the additional quality that it displays the heap as
it&#8217;s being built.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I224">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I225"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The only drawback to this solution is
that the user must remember to call <B>sort(&#160;) </B>before viewing it as a
sorted sequence (although one could conceivably override all the methods that
produce iterators so that they guarantee sorting). Another solution is to build
a priority queue that is not a <B>vector</B>, but will build you a <B>vector</B>
whenever you want one:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I225">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I226"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:PriorityQueue7.cpp</font>
<font color=#009900>// A priority queue that will hand you a vector</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> T, <font color=#0000ff>class</font> Compare&gt;
<font color=#0000ff>class</font> PQV {
  vector&lt;T&gt; v;
  Compare comp;
<font color=#0000ff>public</font>:
  <font color=#009900>// Don't need to call make_heap(); it's empty:</font>
  PQV(Compare cmp = Compare()) : comp(cmp) {}
  <font color=#0000ff>void</font> push(<font color=#0000ff>const</font> T&amp; x) {
    <font color=#009900>// Put it at the end:</font>
    v.push_back(x);
    <font color=#009900>// Re-adjust the heap:</font>
    push_heap(v.begin(), v.end(), comp);
  }
  <font color=#0000ff>void</font> pop() {
    <font color=#009900>// Move the top element to the last position:</font>
    pop_heap(v.begin(), v.end(), comp);
    <font color=#009900>// Remove that element:</font>
    v.pop_back();
  }
  <font color=#0000ff>const</font> T&amp; top() { <font color=#0000ff>return</font> v.front(); }
  <font color=#0000ff>bool</font> empty() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> v.empty(); }
  <font color=#0000ff>int</font> size() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> v.size(); }
  <font color=#0000ff>typedef</font> vector&lt;T&gt; TVec;
  TVec vector() {
    TVec r(v.begin(), v.end());
    <font color=#009900>// It&#8217;s already a heap</font>
    sort_heap(r.begin(), r.end(), comp);
    <font color=#009900>// Put it into priority-queue order:</font>
    reverse(r.begin(), r.end());
    <font color=#0000ff>return</font> r;
  }
};

<font color=#0000ff>int</font> main() {
  PQV&lt;<font color=#0000ff>int</font>, less&lt;<font color=#0000ff>int</font>&gt; &gt; pqi;
  srand(time(0));
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 100; i++)
    pqi.push(rand() % 25);
  <font color=#0000ff>const</font> vector&lt;<font color=#0000ff>int</font>&gt;&amp; v = pqi.vector();
  copy(v.begin(), v.end(),
    ostream_iterator&lt;<font color=#0000ff>int</font>&gt;(cout, <font color=#004488>" "</font>));
  cout &lt;&lt; <font color=#004488>"\n-----------\n"</font>; 
  <font color=#0000ff>while</font>(!pqi.empty()) {
    cout &lt;&lt; pqi.top() &lt;&lt; ' ';
    pqi.pop();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PQV</B> follows the same form as the
STL&#8217;s <B>priority_queue</B>, but has the additional member
<B>vector(&#160;)</B>, which creates a new <B>vector</B> that&#8217;s a copy of
the one in <B>PQV </B>(which means that it&#8217;s already a heap), then sorts
it (thus it leave&#8217;s <B>PQV</B>&#8217;s <B>vector</B> untouched), then
reverses the order so that traversing the new <B>vector</B> produces the same
effect as popping the elements from the priority
queue.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I226">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I227"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You may observe that the approach of
inheriting from <B>priority_queue</B> used in <B>PriorityQueue4.cpp</B> could be
used with the above technique to produce more succinct
code:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I227">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I228"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:PriorityQueue8.cpp</font>
<font color=#009900>// A more compact version of PriorityQueue7.cpp</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> T&gt;
<font color=#0000ff>class</font> PQV : <font color=#0000ff>public</font> priority_queue&lt;T&gt; {
<font color=#0000ff>public</font>:
  <font color=#0000ff>typedef</font> vector&lt;T&gt; TVec;
  TVec vector() {
    TVec r(c.begin(), c.end());
    <font color=#009900>// c is already a heap</font>
    sort_heap(r.begin(), r.end(), comp);
    <font color=#009900>// Put it into priority-queue order:</font>
    reverse(r.begin(), r.end());
    <font color=#0000ff>return</font> r;
  }
};

<font color=#0000ff>int</font> main() {
  PQV&lt;<font color=#0000ff>int</font>&gt; pqi;
  srand(time(0));
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 100; i++)
    pqi.push(rand() % 25);
  <font color=#0000ff>const</font> vector&lt;<font color=#0000ff>int</font>&gt;&amp; v = pqi.vector();
  copy(v.begin(), v.end(),
    ostream_iterator&lt;<font color=#0000ff>int</font>&gt;(cout, <font color=#004488>" "</font>));
  cout &lt;&lt; <font color=#004488>"\n-----------\n"</font>; 
  <font color=#0000ff>while</font>(!pqi.empty()) {
    cout &lt;&lt; pqi.top() &lt;&lt; ' ';
    pqi.pop();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The brevity of this solution makes it the
simplest and most desirable, plus it&#8217;s guaranteed that the user will not
have a <B>vector</B> in the unsorted state. The only potential problem is that
the <B>vector(&#160;)</B> member function returns the <B>vector&lt;T&gt;</B> by
value, which might cause some overhead issues with complex values of the
parameter type
<B>T</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I228">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I229"></a>
</FONT><A NAME="_Toc519042041"></A><BR></P></DIV>
<A NAME="Heading229"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Holding bits</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Most of my computer education was in
hardware-level design and programming, and I spent my first few years doing
embedded systems development. Because C was a language that purported to be
&#8220;close to the hardware,&#8221; I have always found it dismaying that there
was no native binary representation for numbers. Decimal, of course, and
hexadecimal (tolerable only because it&#8217;s easier to group the bits in your
mind), but octal? Ugh. Whenever you read specs for chips you&#8217;re trying to
program, they don&#8217;t describe the chip registers in octal, or even
hexadecimal &#8211; they use binary. And yet C won&#8217;t let you say
<B>0b0101101</B>, which is the obvious solution for a language close to the
hardware.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I229">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I230"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although there&#8217;s still no native
binary representation in C++, things have improved with the addition of two
classes: <B>bitset</B> and <B>vector&lt;bool&gt;</B>, both of which are designed
to manipulate a group of on-off values. The primary differences between these
types are:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I230">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I231"></a>
</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">The <B>bitset</B> holds a
fixed number of bits. You establish the quantity of bits in the <B>bitset</B>
template argument. The <B>vector&lt;bool&gt;</B> can, like a regular
<B>vector</B>, expand dynamically to hold any number of <B>bool</B>
values.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">The
<B>bitset</B> is explicitly designed for performance when manipulating bits, and
not as a &#8220;regular&#8221; container. As such, it has no iterators and
it&#8217;s most storage-efficient when it contains an integral number of
<B>long</B> values. The <B>vector&lt;bool&gt;</B>, on the other hand, is a
specialization of a <B>vector</B>, and so has all the operations of a normal
<B>vector</B> &#8211; the specialization is just designed to be space-efficient
for <B>bool</B>.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There is no
trivial conversion between a <B>bitset</B> and a <B>vector&lt;bool&gt;</B>,
which implies that the two are for very different
purposes.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I231">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I232"></a>
</FONT><A NAME="_Toc519042042"></A><BR></P></DIV>
<A NAME="Heading230"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
bitset&lt;n&gt;</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The template for <B>bitset</B> accepts an
integral template argument which is the number of bits to represent. Thus,
<B>bitset&lt;10&gt;</B> is a different type than <B>bitset&lt;20&gt;</B>, and
you cannot perform comparisons, assignments, etc. between the
two.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I232">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I233"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>bitset</B> provides virtually any
bit operation that you could ask for, in a very efficient form. However, each
<B>bitset</B> is made up of an integral number of <B>long</B>s (typically 32
bits), so even though it uses no more space than it needs, it always uses at
least the size of a <B>long</B>. This means you&#8217;ll use space most
efficiently if you increase the size of your <B>bitset</B>s in chunks of the
number of bits in a <B>long</B>. In addition, the only conversion <I>from</I> a
<B>bitset</B> to a numerical value is to an <B>unsigned long</B>, which means
that 32 bits (if your <B>long </B>is the typical size) is the most flexible form
of a <B>bitset</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I233">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I234"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example tests almost all
the functionality of the <B>bitset</B> (the missing operations are redundant or
trivial).<B> </B>You&#8217;ll see the description of each of the bitset outputs
to the right of the output so that the bits all line up and you can compare them
to the source values. If you still don&#8217;t understand bitwise operations,
running this program should
help.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I234">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I235"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:BitSet.cpp</font>
<font color=#009900>// Exercising the bitset class</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-bor}</font>
<font color=#009900>//{-g++295}</font>
<font color=#009900>//{-g++3}</font>
#include &lt;iostream&gt;
#include &lt;bitset&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;climits&gt;
#include &lt;string&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;
<font color=#0000ff>const</font> <font color=#0000ff>int</font> sz = 32;
<font color=#0000ff>typedef</font> bitset&lt;sz&gt; BS;

<font color=#0000ff>template</font>&lt;<font color=#0000ff>int</font> bits&gt;
bitset&lt;bits&gt; randBitset() {
  bitset&lt;bits&gt; r(rand());
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; bits/16 - 1; i++) {
    r &lt;&lt;= 16;
    <font color=#009900>// "OR" together with a new lower 16 bits:</font>
    r |= bitset&lt;bits&gt;(rand()); 
  }
  <font color=#0000ff>return</font> r;
}  

<font color=#0000ff>int</font> main() {
  srand(time(0));
  cout &lt;&lt; <font color=#004488>"sizeof(bitset&lt;16&gt;) = "</font> 
    &lt;&lt; <font color=#0000ff>sizeof</font>(bitset&lt;16&gt;) &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"sizeof(bitset&lt;32&gt;) = "</font> 
    &lt;&lt; <font color=#0000ff>sizeof</font>(bitset&lt;32&gt;) &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"sizeof(bitset&lt;48&gt;) = "</font> 
    &lt;&lt; <font color=#0000ff>sizeof</font>(bitset&lt;48&gt;) &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"sizeof(bitset&lt;64&gt;) = "</font> 
    &lt;&lt; <font color=#0000ff>sizeof</font>(bitset&lt;64&gt;) &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"sizeof(bitset&lt;65&gt;) = "</font> 
    &lt;&lt; <font color=#0000ff>sizeof</font>(bitset&lt;65&gt;) &lt;&lt; endl;
  BS a(randBitset&lt;sz&gt;()), b(randBitset&lt;sz&gt;());
  <font color=#009900>// Converting from a bitset:</font>
  <font color=#0000ff>unsigned</font> <font color=#0000ff>long</font> ul = a.to_ulong();
  string s = b.to_string();
  <font color=#009900>// Converting a string to a bitset:</font>
  <font color=#0000ff>char</font>* cbits = <font color=#004488>"111011010110111"</font>;
  cout &lt;&lt; <font color=#004488>"char* cbits = "</font> &lt;&lt; cbits &lt;&lt;endl;
  cout &lt;&lt; BS(cbits) &lt;&lt; <font color=#004488>" [BS(cbits)]"</font> &lt;&lt; endl;
  cout &lt;&lt; BS(cbits, 2) 
    &lt;&lt; <font color=#004488>" [BS(cbits, 2)]"</font> &lt;&lt; endl;
  cout &lt;&lt; BS(cbits, 2, 11)
    &lt;&lt; <font color=#004488>" [BS(cbits, 2, 11)]"</font> &lt;&lt; endl;
  cout &lt;&lt; a &lt;&lt; <font color=#004488>" [a]"</font> &lt;&lt; endl;
  cout &lt;&lt; b &lt;&lt; <font color=#004488>" [b]"</font>&lt;&lt; endl;
  <font color=#009900>// Bitwise AND:</font>
  cout &lt;&lt; (a &amp; b) &lt;&lt; <font color=#004488>" [a &amp; b]"</font> &lt;&lt; endl;
  cout &lt;&lt; (BS(a) &amp;= b) &lt;&lt; <font color=#004488>" [a &amp;= b]"</font> &lt;&lt; endl;
  <font color=#009900>// Bitwise OR:</font>
  cout &lt;&lt; (a | b) &lt;&lt; <font color=#004488>" [a | b]"</font> &lt;&lt; endl;
  cout &lt;&lt; (BS(a) |= b) &lt;&lt; <font color=#004488>" [a |= b]"</font> &lt;&lt; endl;
  <font color=#009900>// Exclusive OR:</font>
  cout &lt;&lt; (a ^ b) &lt;&lt; <font color=#004488>" [a ^ b]"</font> &lt;&lt; endl;
  cout &lt;&lt; (BS(a) ^= b) &lt;&lt; <font color=#004488>" [a ^= b]"</font> &lt;&lt; endl;
  cout &lt;&lt; a &lt;&lt; <font color=#004488>" [a]"</font> &lt;&lt; endl; <font color=#009900>// For reference</font>
  <font color=#009900>// Logical left shift (fill with zeros):</font>
  cout &lt;&lt; (BS(a) &lt;&lt;= sz/2) 
    &lt;&lt; <font color=#004488>" [a &lt;&lt;= (sz</font><font color=#004488>/2)]"</font> &lt;&lt; endl;
  cout &lt;&lt; (a &lt;&lt; sz/2) &lt;&lt; endl;
  cout &lt;&lt; a &lt;&lt; <font color=#004488>" [a]"</font> &lt;&lt; endl; <font color=#009900>// For reference</font>
  <font color=#009900>// Logical right shift (fill with zeros):</font>
  cout &lt;&lt; (BS(a) &gt;&gt;= sz/2) 
    &lt;&lt; <font color=#004488>" [a &gt;&gt;= (sz</font><font color=#004488>/2)]"</font> &lt;&lt; endl;
  cout &lt;&lt; (a &gt;&gt; sz/2) &lt;&lt; endl;
  cout &lt;&lt; a &lt;&lt; <font color=#004488>" [a]"</font> &lt;&lt; endl; <font color=#009900>// For reference</font>
  cout &lt;&lt; BS(a).set() &lt;&lt; <font color=#004488>" [a.set()]"</font> &lt;&lt; endl;
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; sz; i++)
    <font color=#0000ff>if</font>(!a.test(i)) {
      cout &lt;&lt; BS(a).set(i) 
        &lt;&lt; <font color=#004488>" [a.set("</font> &lt;&lt; i &lt;&lt;<font color=#004488>")]"</font> &lt;&lt; endl;
      <font color=#0000ff>break</font>; <font color=#009900>// Just do one example of this</font>
    }
  cout &lt;&lt; BS(a).reset() &lt;&lt; <font color=#004488>" [a.reset()]"</font>&lt;&lt; endl;
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; sz; j++)
    <font color=#0000ff>if</font>(a.test(j)) {
      cout &lt;&lt; BS(a).reset(j) 
        &lt;&lt; <font color=#004488>" [a.reset("</font> &lt;&lt; j &lt;&lt;<font color=#004488>")]"</font> &lt;&lt; endl;
      <font color=#0000ff>break</font>; <font color=#009900>// Just do one example of this</font>
    }
  cout &lt;&lt; BS(a).flip() &lt;&lt; <font color=#004488>" [a.flip()]"</font> &lt;&lt; endl;
  cout &lt;&lt; ~a &lt;&lt; <font color=#004488>" [~a]"</font> &lt;&lt; endl;  
  cout &lt;&lt; a &lt;&lt; <font color=#004488>" [a]"</font> &lt;&lt; endl; <font color=#009900>// For reference</font>
  cout &lt;&lt; BS(a).flip(1) &lt;&lt; <font color=#004488>" [a.flip(1)]"</font>&lt;&lt; endl;
  BS c;
  cout &lt;&lt; c &lt;&lt; <font color=#004488>" [c]"</font> &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"c.count() = "</font> &lt;&lt; c.count() &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"c.any() = "</font> 
    &lt;&lt; (c.any() ? <font color=#004488>"true"</font> : <font color=#004488>"false"</font>) &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"c.none() = "</font> 
    &lt;&lt; (c.none() ? <font color=#004488>"true"</font> : <font color=#004488>"false"</font>) &lt;&lt; endl;
  c[1].flip(); c[2].flip();
  cout &lt;&lt; c &lt;&lt; <font color=#004488>" [c]"</font> &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"c.count() = "</font> &lt;&lt; c.count() &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"c.any() = "</font> 
    &lt;&lt; (c.any() ? <font color=#004488>"true"</font> : <font color=#004488>"false"</font>) &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"c.none() = "</font> 
    &lt;&lt; (c.none() ? <font color=#004488>"true"</font> : <font color=#004488>"false"</font>) &lt;&lt; endl;
  <font color=#009900>// Array indexing operations:</font>
  c.reset();
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> k = 0; k &lt; c.size(); k++)
    <font color=#0000ff>if</font>(k % 2 == 0)
      c[k].flip();
  cout &lt;&lt; c &lt;&lt; <font color=#004488>" [c]"</font> &lt;&lt; endl;
  c.reset();
  <font color=#009900>// Assignment to bool:</font>
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> ii = 0; ii &lt; c.size(); ii++)
    c[ii] = (rand() % 100) &lt; 25;
  cout &lt;&lt; c &lt;&lt; <font color=#004488>" [c]"</font> &lt;&lt; endl;
  <font color=#009900>// bool test:</font>
  <font color=#0000ff>if</font>(c[1] == <font color=#0000ff>true</font>) 
    cout &lt;&lt; <font color=#004488>"c[1] == true"</font>; 
  <font color=#0000ff>else</font> 
    cout &lt;&lt; <font color=#004488>"c[1] == false"</font> &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To generate interesting random
<B>bitset</B>s, the <B>randBitset(&#160;)</B> function is created. The Standard
C <B>rand(&#160;)</B> function only generates an <B>int</B>, so this function
demonstrates <B>operator&lt;&lt;=</B> by shifting each 16 random bits to the
left until the <B>bitset</B> (which is templatized in this function for size) is
full. The generated number and each new 16 bits is combined using the
<B>operator|=</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I235">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I236"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first thing demonstrated in
<B>main(&#160;)</B> is the unit size of a <B>bitset</B>. If it is less than 32
bits, <B>sizeof</B> produces 4 (4 bytes = 32 bits), which is the size of a
single <B>long</B> on most implementations. If it&#8217;s between 32 and 64, it
requires two <B>long</B>s, greater than 64 requires 3 <B>long</B>s, etc. Thus
you make the best use of space if you use a bit quantity that fits in an
integral number of <B>long</B>s. However, notice there&#8217;s no extra overhead
for the object &#8211; it&#8217;s as if you were hand-coding to use a
<B>long</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I236">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I237"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Another clue that <B>bitset</B> is
optimized for <B>long</B>s is that there is a <B>to_ulong(&#160;)</B> member
function that produces the value of the bitset as an <B>unsigned long</B>. There
are no other numerical conversions from <B>bitset</B>, but there is a
<B>to_string(&#160;)</B> conversion that produces a <B>string</B> containing
ones and zeros, and this can be as long as the actual <B>bitset</B>. However,
using <B>bitset&lt;32&gt;</B> may make your life simpler because of
<B>to_ulong(&#160;)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I237">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I238"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s still no primitive format
for binary values, but the next best thing is supported by <B>bitset</B>: a
<B>string</B> of ones and zeros with the least-significant bit (lsb) on the
right. The three constructors demonstrated show taking the entire <B>string
</B>(the <B>char </B>array is automatically converted to a <B>string</B>), the
<B>string</B> starting at character 2, and the string from character 2 through
11. You can write to an <B>ostream</B> from a <B>bitset</B> using
<B>operator&lt;&lt; </B>and it comes out as ones and zeros. You can also read
from an <B>istream</B> using <B>operator&gt;&gt;</B> (not shown
here).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I238">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I239"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll notice that <B>bitset</B>
only has three non-member operators: <I>and</I> (<B>&amp;</B>), <I>or</I>
(<B>|</B>) and <I>exclusive-or</I> (<B>^</B>). Each of these create a new
<B>bitset </B>as their return value. All of the member operators opt for the
more efficient <B>&amp;=</B>, <B>|=</B>, etc. form where a temporary is not
created. However, these forms actually change their lvalue (which is <B>a</B> in
most of the tests in the above example). To prevent this, I created a temporary
to be used as the lvalue by invoking the copy-constructor on <B>a</B>; this is
why you see the form <B>BS(a)</B>. The result of each test is printed out, and
occasionally <B>a</B> is reprinted so you can easily look at it for
reference.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I239">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I240"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The rest of the example should be
self-explanatory when you run it; if not you can find the details in your
compiler&#8217;s documentation or the other documentation mentioned earlier in
this
chapter.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I240">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I241"></a>
</FONT><A NAME="_Toc519042043"></A><BR></P></DIV>
<A NAME="Heading231"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
vector&lt;bool&gt;</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>vector&lt;bool&gt;</B> is a
specialization of the <B>vector</B> template. A normal <B>bool</B> variable
requires at least one byte, but since a <B>bool</B> only has two states the
ideal implementation of <B>vector&lt;bool&gt;</B> is such that each <B>bool</B>
value only requires one bit. This means the iterator must be specially-defined,
and cannot be a
<B>bool*</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I241">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I242"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The bit-manipulation functions for
<B>vector&lt;bool&gt;</B> are much more limited than those of <B>bitset</B>. The
only member function that was added to those already in <B>vector</B> is
<B>flip(&#160;)</B>, to invert all the bits; there is no <B>set(&#160;)</B> or
<B>reset(&#160;)</B> as in <B>bitset</B>. When you use <B>operator[ ]</B>, you
get back an object of type <B>vector&lt;bool&gt;::reference</B>, which also has
a <B>flip(&#160;)</B> to invert that individual
bit.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I242">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I243"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:VectorOfBool.cpp</font>
<font color=#009900>// Demonstrate the vector&lt;bool&gt; specialization</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-msc}</font>
<font color=#009900>//{-g++295} </font>
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;
#include &lt;bitset&gt;
#include &lt;iterator&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  vector&lt;<font color=#0000ff>bool</font>&gt; vb(10, <font color=#0000ff>true</font>);
  vector&lt;<font color=#0000ff>bool</font>&gt;::iterator it;
  <font color=#0000ff>for</font>(it = vb.begin(); it != vb.end(); it++)
    cout &lt;&lt; *it;
  cout &lt;&lt; endl;
  vb.push_back(<font color=#0000ff>false</font>);
  ostream_iterator&lt;<font color=#0000ff>bool</font>&gt; out(cout, <font color=#004488>""</font>);
  copy(vb.begin(), vb.end(), out);
  cout &lt;&lt; endl;
  <font color=#0000ff>bool</font> ab[] = { <font color=#0000ff>true</font>, <font color=#0000ff>false</font>, <font color=#0000ff>false</font>, <font color=#0000ff>true</font>, <font color=#0000ff>true</font>, 
    <font color=#0000ff>true</font>, <font color=#0000ff>true</font>, <font color=#0000ff>false</font>, <font color=#0000ff>false</font>, <font color=#0000ff>true</font> };
  <font color=#009900>// There's a similar constructor:</font>
  vb.assign(ab, ab + <font color=#0000ff>sizeof</font>(ab)/<font color=#0000ff>sizeof</font>(<font color=#0000ff>bool</font>));
  copy(vb.begin(), vb.end(), out);
  cout &lt;&lt; endl;
  vb.flip(); <font color=#009900>// Flip all bits</font>
  copy(vb.begin(), vb.end(), out);
  cout &lt;&lt; endl;
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; vb.size(); i++)
    vb[i] = 0; <font color=#009900>// (Equivalent to "false")</font>
  vb[4] = <font color=#0000ff>true</font>;
  vb[5] = 1;
  vb[7].flip(); <font color=#009900>// Invert one bit</font>
  copy(vb.begin(), vb.end(), out);
  cout &lt;&lt; endl;
  <font color=#009900>// Convert to a bitset:</font>
  ostringstream os;
  copy(vb.begin(), vb.end(), 
    ostream_iterator&lt;<font color=#0000ff>bool</font>&gt;(os, <font color=#004488>""</font>));
  bitset&lt;10&gt; bs(os.str());
  cout &lt;&lt; <font color=#004488>"Bitset:\n"</font> &lt;&lt; bs &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The last part of this example takes a
<B>vector&lt;bool&gt;</B> and converts it to a <B>bitset</B> by first turning it
into a <B>string</B> of ones and zeros. Of course, you must know the size of the
<B>bitset</B> at compile-time. You can see that this conversion is not the kind
of operation you&#8217;ll want to do on a regular
basis.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I243">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I244"></a>
</FONT><A NAME="_Toc519042044"></A><BR></P></DIV>
<A NAME="Heading232"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Associative containers</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>set</B>, <B>map</B>,
<B>multiset</B> and <B>multimap</B> are called <I>associative containers</I>
because they associate <I>keys</I> with <I>values</I>. Well, at least
<B>map</B>s and <B>multimap</B>s associate keys to values, but you can look at a
<B>set</B> as a <B>map</B> that has no values, only keys (and they can in fact
be implemented this way), and the same for the relationship between
<B>multiset</B> and <B>multimap</B>. So, because of the structural similarity
<B>set</B>s and <B>multiset</B>s are lumped in with associative
containers.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I244">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I245"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The most important basic operations with
associative containers are putting things in, and in the case of a <B>set</B>,
seeing if something is in the set. In the case of a <B>map</B>, you want to
first see if a key is in the <B>map</B>, and if it exists you want the
associated value for that key to be returned. Of course, there are many
variations on this theme but that&#8217;s the fundamental concept. The following
example shows these
basics:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I245">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I246"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:AssociativeBasics.cpp</font>
<font color=#009900>// Basic operations with sets and maps</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"Noisy.h"</font>
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;map&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  Noisy na[] = { Noisy(), Noisy(), Noisy(), 
    Noisy(), Noisy(), Noisy(), Noisy() };
  <font color=#009900>// Add elements via constructor:</font>
  set&lt;Noisy&gt; ns(na, na+ <font color=#0000ff>sizeof</font> na/<font color=#0000ff>sizeof</font>(Noisy));
  <font color=#009900>// Ordinary insertion:</font>
  Noisy n;
  ns.insert(n);
  cout &lt;&lt; endl;
  <font color=#009900>// Check for set membership:</font>
  cout &lt;&lt; <font color=#004488>"ns.count(n)= "</font> &lt;&lt; ns.count(n) &lt;&lt; endl;
  <font color=#0000ff>if</font>(ns.find(n) != ns.end())
    cout &lt;&lt; <font color=#004488>"n("</font> &lt;&lt; n &lt;&lt; <font color=#004488>") found in ns"</font> &lt;&lt; endl;
  <font color=#009900>// Print elements:</font>
  copy(ns.begin(), ns.end(), 
    ostream_iterator&lt;Noisy&gt;(cout, <font color=#004488>" "</font>));
  cout &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"\n-----------\n"</font>;
  map&lt;<font color=#0000ff>int</font>, Noisy&gt; nm;
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
    nm[i]; <font color=#009900>// Automatically makes pairs</font>
  cout &lt;&lt; <font color=#004488>"\n-----------\n"</font>;
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; nm.size(); j++)
    cout &lt;&lt; <font color=#004488>"nm["</font> &lt;&lt; j &lt;&lt;<font color=#004488>"] = "</font> &lt;&lt; nm[j] &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"\n-----------\n"</font>;
  nm[10] = n;
  cout &lt;&lt; <font color=#004488>"\n-----------\n"</font>;
  nm.insert(make_pair(47, n));
  cout &lt;&lt; <font color=#004488>"\n-----------\n"</font>;
  cout &lt;&lt; <font color=#004488>"\n nm.count(10)= "</font> 
    &lt;&lt; nm.count(10) &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"nm.count(11)= "</font> 
    &lt;&lt; nm.count(11) &lt;&lt; endl;
  map&lt;<font color=#0000ff>int</font>, Noisy&gt;::iterator it = nm.find(6);
  <font color=#0000ff>if</font>(it != nm.end())
    cout &lt;&lt; <font color=#004488>"value:"</font> &lt;&lt; (*it).second
      &lt;&lt; <font color=#004488>" found in nm at location 6"</font> &lt;&lt; endl;
  <font color=#0000ff>for</font>(it = nm.begin(); it != nm.end(); it++)
    cout &lt;&lt; (*it).first &lt;&lt; <font color=#004488>":"</font> 
      &lt;&lt; (*it).second &lt;&lt; <font color=#004488>", "</font>;
  cout &lt;&lt; <font color=#004488>"\n-----------\n"</font>;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>set&lt;Noisy&gt;</B> object
<B>ns</B> is created using two iterators into an array of <B>Noisy</B> objects,
but there is also a default constructor and a copy-constructor, and you can pass
in an object that provides an alternate scheme for doing comparisons. Both
<B>set</B>s and <B>map</B>s have an <B>insert(&#160;)</B> member function to put
things in, and there are a couple of different ways to check to see if an object
is already in an associative container: <B>count(&#160;)</B>, when given a key,
will tell you how many times that key occurs (this can only be zero or one in a
<B>set</B> or <B>map</B>, but it can be more than one with a <B>multiset</B> or
<B>multimap</B>). The <B>find(&#160;)</B> member function will produce an
iterator indicating the first occurrence (with <B>set</B> and <B>map</B>, the
<I>only</I> occurrence) of the key that you give it, or the past-the-end
iterator if it can&#8217;t find the key. The <B>count(&#160;)</B> and
<B>find(&#160;)</B> member functions exist for all the associative containers,
which makes sense. The associative containers also have member functions
<B>lower_bound(&#160;)</B>, <B>upper_bound(&#160;)</B> and
<B>equal_range(&#160;)</B>, which actually only make sense for <B>multiset</B>
and <B>multimap</B>, as you shall see (but don&#8217;t try to figure out how
they would be useful for <B>set</B> and <B>map</B>, since they are designed for
dealing with a range of duplicate keys, which those containers don&#8217;t
allow).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I246">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I247"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Designing an <B>operator[ ]</B> always
produces a little bit of a dilemma because it&#8217;s intended to be treated as
an array-indexing operation, so people don&#8217;t tend to think about
performing a test before they use it. But what happens if you decide to index
out of the bounds of the array? One option, of course, is to throw an exception,
but with a <B>map</B> &#8220;indexing out of the array&#8221; could mean that
you want an entry there, and that&#8217;s the way the STL <B>map</B> treats it.
The first <B>for</B> loop after the creation of the <B>map&lt;int, Noisy&gt;
nm</B> just &#8220;looks up&#8221; objects using the <B>operator[ ]</B>, but
this is actually creating new <B>Noisy</B> objects! The <B>map</B> creates a new
key-value pair (using the default constructor for the value) if you look up a
value with <B>operator[ ]</B> and it isn&#8217;t there. This means that if you
really just want to look something up and not create a new entry, you must use
<B>count(&#160;)</B> (to see if it&#8217;s there) or <B>find(&#160;)</B> (to get
an iterator to it).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I247">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I248"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>for</B> loop that prints out the
values of the container using <B>operator[ ]</B> has a number of problems.
First, it requires integral keys (which we happen to have in this case). Next
and worse, if all the keys are not sequential, you&#8217;ll end up counting from
0 to the size of the container, and if there are some spots which don&#8217;t
have key-value pairs you&#8217;ll automatically create them, and miss some of
the higher values of the keys. Finally, if you look at the output from the
<B>for</B> loop you&#8217;ll see that things are <I>very</I> busy, and
it&#8217;s quite puzzling at first why there are so many constructions and
destructions for what appears to be a simple lookup. The answer only becomes
clear when you look at the code in the <B>map</B> template for <B>operator[
]</B>, which will be something like
this:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I248">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I249"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>mapped_type&amp; <font color=#0000ff>operator</font>[] (<font color=#0000ff>const</font> key_type&amp; k) {
  value_type tmp(k,T()); 
  <font color=#0000ff>return</font> (*((insert(tmp)).first)).second;
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Following the trail, you&#8217;ll find
that <B>map::value_type</B>
is:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I249">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I250"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>typedef</font> pair&lt;<font color=#0000ff>const</font> Key, T&gt; value_type;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now you need to know what a <B>pair</B>
is, which can be found in
<B>&lt;utility&gt;</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I250">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I251"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>template</font> &lt;<font color=#0000ff>class</font> T1, <font color=#0000ff>class</font> T2&gt;
<font color=#0000ff>struct</font> pair { 
  <font color=#0000ff>typedef</font> T1 first_type; 
  <font color=#0000ff>typedef</font> T2 second_type; 
  T1 first; 
  T2 second; 
  pair(); 
  pair(<font color=#0000ff>const</font> T1&amp; x, <font color=#0000ff>const</font> T2&amp; y) 
    : first(x), second(y) {}
  <font color=#009900>// Templatized copy-constructor:</font>
  <font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> U, <font color=#0000ff>class</font> V&gt; 
   pair(<font color=#0000ff>const</font> pair&lt;U, V&gt; &amp;p);
};</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It turns out this is a very important
(albeit simple) <B>struct</B> which is used quite a bit in the STL. All it
really does it package together two objects, but it&#8217;s very useful,
especially when you want to return two objects from a function (since a
<B>return</B> statement only takes one object). There&#8217;s even a shorthand
for creating a pair called <B>make_pair(&#160;)</B>, which is used in
<B>AssociativeBasics.cpp</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I251">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I252"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So to retrace the steps,
<B>map::value_type</B> is a <B>pair</B> of the key and the value of the map
&#8211; actually, it&#8217;s a single entry for the map. But notice that
<B>pair</B> packages its objects by value, which means that copy-constructions
are necessary to get the objects into the <B>pair</B>. Thus, the creation of
<B>tmp</B> in <B>map::operator[ ]</B> will involve at least a copy-constructor
call and destructor call for each object in the <B>pair</B>. Here, we&#8217;re
getting off easy because the key is an <B>int</B>. But if you want to really see
what kind of activity can result from <B>map::operator[ ]</B>, try running
this:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I252">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I253"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:NoisyMap.cpp</font>
<font color=#009900>// Mapping Noisy to Noisy</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"Noisy.h"</font>
#include &lt;map&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  map&lt;Noisy, Noisy&gt; mnn;
  Noisy n1, n2;
  cout &lt;&lt; <font color=#004488>"\n--------\n"</font>;
  mnn[n1] = n2;
  cout &lt;&lt; <font color=#004488>"\n--------\n"</font>;
  cout &lt;&lt; mnn[n1] &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"\n--------\n"</font>;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll see that both the insertion
and lookup generate a lot of extra objects, and that&#8217;s because of the
creation of the <B>tmp</B> object. If you look back up at <B>map::operator[
]</B> you&#8217;ll see that the second line calls <B>insert(&#160;)</B> passing
it <B>tmp</B> &#8211; that is, <B>operator[ ]</B> does an insertion every time.
The return value of <B>insert(&#160;)</B> is a different kind of <B>pair</B>,
where <B>first</B> is an iterator pointing to the key-value <B>pair</B> that was
just inserted, and <B>second</B> is a <B>bool</B> indicating whether the
insertion took place. You can see that <B>operator[ ]</B> grabs <B>first</B>
(the iterator), dereferences it to produce the <B>pair</B>, and then returns the
<B>second</B> which is the value at that location.

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I253">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I254"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So on the upside, <B>map</B> has this
fancy &#8220;make a new entry if one isn&#8217;t there&#8221; behavior, but the
downside is that you <I>always</I> get a lot of extra object creations and
destructions when you use <B>map::operator[ ]</B>. Fortunately,
<B>AssociativeBasics.cpp</B> also demonstrates how to reduce the overhead of
insertions and deletions, by not using <B>operator[ ]</B> if you don&#8217;t
have to. The <B>insert(&#160;)</B> member function is slightly more efficient
than <B>operator[ ]</B>. With a <B>set</B> you only hold one object, but with a
<B>map</B> you hold key-value pairs, so <B>insert(&#160;)</B> requires a
<B>pair</B> as its argument. Here&#8217;s where <B>make_pair(&#160;)</B> comes
in handy, as you can
see.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I254">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I255"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For looking objects up in a <B>map</B>,
you can use <B>count(&#160;)</B> to see whether a key is in the map, or you can
use <B>find(&#160;)</B> to produce an iterator pointing directly at the
key-value pair. Again, since the <B>map</B> contains <B>pair</B>s that&#8217;s
what the iterator produces when you dereference it, so you have to select
<B>first</B> and <B>second</B>. When you run <B>AssociativeBasics.cpp</B>
you&#8217;ll notice that the iterator approach involves no extra object
creations or destructions at all. It&#8217;s not as easy to write or read,
though.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I255">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I256"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you use a <B>map</B> with large,
complex objects and discover there&#8217;s too much overhead when doing lookups
and insertions (don&#8217;t assume this from the beginning &#8211; take the easy
approach first and use a profiler to discover bottlenecks), then you can use the
counted-handle approach shown in Chapter XX so that you are only passing around
small, lightweight
objects.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I256">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I257"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, you can also iterate through a
<B>set</B> or <B>map</B> and operate on each of its objects. This will be
demonstrated in later
examples.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I257">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I258"></a>
</FONT><A NAME="_Toc519042045"></A><BR></P></DIV>
<A NAME="Heading233"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Generators and fillers<BR>for associative containers</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ve seen how useful the
<B>fill(&#160;)</B>, <B>fill_n(&#160;)</B>, <B>generate(&#160;)</B> and
<B>generate_n(&#160;)</B> function templates in <B>&lt;algorithm&gt;</B> have
been for filling the sequential containers (<B>vector</B>, <B>list</B> and
<B>deque</B>) with data. However, these are implemented by using <B>operator=
</B>to assign values into the sequential containers, and the way that you add
objects to associative containers is with their respective <B>insert(&#160;)</B>
member functions. Thus the default &#8220;assignment&#8221; behavior causes a
problem when trying to use the &#8220;fill&#8221; and &#8220;generate&#8221;
functions with associative
containers.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I258">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I259"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One solution is to duplicate the
&#8220;fill&#8221; and &#8220;generate&#8221; functions, creating new ones that
can be used with associative containers. It turns out that only the
<B>fill_n(&#160;)</B> and <B>generate_n(&#160;)</B> functions can be duplicated
(<B>fill(&#160;) </B>and <B>generate(&#160;) </B>copy in between two iterators,
which doesn&#8217;t make sense with associative containers), but the job is
fairly easy, since you have the <B>&lt;algorithm&gt;</B> header file to work
from (and since it contains templates, all the source code is
there):
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I259">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I260"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:assocGen.h</font>
<font color=#009900>// The fill_n() and generate_n() equivalents </font>
<font color=#009900>// for associative containers.</font>
#ifndef ASSOCGEN_H
#define ASSOCGEN_H

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> Assoc, <font color=#0000ff>class</font> Count, <font color=#0000ff>class</font> T&gt;
<font color=#0000ff>void</font> 
assocFill_n(Assoc&amp; a, Count n, <font color=#0000ff>const</font> T&amp; val) {
  <font color=#0000ff>while</font>(n-- &gt; 0)
    a.insert(val);
}

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> Assoc, <font color=#0000ff>class</font> Count, <font color=#0000ff>class</font> Gen&gt;
<font color=#0000ff>void</font> assocGen_n(Assoc&amp; a, Count n, Gen g) {
  <font color=#0000ff>while</font>(n-- &gt; 0)
    a.insert(g());
}
#endif <font color=#009900>// ASSOCGEN_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that instead of using
iterators, the container class itself is passed (by reference, of course, since
you wouldn&#8217;t want to make a local copy, fill it, and then have it
discarded at the end of the
scope).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I260">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I261"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This code demonstrates two valuable
lessons. The first lesson is that if the algorithms don&#8217;t do what you
want, copy the nearest thing and modify it. You have the example at hand in the
STL header, so most of the work has already been
done.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I261">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I262"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second lesson is more pointed: if you
look long enough, there&#8217;s probably a way to do it in the STL
<I>without</I> inventing anything new. The present problem can instead be solved
by using an <B>insert_iterator</B> (produced by a call to
<B>inserter(&#160;)</B>), which calls <B>insert(&#160;)</B> to place items in
the container instead of <B>operator=</B>. This is <I>not</I> simply a variation
of <B>front_insert_iterator</B> (produced by a call to
<B>front_inserter(&#160;)</B>) or <B>back_insert_iterator</B> (produced by a
call to <B>back_inserter(&#160;)</B>), since those iterators use
<B>push_front(&#160;)</B> and <B>push_back(&#160;)</B>, respectively. Each of
the insert iterators is different by virtue of the member function it uses for
insertion, and <B>insert(&#160;)</B> is the one we need. Here&#8217;s a
demonstration that shows filling and generating both a <B>map</B> and a
<B>set</B> (of course, it can also be used with <B>multimap</B> and
<B>multiset</B>). First, some templatized, simple generators are created (this
may seem like overkill, but you never know when you&#8217;ll need them; for that
reason they&#8217;re placed in a header
file):
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I262">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I263"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:SimpleGenerators.h</font>
<font color=#009900>// Generic generators, including</font>
<font color=#009900>// one that creates pairs</font>
#include &lt;iostream&gt;
#include &lt;utility&gt;

<font color=#009900>// A generator that increments its value:</font>
<font color=#0000ff>template</font>&lt;<font color=#0000ff>typename</font> T&gt;
<font color=#0000ff>class</font> IncrGen {
  T i;
<font color=#0000ff>public</font>:
  IncrGen(T ii) : i (ii) {}
  T <font color=#0000ff>operator</font>()() { <font color=#0000ff>return</font> i++; }
};

<font color=#009900>// A generator that produces an STL pair&lt;&gt;:</font>
<font color=#0000ff>template</font>&lt;<font color=#0000ff>typename</font> T1, <font color=#0000ff>typename</font> T2&gt;
<font color=#0000ff>class</font> PairGen {
  T1 i;
  T2 j;
<font color=#0000ff>public</font>:
  PairGen(T1 ii, T2 jj) : i(ii), j(jj) {}
  std::pair&lt;T1,T2&gt; <font color=#0000ff>operator</font>()() { 
    <font color=#0000ff>return</font> std::pair&lt;T1,T2&gt;(i++, j++); 
  }
};

<font color=#009900>// A generic global operator&lt;&lt; </font>
<font color=#009900>// for printing any STL pair&lt;&gt;:</font>
<font color=#0000ff>template</font>&lt;<font color=#0000ff>typename</font> Pair&gt; std::ostream&amp;
<font color=#0000ff>operator</font>&lt;&lt;(std::ostream&amp; os, <font color=#0000ff>const</font> Pair&amp; p) {
  <font color=#0000ff>return</font> os &lt;&lt; p.first &lt;&lt; <font color=#004488>"\t"</font> 
    &lt;&lt; p.second &lt;&lt; std::endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Both generators expect that <B>T</B> can
be incremented, and they simply use <B>operator++</B> to generate new values
from whatever you used for initialization. <B>PairGen</B> creates an STL
<B>pair</B> object as its return value, and that&#8217;s what can be placed into
a <B>map</B> or <B>multimap</B> using
<B>insert(&#160;)</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I263">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I264"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The last function is a generalization of
<B>operator&lt;&lt;</B> for <B>ostream</B>s, so that any <B>pair</B> can be
printed, assuming each element of the <B>pair </B>supports a stream
<B>operator&lt;&lt;</B>. As you can see below, this allows the use of
<B>copy(&#160;)</B> to output the
<B>map</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I264">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I265"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:AssocInserter.cpp</font>
<font color=#009900>// Using an insert_iterator so fill_n() and</font>
<font color=#009900>// generate_n() can be used with associative </font>
<font color=#009900>// containers</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-bor}</font>
<font color=#009900>//{-msc}</font>
<font color=#009900>//{-g++3}</font>
#include <font color=#004488>"SimpleGenerators.h"</font>
#include &lt;iterator&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;map&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  set&lt;<font color=#0000ff>int</font>&gt; s;
  fill_n(inserter(s, s.begin()), 10, 47);
  generate_n(inserter(s, s.begin()), 10, 
    IncrGen&lt;<font color=#0000ff>int</font>&gt;(12));
  copy(s.begin(), s.end(), 
    ostream_iterator&lt;<font color=#0000ff>int</font>&gt;(cout, <font color=#004488>"\n"</font>));
  
  map&lt;<font color=#0000ff>int</font>, <font color=#0000ff>int</font>&gt; m;
  fill_n(inserter(m, m.begin()), 10, 
    make_pair(90,120));
  generate_n(inserter(m, m.begin()), 10, 
    PairGen&lt;<font color=#0000ff>int</font>, <font color=#0000ff>int</font>&gt;(3, 9));
  copy(m.begin(), m.end(), 
    ostream_iterator&lt;pair&lt;<font color=#0000ff>int</font>,<font color=#0000ff>int</font>&gt; &gt;(cout,<font color=#004488>"\n"</font>));
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second argument to <B>inserter</B> is
an iterator, which actually isn&#8217;t used in the case of associative
containers since they maintain their order internally, rather than allowing you
to tell them where the element should be inserted. However, an
<B>insert_iterator</B> can be used with many different types of containers so
you must provide the
iterator.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I265">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I266"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note how the <B>ostream_iterator</B> is
created to output a <B>pair</B>; this wouldn&#8217;t have worked if the
<B>operator&lt;&lt;</B> hadn&#8217;t been created, and since it&#8217;s a
template it is automatically instantiated for <B>pair&lt;int,
int&gt;</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I266">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I267"></a>
</FONT><A NAME="_Toc519042046"></A><BR></P></DIV>
<A NAME="Heading234"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
The magic of maps</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An ordinary array uses an integral value
to index into a sequential set of elements of some type. A <B>map</B> is an
<I>associative array</I>, which means you associate one object with another in
an array-like fashion, but instead of selecting an array element with a number
as you do with an ordinary array, you look it up with an object! The example
which follows counts the words in a text file, so the index is the <B>string</B>
object representing the word, and the value being looked up is the object that
keeps count of the
strings.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I267">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I268"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In a single-item container like a
<B>vector</B> or <B>list</B>, there&#8217;s only one thing being held. But in a
<B>map</B>, you&#8217;ve got two things: the <I>key</I> (what you look up by, as
in <B>mapname[key]</B>) and the <I>value</I> that results from the lookup with
the key. If you simply want to move through the entire <B>map</B> and list each
key-value pair, you use an iterator, which when dereferenced produces a
<B>pair</B> object containing both the key and the value. You access the members
of a <B>pair</B> by selecting <B>first</B> or
<B>second</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I268">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I269"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This same philosophy of packaging two
items together is also used to insert elements into the map, but the <B>pair</B>
is created as part of the instantiated <B>map</B> and is called
<B>value_type</B>, containing the key and the value. So one option for inserting
a new element is to create a <B>value_type</B> object, loading it with the
appropriate objects and then calling the <B>insert(&#160;)</B> member function
for the <B>map</B>. Instead, the following example makes use of the
aforementioned special feature of <B>map</B>: if you&#8217;re trying to find an
object by passing in a key to <B>operator[ ]</B> and that object doesn&#8217;t
exist, <B>operator[ ]</B> will automatically insert a new key-value pair for
you, using the default constructor for the value object. With that in mind,
consider an implementation of a word counting
program:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I269">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I270"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:WordCount.cpp</font>
<font color=#009900>//{L} StreamTokenizer ../TestSuite/Test</font>
<font color=#009900>//{-g++295} </font>
<font color=#009900>// Count occurrences of words using a map</font>
#include <font color=#004488>"StreamTokenizer.h"</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Count {
  <font color=#0000ff>int</font> i;
<font color=#0000ff>public</font>:
  Count() : i(0) {}
  <font color=#0000ff>void</font> <font color=#0000ff>operator</font>++(<font color=#0000ff>int</font>) { i++; } <font color=#009900>// Post-increment  </font>
  <font color=#0000ff>int</font>&amp; val() { <font color=#0000ff>return</font> i; }
};

<font color=#0000ff>typedef</font> map&lt;string, Count&gt; WordMap;
<font color=#0000ff>typedef</font> WordMap::iterator WMIter;

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  <font color=#0000ff>char</font>* fname = <font color=#004488>"WordCount.cpp"</font>;
  <font color=#0000ff>if</font>(argc &gt; 1) fname = argv[1];
  ifstream in(fname);
  assure(in, fname);
  StreamTokenizer words(in);
  WordMap wordmap;
  string word;
  <font color=#0000ff>while</font>((word = words.next()).size() != 0)
    wordmap[word]++;
  <font color=#0000ff>for</font>(WMIter w = wordmap.begin(); 
      w != wordmap.end(); w++)
    cout &lt;&lt; (*w).first &lt;&lt; <font color=#004488>": "</font>
      &lt;&lt; (*w).second.val() &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The need for the <B>Count</B> class is to
contain an <B>int</B> that&#8217;s automatically initialized to zero. This is
necessary because of the crucial
line:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I270">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I271"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>wordmap[word]++;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This finds the word that has been
produced by <B>StreamTokenizer </B>and increments the <B>Count</B> object
associated with that word, which is fine as long as there <I>is</I> a key-value
pair for that <B>string</B>. If there isn&#8217;t, the <B>map</B> automatically
inserts a key for the word you&#8217;re looking up, and a <B>Count</B> object,
which is initialized to zero by the default constructor. Thus, when it&#8217;s
incremented the <B>Count</B> becomes
1.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I271">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I272"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Printing the entire list requires
traversing it with an iterator (there&#8217;s no <B>copy(&#160;)</B> shortcut
for a <B>map</B> unless you want to write an <B>operator&lt;&lt; </B>for the
<B>pair</B> in the map). As previously mentioned, dereferencing this iterator
produces a <B>pair</B> object, with the <B>first</B> member the key and the
<B>second</B> member the value. In this case <B>second</B> is a <B>Count</B>
object, so its <B>val(&#160;)</B> member must be called to produce the actual
word count.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I272">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I273"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you want to find the count for a
particular word, you can use the array index operator, like
this:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I273">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I274"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>cout &lt;&lt; <font color=#004488>"the: "</font> &lt;&lt; wordmap[<font color=#004488>"the"</font>].val() &lt;&lt; endl;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that one of the great
advantages of the <B>map</B> is the clarity of the syntax; an associative array
makes intuitive sense to the reader (note, however, that if &#8220;the&#8221;
isn&#8217;t already in the <B>wordmap</B> a new entry will be
created!).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I274">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I275"></a>
</FONT><BR></P></DIV>
<A NAME="Heading235"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H4 ALIGN="LEFT">
A command-line argument tool</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A problem that often comes up in
programming is the management of program arguments that you can specify on the
command line. Usually you&#8217;d like to have a set of defaults that can be
changed via the command line. The following tool expects the command line
arguments to be in the form <B>flag1=value1</B> with no spaces around the
&#8216;<B>=</B>&#8216; (so it will be treated as a single argument). The
<B>ProgVal</B> class simply inherits from <B>map&lt;string,
string&gt;</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I275">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I276"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:ProgVals.h</font>
<font color=#009900>// Program values can be changed by command line</font>
#ifndef PROGVALS_H
#define PROGVALS_H
#include &lt;map&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

<font color=#0000ff>class</font> ProgVals 
  : <font color=#0000ff>public</font> std::map&lt;std::string, std::string&gt; {
<font color=#0000ff>public</font>:
  ProgVals(std::string defaults[][2], <font color=#0000ff>int</font> sz);
  <font color=#0000ff>void</font> parse(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[],
    std::string usage, <font color=#0000ff>int</font> offset = 1);
  <font color=#0000ff>void</font> print(std::ostream&amp; out = std::cout);
};
#endif <font color=#009900>// PROGVALS_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The constructor expects an array of
<B>string</B> pairs (as you&#8217;ll see, this allows you to initialize it with
an array of <B>char*</B>) and the size of that array. The <B>parse(&#160;)</B>
member function is handed the command-line arguments along with a
&#8220;usage&#8221; string to print if the command line is given incorrectly,
and the &#8220;offset&#8221; which tells it which command-line argument to start
with (so you can have non-flag arguments at the beginning of the command line).
Finally, <B>print(&#160;)</B> displays the values. Here is the
implementation:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I276">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I277"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:ProgVals.cpp {O}</font>
#include <font color=#004488>"ProgVals.h"</font>
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

ProgVals::ProgVals(
  std::string defaults[][2], <font color=#0000ff>int</font> sz) {
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; sz; i++)
    insert(make_pair(
      defaults[i][0], defaults[i][1]));
}

<font color=#0000ff>void</font> ProgVals::parse(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[],
  string usage, <font color=#0000ff>int</font> offset) {
  <font color=#009900>// Parse and apply additional</font>
  <font color=#009900>// command-line arguments:</font>
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = offset; i &lt; argc; i++) {
    string flag(argv[i]);
    <font color=#0000ff>int</font> equal = flag.find('=');
    <font color=#0000ff>if</font>(equal == string::npos) {
      cerr &lt;&lt; <font color=#004488>"Command line error: "</font> &lt;&lt;
        argv[i] &lt;&lt; endl &lt;&lt; usage &lt;&lt; endl;
      <font color=#0000ff>continue</font>; <font color=#009900>// Next argument</font>
    }
    string name = flag.substr(0, equal);
    string value = flag.substr(equal + 1);
    <font color=#0000ff>if</font>(find(name) == end()) {
      cerr &lt;&lt; name &lt;&lt; endl &lt;&lt; usage &lt;&lt; endl;
      <font color=#0000ff>continue</font>; <font color=#009900>// Next argument</font>
    }
    <font color=#0000ff>operator</font>[](name) = value;
  }
}

<font color=#0000ff>void</font> ProgVals::print(ostream&amp; out) {
  out &lt;&lt; <font color=#004488>"Program values:"</font> &lt;&lt; endl;
  <font color=#0000ff>for</font>(iterator it = begin(); it != end(); it++)
    out &lt;&lt; (*it).first &lt;&lt; <font color=#004488>" = "</font>
        &lt;&lt; (*it).second &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The constructor uses the STL
<B>make_pair(&#160;)</B> helper function to convert each pair of <B>char*</B>
into a <B>pair</B> object that can be inserted into the <B>map</B>. In
<B>parse(&#160;)</B>, each command-line argument is checked for the existence of
the telltale &#8216;<B>=</B>&#8216; sign (reporting an error if it isn&#8217;t
there), and then is broken into two strings, the <B>name</B> which appears
before the &#8216;<B>=</B>&#8216;, and the <B>value</B> which appears after. The
<B>operator[&#160;]</B> is then used to change the existing value to the new
one.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I277">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I278"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s an example to test the
tool:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I278">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I279"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:ProgValTest.cpp</font>
<font color=#009900>//{L} ProgVals</font>
#include <font color=#004488>"ProgVals.h"</font>
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

string defaults[][2] = {
  { <font color=#004488>"color"</font>, <font color=#004488>"red"</font> },
  { <font color=#004488>"size"</font>, <font color=#004488>"medium"</font> },
  { <font color=#004488>"shape"</font>, <font color=#004488>"rectangular"</font> },
  { <font color=#004488>"action"</font>, <font color=#004488>"hopping"</font>},
};

<font color=#0000ff>const</font> <font color=#0000ff>char</font>* usage = <font color=#004488>"usage:\n"</font>
<font color=#004488>"ProgValTest [flag1=val1 flag2=val2 ...]\n"</font>
<font color=#004488>"(Note no space around '=')\n"</font>
<font color=#004488>"Where the flags can be any of: \n"</font>
<font color=#004488>"color, size, shape, action \n"</font>;

<font color=#009900>// So it can be used globally:</font>
ProgVals pvals(defaults, 
  <font color=#0000ff>sizeof</font> defaults / <font color=#0000ff>sizeof</font> *defaults);

<font color=#0000ff>class</font> Animal {
  string color, size, shape, action;
<font color=#0000ff>public</font>:
  Animal(string col, string sz, 
    string shp, string act) 
    :color(col),size(sz),shape(shp),action(act){}
  <font color=#009900>// Default constructor uses program default</font>
  <font color=#009900>// values, possibly change on command line:</font>
  Animal() : color(pvals[<font color=#004488>"color"</font>]), 
    size(pvals[<font color=#004488>"size"</font>]), shape(pvals[<font color=#004488>"shape"</font>]),
    action(pvals[<font color=#004488>"action"</font>]) {}
  <font color=#0000ff>void</font> print() {
    cout &lt;&lt; <font color=#004488>"color = "</font> &lt;&lt; color &lt;&lt; endl
      &lt;&lt; <font color=#004488>"size = "</font> &lt;&lt; size &lt;&lt; endl
      &lt;&lt; <font color=#004488>"shape = "</font> &lt;&lt; shape &lt;&lt; endl
      &lt;&lt; <font color=#004488>"action = "</font> &lt;&lt; action &lt;&lt; endl;
  }
  <font color=#009900>// And of course pvals can be used anywhere</font>
  <font color=#009900>// else you'd like.</font>
};

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  <font color=#009900>// Initialize and parse command line values</font>
  <font color=#009900>// before any code that uses pvals is called:</font>
  pvals.parse(argc, argv, usage);
  pvals.print();
  Animal a;
  cout &lt;&lt; <font color=#004488>"Animal a values:"</font> &lt;&lt; endl;
  a.print();
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This program can create <B>Animal</B>
objects with different characteristics, and those characteristics can be
established with the command line. The default characteristics are given in the
two-dimensional array of <B>char*</B> called <B>defaults</B> and, after the
<B>usage</B> string you can see a global instance of <B>ProgVals</B> called
<B>pvals </B>is created; this is important because it allows the rest of the
code in the program to access the
values.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I279">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I280"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that <B>Animal</B>&#8217;s default
constructor uses the values in <B>pvals</B> inside its constructor initializer
list. When you run the program you can try creating different animal
characteristics.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I280">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I281"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Many command-line programs also use a
style of beginning a flag with a hyphen, and sometimes they use single-character
flags.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I281">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I282"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The STL <B>map</B> is used in numerous
places throughout the rest of this
book.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I282">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I283"></a>
</FONT><A NAME="_Toc312374082"></A><A NAME="_Toc519042047"></A><BR></P></DIV>
<A NAME="Heading236"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Multimaps and duplicate keys</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>multimap</B> is a <B>map</B> that
can contain duplicate keys. At first this may seem like a strange idea, but it
can occur surprisingly often. A phone book, for example, can have many entries
with the same name. 
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I283">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I284"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Suppose you are monitoring wildlife, and
you want to keep track of where and when each type of animal is spotted. Thus,
you may see many animals of the same kind, all in different locations and at
different times. So if the type of animal is the key, you&#8217;ll need a
<B>multimap</B>. Here&#8217;s what it looks
like:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I284">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I285"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:WildLifeMonitor.cpp</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-msc}</font>
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> DataPoint {
  <font color=#0000ff>int</font> x, y; <font color=#009900>// Location coordinates</font>
  time_t time; <font color=#009900>// Time of Sighting</font>
<font color=#0000ff>public</font>:
  DataPoint() : x(0), y(0), time(0) {}
  DataPoint(<font color=#0000ff>int</font> xx, <font color=#0000ff>int</font> yy, time_t tm) :
    x(xx), y(yy), time(tm) {}
  <font color=#009900>// Synthesized operator=, copy-constructor OK</font>
  <font color=#0000ff>int</font> getX() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> x; }
  <font color=#0000ff>int</font> getY() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> y; }
  <font color=#0000ff>const</font> time_t* getTime() <font color=#0000ff>const</font> { <font color=#0000ff>return</font> &amp;time; }
};

string animal[] = { 
  <font color=#004488>"chipmunk"</font>, <font color=#004488>"beaver"</font>, <font color=#004488>"marmot"</font>, <font color=#004488>"weasel"</font>,
  <font color=#004488>"squirrel"</font>, <font color=#004488>"ptarmigan"</font>, <font color=#004488>"bear"</font>, <font color=#004488>"eagle"</font>,
  <font color=#004488>"hawk"</font>, <font color=#004488>"vole"</font>, <font color=#004488>"deer"</font>, <font color=#004488>"otter"</font>, <font color=#004488>"hummingbird"</font>,
};
<font color=#0000ff>const</font> <font color=#0000ff>int</font> asz = <font color=#0000ff>sizeof</font> animal/<font color=#0000ff>sizeof</font> *animal;
vector&lt;string&gt; animals(animal, animal + asz);

<font color=#009900>// All the information is contained in a </font>
<font color=#009900>// "Sighting," which can be sent to an ostream:</font>
<font color=#0000ff>typedef</font> pair&lt;string, DataPoint&gt; Sighting;

ostream&amp; 
<font color=#0000ff>operator</font>&lt;&lt;(ostream&amp; os, <font color=#0000ff>const</font> Sighting&amp; s) {
  <font color=#0000ff>return</font> os &lt;&lt; s.first &lt;&lt; <font color=#004488>" sighted at x= "</font> &lt;&lt; 
    s.second.getX() &lt;&lt; <font color=#004488>", y= "</font> &lt;&lt; s.second.getY()
    &lt;&lt; <font color=#004488>", time = "</font> &lt;&lt; ctime(s.second.getTime());
}

<font color=#009900>// A generator for Sightings:</font>
<font color=#0000ff>class</font> SightingGen {
  vector&lt;string&gt;&amp; animals;
  <font color=#0000ff>enum</font> { d = 100 };
<font color=#0000ff>public</font>:
  SightingGen(vector&lt;string&gt;&amp; an) :
    animals(an) { srand(time(0)); }
  Sighting <font color=#0000ff>operator</font>()() {
    Sighting result;
    <font color=#0000ff>int</font> select = rand() % animals.size();
    result.first = animals[select];
    result.second = DataPoint(
      rand() % d, rand() % d, time(0));
    <font color=#0000ff>return</font> result;
  }
};

<font color=#009900>// Display a menu of animals, allow the user to</font>
<font color=#009900>// select one, return the index value:</font>
<font color=#0000ff>int</font> menu() {
  cout &lt;&lt; <font color=#004488>"select an animal or 'q' to quit: "</font>;
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; animals.size(); i++)
    cout &lt;&lt;'['&lt;&lt; i &lt;&lt;']'&lt;&lt; animals[i] &lt;&lt; ' ';
  cout &lt;&lt; endl;
  string reply;
  cin &gt;&gt; reply;
  <font color=#0000ff>if</font>(reply.at(0) == 'q') <font color=#0000ff>return</font> 0;
  istringstream r(reply);
  <font color=#0000ff>int</font> i;
  r &gt;&gt; i; <font color=#009900>// Converts to int</font>
  i %= animals.size();
  <font color=#0000ff>return</font> i;
}

<font color=#0000ff>typedef</font> multimap&lt;string, DataPoint&gt; DataMap;
<font color=#0000ff>typedef</font> DataMap::iterator DMIter;

<font color=#0000ff>int</font> main() {
  DataMap sightings;
  generate_n(
    inserter(sightings, sightings.begin()),
    50, SightingGen(animals));
  <font color=#009900>// Print everything:</font>
  copy(sightings.begin(), sightings.end(),
    ostream_iterator&lt;Sighting&gt;(cout, <font color=#004488>""</font>));
  <font color=#009900>// Print sightings for selected animal:</font>
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> count = 1; count &lt; 10; count++) {
    <font color=#009900>// Use menu to get selection:</font>
    <font color=#009900>// int i = menu();</font>
    <font color=#009900>// Generate randomly (for automated testing):</font>
    <font color=#0000ff>int</font> i = rand() % animals.size();
    <font color=#009900>// Iterators in "range" denote begin, one </font>
    <font color=#009900>// past end of matching range:</font>
    pair&lt;DMIter, DMIter&gt; range = 
      sightings.equal_range(animals[i]);
    copy(range.first, range.second,
      ostream_iterator&lt;Sighting&gt;(cout, <font color=#004488>""</font>));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All the data about a sighting is
encapsulated into the class <B>DataPoint</B>, which is simple enough that it can
rely on the synthesized assignment and copy-constructor. It uses the Standard C
library time functions to record the time of the
sighting.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I285">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I286"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the array of <B>string</B>
<B>animal</B>, notice that the <B>char*</B> constructor is automatically used
during initialization, which makes initializing an array of <B>string</B> quite
convenient. Since it&#8217;s easier to use the animal names in a <B>vector</B>,
the length of the array is calculated and a <B>vector&lt;string&gt;</B> is
initialized using the <B>vector(iterator, iterator)</B>
constructor.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I286">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I287"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The key-value pairs that make up a
<B>Sighting</B> are the <B>string</B> which names the type of animal, and the
<B>DataPoint</B> that says where and when it was sighted. The standard
<B>pair</B> template combines these two types and is typedefed to produce the
<B>Sighting</B> type. Then an <B>ostream</B> <B>operator&lt;&lt;</B> is created
for <B>Sighting</B>; this will allow you to iterate through a map or multimap of
<B>Sighting</B>s<B> </B>and print it
out.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I287">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I288"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>SightingGen</B> generates random
sightings at random data points to use for testing. It has the usual
<B>operator(&#160;)</B> necessary for a function object, but it also has a
constructor to capture and store a reference to a <B>vector&lt;string&gt;</B>,
which is where the aforementioned animal names are
stored.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I288">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I289"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>DataMap</B> is a <B>multimap</B> of
<B>string</B>-<B>DataPoint</B> pairs, which means it stores <B>Sighting</B>s. It
is filled with 50 <B>Sighting</B>s using <B>generate_n(&#160;)</B>, and printed
out (notice that because there is an <B>operator&lt;&lt;</B> that takes a
<B>Sighting</B>, an <B>ostream_iterator</B> can be created). At this point the
user is asked to select the animal that they want to see all the sightings for.
If you press <B>&#8216;q&#8217;</B> the program will quit, but if you select an
animal number, then the <B>equal_range(&#160;)</B> member function is invoked.
This returns an iterator (<B>DMIter</B>) to the beginning of the set of matching
pairs, and one indicating past-the-end of the set. Since only one object can be
returned from a function, <B>equal_range(&#160;)</B> makes use of <B>pair</B>.
Since the <B>range</B> pair has the beginning and ending iterators of the
matching set, those iterators can be used in <B>copy(&#160;)</B> to print out
all the sightings for a particular type of
animal.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I289">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I290"></a>
</FONT><A NAME="_Toc519042048"></A><BR></P></DIV>
<A NAME="Heading237"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Multisets</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ve seen the <B>set</B>, which
only allows one object of each value to be inserted. The <B>multiset</B> is odd
by comparison since it allows more than one object of each value to be inserted.
This seems to go against the whole idea of &#8220;setness,&#8221; where you can
ask &#8220;is &#8216;it&#8217; in this set?&#8221; If there can be more than one
of &#8216;it&#8217;, then what does that question
mean?
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I290">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I291"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">With some thought, you can see that it
makes no sense to have more than one object of the same value in a set if those
duplicate objects are <I>exactly</I> the same (with the possible exception of
counting occurrences of objects, but as seen earlier in this chapter that can be
handled in an alternative, more elegant fashion). Thus each duplicate object
will have something that makes it unique from the other duplicates &#8211; most
likely different state information that is not used in the calculation of the
value during the comparison. That is, to the comparison operation, the objects
look the same but they actually contain some differing internal
state.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I291">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I292"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Like any STL container that must order
its elements, the <B>multiset</B> template uses the <B>less</B> template by
default to determine element ordering. This uses the contained classes&#8217;
<B>operator&lt;</B>, but you may of course substitute your own comparison
function.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I292">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I293"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Consider a simple class that contains one
element that is used in the comparison, and another that is
not:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I293">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I294"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:MultiSet1.cpp</font>
<font color=#009900>// Demonstration of multiset behavior</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-msc}</font>
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;ctime&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> X {
  <font color=#0000ff>char</font> c; <font color=#009900>// Used in comparison</font>
  <font color=#0000ff>int</font> i; <font color=#009900>// Not used in comparison</font>
  <font color=#009900>// Don't need default constructor and operator=</font>
  X();
  X&amp; <font color=#0000ff>operator</font>=(<font color=#0000ff>const</font> X&amp;);
  <font color=#009900>// Usually need a copy-constructor (but the</font>
  <font color=#009900>// synthesized version works here)</font>
<font color=#0000ff>public</font>:
  X(<font color=#0000ff>char</font> cc, <font color=#0000ff>int</font> ii) : c(cc), i(ii) {}
  <font color=#009900>// Notice no operator== is required</font>
  <font color=#0000ff>friend</font> <font color=#0000ff>bool</font> <font color=#0000ff>operator</font>&lt;(<font color=#0000ff>const</font> X&amp; x, <font color=#0000ff>const</font> X&amp; y) {
    <font color=#0000ff>return</font> x.c &lt; y.c;
  }
  <font color=#0000ff>friend</font> ostream&amp; <font color=#0000ff>operator</font>&lt;&lt;(ostream&amp; os, X x) {
    <font color=#0000ff>return</font> os &lt;&lt; x.c &lt;&lt; <font color=#004488>":"</font> &lt;&lt; x.i;
  }
};

<font color=#0000ff>class</font> Xgen {
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> i;
  <font color=#009900>// Number of characters to select from:</font>
  <font color=#0000ff>enum</font> { span = 6 };
<font color=#0000ff>public</font>:
  Xgen() { srand(time(0)); }
  X <font color=#0000ff>operator</font>()() {
    <font color=#0000ff>char</font> c = 'A' + rand() % span;    
    <font color=#0000ff>return</font> X(c, i++);
  }
};

<font color=#0000ff>int</font> Xgen::i = 0;

<font color=#0000ff>typedef</font> multiset&lt;X&gt; Xmset;
<font color=#0000ff>typedef</font> Xmset::const_iterator Xmit;

<font color=#0000ff>int</font> main() {
  Xmset mset;
  <font color=#009900>// Fill it with X's:</font>
  generate_n(inserter(mset, mset.begin()), 
    25, Xgen());
  <font color=#009900>// Initialize a regular set from mset:</font>
  set&lt;X&gt; unique(mset.begin(), mset.end());
  copy(unique.begin(), unique.end(), 
    ostream_iterator&lt;X&gt;(cout, <font color=#004488>" "</font>));
  cout &lt;&lt; <font color=#004488>"\n----\n"</font>;
  <font color=#009900>// Iterate over the unique values:</font>
  <font color=#0000ff>for</font>(set&lt;X&gt;::iterator i = unique.begin();
      i != unique.end(); i++) {
    pair&lt;Xmit, Xmit&gt; p = mset.equal_range(*i);
    copy(p.first, p.second, 
      ostream_iterator&lt;X&gt;(cout, <font color=#004488>" "</font>));
    cout &lt;&lt; endl;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>X</B>, all the comparisons are made
with the <B>char c</B>. The comparison is performed with <B>operator&lt;</B>,
which is all that is necessary for the <B>multiset</B>, since in this example
the default <B>less</B> comparison object is used. The class <B>Xgen</B> is used
to randomly generate <B>X</B> objects, but the comparison value is restricted to
the span from <B>&#8216;A</B>&#8217; to &#8216;<B>E</B>&#8217;. In
<B>main(&#160;)</B>, a <B>multiset&lt;X&gt;</B> is created and filled with 25
<B>X</B> objects using <B>Xgen</B>, guaranteeing that there will be duplicate
keys. So that we know what the unique values are, a regular <B>set&lt;X&gt;</B>
is created from the <B>multiset</B> (using the <B>iterator, iterator</B>
constructor). These values are displayed, then each one is used to produce the
<B>equal_range(&#160;)</B> in the <B>multiset</B> (<B>equal_range(&#160;)</B>
has the same meaning here as it does with <B>multimap</B>: all the elements with
matching keys). Each set of matching keys is then
printed.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I294">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I295"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As a second example, a (possibly) more
elegant version of <B>WordCount.cpp</B> can be created using
<B>multiset</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I295">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I296"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:MultiSetWordCount.cpp</font>
<font color=#009900>//{L} StreamTokenizer ../TestSuite/Test</font>
<font color=#009900>//{-g++295}</font>
<font color=#009900>// Count occurrences of words using a multiset</font>
#include <font color=#004488>"StreamTokenizer.h"</font>
#include <font color=#004488>"..</font><font color=#004488>/require.h"</font>
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;fstream&gt;
#include &lt;iterator&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  <font color=#0000ff>char</font>* fname = <font color=#004488>"MultiSetWordCount.cpp"</font>;
  <font color=#0000ff>if</font>(argc &gt; 1) fname = argv[1];
  ifstream in(fname);
  assure(in, fname);
  StreamTokenizer words(in);
  multiset&lt;string&gt; wordmset;
  string word;
  <font color=#0000ff>while</font>((word = words.next()).size() != 0)
    wordmset.insert(word);
  <font color=#0000ff>typedef</font> multiset&lt;string&gt;::iterator MSit;
  MSit it = wordmset.begin();
  <font color=#0000ff>while</font>(it != wordmset.end()) {
    pair&lt;MSit, MSit&gt; p=wordmset.equal_range(*it);
    <font color=#0000ff>int</font> count = distance(p.first, p.second);
    cout &lt;&lt; *it &lt;&lt; <font color=#004488>": "</font> &lt;&lt; count &lt;&lt; endl;
    it = p.second; <font color=#009900>// Move to the next word</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The setup in <B>main(&#160;)</B> is
identical to <B>WordCount.cpp</B>, but then each word is simply inserted into
the <B>multiset&lt;string&gt;</B>. An iterator is created and initialized to the
beginning of the <B>multiset</B>; dereferencing this iterator produces the
current word. <B>equal_range(&#160;)</B> produces the starting and ending
iterators of the word that&#8217;s currently selected, and the STL algorithm
<B>distance(&#160;)</B> (which is in <B>&lt;iterator&gt;</B>) is used to count
the number of elements in that range. Then the iterator <B>it </B>is moved
forward to the end of the range, which puts it at the next word. Although if
you&#8217;re unfamiliar with the <B>multiset</B> this code can seem more
complex, the density of it and the lack of need for supporting classes like
<B>Count</B> has a lot of
appeal.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I296">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I297"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the end, is this really a
&#8220;set,&#8221; or should it be called something else? An alternative is the
generic &#8220;bag&#8221; that has been defined in some container libraries,
since a bag holds anything at all without discrimination &#8211; including
duplicate objects. This is close, but it doesn&#8217;t quite fit since a bag has
no specification about how elements should be ordered, while a <B>multiset</B>
(which requires that all duplicate elements be adjacent to each other) is even
more restrictive than the concept of a set, which could use a hashing function
to order its elements, in which case they would not be in sorted order. Besides,
if you wanted to store a bunch of objects without any special criterions,
you&#8217;d probably just use a <B>vector</B>, <B>deque</B> or <B>list</B>.

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I297">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I298"></a>
</FONT><A NAME="_Toc519042049"></A><BR></P></DIV>
<A NAME="Heading238"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Combining STL containers</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When using a thesaurus, you have a word
and you want to know all the words that are similar. When you look up a word,
then, you want a list of words as the result. Here, the &#8220;multi&#8221;
containers (<B>multimap</B> or <B>multiset</B>) are not appropriate. The
solution is to combine containers, which is easily done using the STL. Here, we
need a tool that turns out to be a powerful general concept, which is a
<B>map</B> of
<B>vector</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I298">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I299"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:Thesaurus.cpp</font>
<font color=#009900>// A map of vectors</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-msc}</font>
<font color=#009900>//{-g++3}</font>
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>typedef</font> map&lt;string, vector&lt;string&gt; &gt; Thesaurus;
<font color=#0000ff>typedef</font> pair&lt;string, vector&lt;string&gt; &gt; TEntry;
<font color=#0000ff>typedef</font> Thesaurus::iterator TIter;

ostream&amp; <font color=#0000ff>operator</font>&lt;&lt;(ostream&amp; os,<font color=#0000ff>const</font> TEntry&amp; t){
  os &lt;&lt; t.first &lt;&lt; <font color=#004488>": "</font>;
  copy(t.second.begin(), t.second.end(),
    ostream_iterator&lt;string&gt;(os, <font color=#004488>" "</font>));
  <font color=#0000ff>return</font> os;
}

<font color=#009900>// A generator for thesaurus test entries:</font>
<font color=#0000ff>class</font> ThesaurusGen {
  <font color=#0000ff>static</font> <font color=#0000ff>const</font> string letters;
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> count;
<font color=#0000ff>public</font>:
  <font color=#0000ff>int</font> maxSize() { <font color=#0000ff>return</font> letters.size(); }
  ThesaurusGen() { srand(time(0)); }
  TEntry <font color=#0000ff>operator</font>()() {
    TEntry result;
    <font color=#0000ff>if</font>(count &gt;= maxSize()) count = 0;
    result.first = letters[count++];
    <font color=#0000ff>int</font> entries = (rand() % 5) + 2;
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; entries; i++) {
      <font color=#0000ff>int</font> choice = rand() % maxSize();
      <font color=#0000ff>char</font> cbuf[2] = { 0 };
      cbuf[0] = letters[choice];
      result.second.push_back(cbuf);
    }
    <font color=#0000ff>return</font> result;
  }
};

<font color=#0000ff>int</font> ThesaurusGen::count = 0;
<font color=#0000ff>const</font> string ThesaurusGen::letters(<font color=#004488>"ABCDEFGHIJKL"</font>
  <font color=#004488>"MNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"</font>);

<font color=#009900>// Ask for a "word" to look up:</font>
string menu(Thesaurus&amp; thesaurus) {
  <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
    cout &lt;&lt; <font color=#004488>"Select a \"</font>word\<font color=#004488>", 0 to quit: "</font>;
    <font color=#0000ff>for</font>(TIter it = thesaurus.begin(); 
      it != thesaurus.end(); it++)
      cout &lt;&lt; (*it).first &lt;&lt; ' ';
    cout &lt;&lt; endl;
    string reply;
    cin &gt;&gt; reply;
    <font color=#0000ff>if</font>(reply.at(0) == '0') exit(0); <font color=#009900>// Quit</font>
    <font color=#0000ff>if</font>(thesaurus.find(reply) == thesaurus.end())
      <font color=#0000ff>continue</font>; <font color=#009900>// Not in list, try again</font>
    <font color=#0000ff>return</font> reply;
  }
}

<font color=#0000ff>int</font> main() {
  Thesaurus thesaurus;
  <font color=#009900>// Fill with 10 entries:</font>
  generate_n(
    inserter(thesaurus, thesaurus.begin()), 
    10, ThesaurusGen());
  <font color=#009900>// Print everything:</font>
  copy(thesaurus.begin(), thesaurus.end(),
    ostream_iterator&lt;TEntry&gt;(cout, <font color=#004488>"\n"</font>));
  <font color=#009900>// Create a list of the keys:</font>
  string keys[10];
  <font color=#0000ff>int</font> i = 0;
  <font color=#0000ff>for</font>(TIter it = thesaurus.begin(); 
    it != thesaurus.end(); it++)
    keys[i++] = (*it).first;
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> count = 0; count &lt; 10; count++) {
    <font color=#009900>// Enter from the console:</font>
    <font color=#009900>// string reply = menu(thesaurus);</font>
    <font color=#009900>// Generate randomly (for automated testing):</font>
    string reply = keys[rand() % 10];
    vector&lt;string&gt;&amp; v = thesaurus[reply];
    copy(v.begin(), v.end(), 
      ostream_iterator&lt;string&gt;(cout, <font color=#004488>" "</font>));
    cout &lt;&lt; endl;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>Thesaurus</B> maps a <B>string</B>
(the word) to a <B>vector&lt;string&gt;</B> (the synonyms). A <B>TEntry </B>is a
single entry in a <B>Thesaurus</B>. By creating an <B>ostream
operator&lt;&lt;</B> for a <B>TEntry</B>, a single entry from the
<B>Thesaurus</B> can easily be printed (and the whole <B>Thesaurus</B> can
easily be printed with <B>copy(&#160;)</B>). The <B>ThesaurusGen</B> creates
&#8220;words&#8221; (which are just single letters) and &#8220;synonyms&#8221;
for those words (which are just other randomly-chosen single letters) to be used
as thesaurus entries. It randomly chooses the number of synonym entries to make,
but there must be at least two. All the letters are chosen by indexing into a
<B>static string</B> that is part of
<B>ThesaurusGen</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I299">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I300"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>main(&#160;)</B>, a
<B>Thesaurus</B> is created, filled with 10 entries and printed using the
<B>copy(&#160;)</B> algorithm. The <B>menu( )</B> function ask user to choose a
&#8220;word&#8221; to look up by typing the letter of that word. The
<B>find(&#160;)</B> member function is used to find whether the entry exists in
the <B>map</B> (remember, you don&#8217;t want to use <B>operator[ ]</B> or it
will automatically make a new entry if it doesn&#8217;t find a match!). If so,
<B>operator[ ]</B> is used to fetch out the <B>vector&lt;string&gt;</B> which is
displayed.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the above code, the selection of the
<B>reply</B>
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I300">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I301"></a>
 string is generated
randomly, to allow automated testing.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because templates make the expression of
powerful concepts easy, you can take this concept much further, creating a
<B>map</B> of <B>vector</B>s containing <B>map</B>s, etc. For that matter, you
can combine any of the STL containers this
way.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I301">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I302"></a>
</FONT><A NAME="_Toc519042050"></A><BR></P></DIV>
<A NAME="Heading239"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Cleaning up <BR>containers of pointers</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>Stlshape.cpp</B>, the pointers did
not clean themselves up automatically. It would be convenient to be able to do
this easily, rather than writing out the code each time. Here is a function
template that will clean up the pointers in any sequence container; note that it
is placed in the book&#8217;s root directory for easy
access:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I302">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I303"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: :purge.h</font>
<font color=#009900>// Delete pointers in an STL sequence container</font>
#ifndef PURGE_H
#define PURGE_H
#include &lt;algorithm&gt;

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> Seq&gt; <font color=#0000ff>void</font> purge(Seq&amp; c) {
  <font color=#0000ff>typename</font> Seq::iterator i;
  <font color=#0000ff>for</font>(i = c.begin(); i != c.end(); i++) {
    <font color=#0000ff>delete</font> *i;
    *i = 0;
  }
}

<font color=#009900>// Iterator version:</font>
<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> InpIt&gt;
<font color=#0000ff>void</font> purge(InpIt begin, InpIt end) {
  <font color=#0000ff>while</font>(begin != end) {
    <font color=#0000ff>delete</font> *begin;
    *begin = 0;
    begin++;
  }
}
#endif <font color=#009900>// PURGE_H ///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the first version of
<B>purge(&#160;)</B>, note that <B>typename</B> is absolutely necessary; indeed
this is exactly the case that the keyword was added for: <B>Seq</B> is a
template argument, and <B>iterator</B> is something that is nested within that
template. So what does <B>Seq::iterator</B> refer to? The <B>typename</B>
keyword specifies that it refers to a type, and not something
else.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I303">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I304"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">While the container version of purge must
work with an STL-style container, the iterator version of <B>purge(&#160;)</B>
will work with any range, including an
array.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I304">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I305"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here is <B>Stlshape.cpp</B>, modified to
use the <B>purge(&#160;)</B>
function:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I305">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I306"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:Stlshape2.cpp</font>
<font color=#009900>// Stlshape.cpp with the purge() function</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
#include <font color=#004488>"..</font><font color=#004488>/purge.h"</font>
#include &lt;vector&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>class</font> Shape {
<font color=#0000ff>public</font>:
  <font color=#0000ff>virtual</font> <font color=#0000ff>void</font> draw() = 0;
  <font color=#0000ff>virtual</font> ~Shape() {};
};

<font color=#0000ff>class</font> Circle : <font color=#0000ff>public</font> Shape {
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> draw() { cout &lt;&lt; <font color=#004488>"Circle::draw\n"</font>; }
  ~Circle() { cout &lt;&lt; <font color=#004488>"~Circle\n"</font>; }
};

<font color=#0000ff>class</font> Triangle : <font color=#0000ff>public</font> Shape {
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> draw() { cout &lt;&lt; <font color=#004488>"Triangle::draw\n"</font>; }
  ~Triangle() { cout &lt;&lt; <font color=#004488>"~Triangle\n"</font>; }
};

<font color=#0000ff>class</font> Square : <font color=#0000ff>public</font> Shape {
<font color=#0000ff>public</font>:
  <font color=#0000ff>void</font> draw() { cout &lt;&lt; <font color=#004488>"Square::draw\n"</font>; }
  ~Square() { cout &lt;&lt; <font color=#004488>"~Square\n"</font>; }
};

<font color=#0000ff>typedef</font> std::vector&lt;Shape*&gt; Container;
<font color=#0000ff>typedef</font> Container::iterator Iter;

<font color=#0000ff>int</font> main() {
  Container shapes;
  shapes.push_back(<font color=#0000ff>new</font> Circle);
  shapes.push_back(<font color=#0000ff>new</font> Square);
  shapes.push_back(<font color=#0000ff>new</font> Triangle);
  <font color=#0000ff>for</font>(Iter i = shapes.begin();
      i != shapes.end(); i++)
    (*i)-&gt;draw();
  purge(shapes);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When using <B>purge(&#160;)</B>, you must
be careful to consider ownership issues &#8211; if an object pointer is held in
more than one container, then you must be sure not to delete it twice, and you
don&#8217;t want to destroy the object in the first container before the second
one is finished with it. Purging the same container twice is not a problem,
because <B>purge(&#160;)</B> sets the pointer to zero once it deletes that
pointer, and calling <B>delete</B> for a zero pointer is a safe
operation.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I306">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I307"></a>
</FONT><A NAME="_Toc519042051"></A><BR></P></DIV>
<A NAME="Heading240"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Creating your own containers</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">With the STL as a foundation, it&#8217;s
possible to create your own containers. Assuming you follow the same model of
providing iterators, your new container will behave as if it were a built-in STL
container.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I307">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I308"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Consider the &#8220;ring&#8221; data
structure, which is a circular sequence container. If you reach the end, it just
wraps around to the beginning. This can be implemented on top of a <B>list</B>
as follows:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I308">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I309"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:Ring.cpp</font>
<font color=#009900>// Making a "ring" data structure from the STL</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-g++295}</font>
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;string&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>template</font>&lt;<font color=#0000ff>class</font> T&gt;
<font color=#0000ff>class</font> Ring {
  list&lt;T&gt; lst;
<font color=#0000ff>public</font>:
  <font color=#009900>// Declaration necessary so the following </font>
  <font color=#009900>// 'friend' statement sees this 'iterator' </font>
  <font color=#009900>// instead of std::iterator:</font>
  <font color=#0000ff>class</font> iterator;
  <font color=#0000ff>friend</font> <font color=#0000ff>class</font> iterator;
  <font color=#0000ff>class</font> iterator : <font color=#0000ff>public</font> std::iterator&lt;
    std::bidirectional_iterator_tag,T,ptrdiff_t&gt;{
    list&lt;T&gt;::iterator it;
    list&lt;T&gt;* r;
  <font color=#0000ff>public</font>:
    <font color=#009900>// "typename" necessary to resolve nesting:</font>
    iterator(list&lt;T&gt;&amp; lst,
      <font color=#0000ff>const</font> <font color=#0000ff>typename</font> list&lt;T&gt;::iterator&amp; i)
      : r(&amp;lst), it(i) {}
    <font color=#0000ff>bool</font> <font color=#0000ff>operator</font>==(<font color=#0000ff>const</font> iterator&amp; x) <font color=#0000ff>const</font> {
      <font color=#0000ff>return</font> it == x.it;
    }
    <font color=#0000ff>bool</font> <font color=#0000ff>operator</font>!=(<font color=#0000ff>const</font> iterator&amp; x) <font color=#0000ff>const</font> {
      <font color=#0000ff>return</font> !(*<font color=#0000ff>this</font> == x);
    }
    list&lt;T&gt;::reference <font color=#0000ff>operator</font>*() <font color=#0000ff>const</font> {
      <font color=#0000ff>return</font> *it;
    }
    iterator&amp; <font color=#0000ff>operator</font>++() {
      ++it;
      <font color=#0000ff>if</font>(it == r-&gt;end())
        it = r-&gt;begin();
      <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
    }
    iterator <font color=#0000ff>operator</font>++(<font color=#0000ff>int</font>) {
      iterator tmp = *<font color=#0000ff>this</font>;
      ++*<font color=#0000ff>this</font>;
      <font color=#0000ff>return</font> tmp;
    }
    iterator&amp; <font color=#0000ff>operator</font>--() {
      <font color=#0000ff>if</font>(it == r-&gt;begin())
        it = r-&gt;end();
      --it;
      <font color=#0000ff>return</font> *<font color=#0000ff>this</font>;
    }
    iterator <font color=#0000ff>operator</font>--(<font color=#0000ff>int</font>) {
      iterator tmp = *<font color=#0000ff>this</font>;
      --*<font color=#0000ff>this</font>; 
      <font color=#0000ff>return</font> tmp;
    }
    iterator insert(<font color=#0000ff>const</font> T&amp; x){
      <font color=#0000ff>return</font> iterator(*r, r-&gt;insert(it, x));
    }
    iterator erase() {
      <font color=#0000ff>return</font> iterator(*r, r-&gt;erase(it));
    }
  };
  <font color=#0000ff>void</font> push_back(<font color=#0000ff>const</font> T&amp; x) {
    lst.push_back(x);
  }
  iterator begin() {
    <font color=#0000ff>return</font> iterator(lst, lst.begin());
  }
 <font color=#0000ff>int</font> size() { <font color=#0000ff>return</font> lst.size(); }
};

<font color=#0000ff>int</font> main() {
  Ring&lt;string&gt; rs;
  rs.push_back(<font color=#004488>"one"</font>);
  rs.push_back(<font color=#004488>"two"</font>);
  rs.push_back(<font color=#004488>"three"</font>);
  rs.push_back(<font color=#004488>"four"</font>);
  rs.push_back(<font color=#004488>"five"</font>);
  Ring&lt;string&gt;::iterator it = rs.begin();
  it++; it++;
  it.insert(<font color=#004488>"six"</font>);
  it = rs.begin();
  <font color=#009900>// Twice around the ring:</font>
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; rs.size() * 2; i++)
    cout &lt;&lt; *it++ &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that the iterator is where
most of the coding is done. The <B>Ring</B> <B>iterator</B> must know how to
loop back to the beginning, so it must keep a reference to the <B>list </B>of<B>
</B>its &#8220;parent&#8221; <B>Ring</B> object in order to know if it&#8217;s
at the end and how to get back to the
beginning.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I309">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I310"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll notice that the interface
for <B>Ring</B> is quite limited; in particular there is no <B>end(&#160;)</B>,
since a ring just keeps looping. This means that you won&#8217;t be able to use
a <B>Ring</B> in any STL algorithms that require a past-the-end iterator &#8211;
which is many of them. (It turns out that adding this feature is a non-trivial
exercise). Although this can seem limiting, consider <B>stack</B>, <B>queue</B>
and <B>priority_queue</B>, which don&#8217;t produce any iterators at
all!
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I310">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I311"></a>
</FONT><A NAME="_Toc519042052"></A><BR></P></DIV>
<A NAME="Heading241"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Freely-available <BR>STL extensions</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although the STL containers may provide
all the functionality you&#8217;ll ever need, they are not complete. For
example, the standard implementations of <B>set</B> and <B>map</B> use trees,
and although these are reasonably fast they may not be fast enough for your
needs. In the C++ Standards Committee it was generally agreed that hashed
implementations of <B>set</B> and <B>map</B> should have been included in
Standard C++, however there was not considered to be enough time to add these
components, and thus they were left
out.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I311">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I312"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Fortunately, there are freely-available
alternatives. One of the nice things about the STL is that it establishes a
basic model for creating STL-like classes, so anything built using the same
model is easy to understand if you are already familiar with the
STL.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I312">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I313"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The SGI STL (freely available at
http://www.sgi.com/Technology/STL/) is one of the most robust implementations of
the STL, and can be used to replace your compiler&#8217;s STL if that is found
wanting. In addition they&#8217;ve added a number of extensions including
<B>hash_set</B>, <B>hash_multiset</B>, <B>hash_map</B>, <B>hash_multimap</B>,
<B>slist</B> (a singly-linked list) and <B>rope</B> (a variant of <B>string</B>
optimized for very large strings and fast concatenation and substring
operations).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I313">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I314"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Let&#8217;s consider a performance
comparison between a tree-based <B>map</B> and the SGI <B>hash_map</B>. To keep
things simple, the mappings will be from <B>int</B> to
<B>int</B>:
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I314">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I315"></a>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C07:MapVsHashMap.cpp</font>
<font color=#009900>// The hash_map header is not part of the </font>
<font color=#009900>// Standard C++ STL. It is an extension that </font>
<font color=#009900>// is only available as part of the SGI STL</font>
<font color=#009900>// (It is included with the g++ distribution)</font>
<font color=#009900>//{L} ../TestSuite/Test</font>
<font color=#009900>//{-bor} You can add the header by hand</font>
<font color=#009900>//{-msc} You can add the header by hand</font>
<font color=#009900>//{-g++3}</font>
#include &lt;hash_map&gt; 
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;ctime&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main(){
  hash_map&lt;<font color=#0000ff>int</font>, <font color=#0000ff>int</font>&gt; hm;
  map&lt;<font color=#0000ff>int</font>, <font color=#0000ff>int</font>&gt; m;
  clock_t ticks = clock();
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 100; i++)
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; 1000; j++)
      m.insert(make_pair(j,j));
  cout &lt;&lt; <font color=#004488>"map insertions: "</font> 
    &lt;&lt; clock() - ticks &lt;&lt; endl;
  ticks = clock();
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 100; i++)
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; 1000; j++)
      hm.insert(make_pair(j,j));
  cout &lt;&lt; <font color=#004488>"hash_map insertions: "</font> 
    &lt;&lt; clock() - ticks &lt;&lt; endl;
  ticks = clock();
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 100; i++)
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; 1000; j++)
      m[j];
  cout &lt;&lt; <font color=#004488>"map::operator[] lookups: "</font> 
    &lt;&lt; clock() - ticks &lt;&lt; endl;
  ticks = clock();
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 100; i++)
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; 1000; j++)
      hm[j];
  cout &lt;&lt; <font color=#004488>"hash_map::operator[] lookups: "</font>
    &lt;&lt; clock() - ticks &lt;&lt; endl;
  ticks = clock();
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 100; i++)
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; 1000; j++)
      m.find(j);
  cout &lt;&lt; <font color=#004488>"map::find() lookups: "</font>
    &lt;&lt; clock() - ticks &lt;&lt; endl;
  ticks = clock();
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 100; i++)
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; 1000; j++)
      hm.find(j);
  cout &lt;&lt; <font color=#004488>"hash_map::find() lookups: "</font> 
    &lt;&lt; clock() - ticks &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The performance test I ran showed a speed
improvement of roughly 4:1 for the <B>hash_map</B> over the <B>map</B> in all
operations (and as expected, <B>find(&#160;)</B> is slightly faster than
<B>operator[ ]</B> for lookups for both types of map). If a profiler shows a
bottleneck in your <B>map</B>, you should consider a
<B>hash_map</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I315">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I316"></a>
</FONT><A NAME="_Toc519042053"></A><BR></P></DIV>
<A NAME="Heading242"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Non-STL containers<A NAME="_Toc519042054"></A></H2></FONT>
<A NAME="Heading243"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Bitset<A NAME="_Toc519042055"></A></H3></FONT>
<A NAME="Heading244"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H3 ALIGN="LEFT">
Valarray<A NAME="_Toc519042056"></A></H3></FONT>
<A NAME="Heading245"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Summary</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The goal of this chapter was not just to
introduce the STL containers in some considerable depth (of course, not every
detail could be covered here, but you should have enough now that you can look
up further information in the other resources). My higher hope is that this
chapter has made you grasp the incredible power available in the STL, and shown
you how much faster and more efficient your programming activities can be by
using and understanding the
STL.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I316">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I317"></a>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The fact that I could not escape from
introducing some of the STL algorithms in this chapter suggests how useful they
can be. In the next chapter you&#8217;ll get a much more focused look at the
algorithms.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I317">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I318"></a>
</FONT><A NAME="_Toc519042057"></A><BR></P></DIV>
<A NAME="Heading246"></A><FONT FACE = "Verdana, Tahoma, Arial, Helvetica, Sans"><H2 ALIGN="LEFT">
Exercises</H2></FONT>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create a
<B>set&lt;char&gt;</B>, then open a file (whose name is provided on the command
line) and read that file in a char at a time, placing each char in the set.
Print the results and observe the organization, and whether there are any
letters in the alphabet that are not used in that particular
file.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I318">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I319"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
a kind of &#8220;hangman&#8221; game. Create a class that contains a char and a
bool to indicate whether that char has been guessed yet. Randomly select a word
from a file, and read it into a vector of your new type. Repeatedly ask the user
for a character guess, and after each guess display the characters in the word
that have been guessed, and underscores for the characters that haven&#8217;t.
Allow a way for the user to guess the whole word. Decrement a value for each
guess, and if the user can get the whole word before the value goes to zero,
they
win.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I319">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I320"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>WordCount.cpp</B> so that it uses <B>insert(&#160;)</B> instead of
<B>operator[&#160;]</B> to insert elements in the
map.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I320">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I321"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>WordCount.cpp</B> so that it uses a <B>multimap</B> instead of a
<B>map</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I321">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I322"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
a generator that produces random int values between 0 and 20. Use this to fill a
<B>multiset&lt;int&gt;</B>. Count the occurrences of each value, following the
example given in
<B>MultiSetWordCount.cpp</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I322">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I323"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Change
<B>StlShape.cpp</B> so that it uses a deque instead of a
vector.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I323">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I324"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>Reversible.cpp</B> so it works with <B>deque</B> and <B>list</B> instead of
<B>vector</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I324">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I325"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>Progvals.h</B> and <B>ProgVals.cpp</B> so that they expect leading hyphens to
distinguish command-line
arguments.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I325">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I326"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
a second version of <B>Progvals.h</B> and <B>ProgVals.cpp</B> that uses a
<B>set</B> instead of a <B>map</B> to manage single-character flags on the
command line (such as -a -b -c etc) and also allows the characters to be ganged
up behind a single hyphen (such as
-abc).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I326">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I327"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Use
a <B>stack&lt;int&gt;</B> and build a Fibonacci sequence on the stack. The
program&#8217;s command line should take the number of Fibonacci elements
desired, and you should have a loop that looks at the last two elements on the
stack and pushes a new one for every pass through the
loop.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I327">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I328"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Open
a text file whose name is provided on the command line. Read the file a word at
a time (hint: use <B>&gt;&gt;</B>) and use a <B>multiset&lt;string&gt;</B> to
create a word count for each
word.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I328">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I329"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>BankTeller.cpp</B> so that the policy that decides when a teller is added or
removed is encapsulated inside a
class.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I329">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I330"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
two classes <B>A</B> and <B>B</B> (feel free to choose more interesting names).
Create a <B>multimap&lt;A, B&gt;</B> and fill it with key-value pairs, ensuring
that there are some duplicate keys. Use <B>equal_range(&#160;)</B> to discover
and print a range of objects with duplicate keys. Note you may have to add some
functions in <B>A</B> and/or <B>B</B> to make this program
work.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I330">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I331"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Perform
the above exercise for <B>a
multiset&lt;A&gt;</B>.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I331">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I332"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
a class that has an operator&lt; and an ostream&amp; operator&lt;&lt;. The class
should contain a priority number. Create a generator for your class that makes a
random priority number. Fill a priority_queue using your generator, then pull
the elements out to show they are in the proper
order.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I332">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I333"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Rewrite
Ring.cpp so it uses a deque instead of a list for its underlying
implementation.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I333">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I334"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
Ring.cpp so that the underlying implementation can be chosen using a template
argument (let that template argument default to
list).
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I334">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I335"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Open
a file and read it into a single string. Turn the string into a stringstream.
Read tokens from the stringstream into a list&lt;string&gt; using a
TokenIterator.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I335">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I336"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Compare
the performance of stack based on whether it is implemented with vector, deque
or
list.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I336">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I337"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
an iterator class called BitBucket that just absorbs whatever you send to it
without writing it
anywhere.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I337">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I338"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
a template that implements a singly-linked list called SList. Provide a default
constructor, begin(&#160;) and end(&#160;) functions (thus you must create the
appropriate nested iterator), insert(&#160;), erase(&#160;) and a destructor.

[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I338">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I339"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">(More
challenging) Create a little command language. Each command can simply print its
name and its arguments, but you may also want to make it perform other
activities like run programs. The commands will be read from a file that you
pass as an command-line argument, or from standard input if no file is given.
Each command is on a single line, and lines beginning with &#8216;#&#8217; are
comments. A line begins with the one-word command itself, followed by any number
of arguments. Commands and arguments are separated by spaces. Use a map that
maps string objects (the name of the command) to object pointers. The object
pointers point to objects of a base class Command that has a virtual
execute(string args) function, where args contains all the arguments for that
command (execute(&#160;) will parse its own arguments from args). Each different
type of command is represented by a class that is inherited from
Command.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I339">Comment</a>&nbsp;]

<a NAME="TIC2V2_CHAPTER7_I340"></a>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Add
features to the above exercise so that you can have labels, if-then statements,
and the ability to jump program execution to a
label.
[&nbsp;<a HREF="mailto:cda@freshsources.com?subject=[TICV2] TIC2V2_CHAPTER7_I340">Comment</a>&nbsp;]

</FONT></OL>
<HR><DIV ALIGN="LEFT"><P><A NAME="fn19" HREF="#fnB19">[19]</A><FONT FACE="Georgia" SIZE=2>
Contributed to the C++ Standard by Alexander Stepanov and Meng Lee at
Hewlett-Packard.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn20" HREF="#fnB20">[20]</A><FONT FACE="Georgia" SIZE=2>
These were actually created to abstract the &#8220;locale&#8221; facets away
from iostreams, so that locale facets could operate on any sequence of
characters, not only iostreams. Locales allow iostreams to easily handle
culturally-different formatting (such as representation of money), and are
beyond the scope of this book.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn21" HREF="#fnB21">[21]</A><FONT FACE="Georgia" SIZE=2>
I am indebted to Nathan Myers for explaining this to me.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn22" HREF="#fnB22">[22]</A><FONT FACE="Georgia" SIZE=2>
This is another example coached by Nathan Myers.</FONT><BR></P></DIV>

<DIV ALIGN="CENTER">
    <FONT FACE="Verdana, Tahoma, Arial, Helvetica, Sans" size = "-1">
     [ <a href="Chap06.htm">Previous Chapter</a> ] 
    
    [ <a href="SimpCont.htm">Short TOC</a> ] 
    [ <a href="Contents.htm">Table of Contents</a> ] 
  
        [ <a href="DocIdx.htm">Index</a> ]
        
     [ <a href="Chap08.htm">Next Chapter</a> ] 
    </FONT>
    <BR>
 Last Update:08/19/2001</P></DIV>

</BODY>

</HTML>
